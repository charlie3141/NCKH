<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gangtay — Firebase realtime + robust mobile play</title>
<style>
  body{font-family:system-ui,Arial;padding:14px;max-width:980px;margin:auto}
  h1{margin:0 0 8px 0}
  label{display:block;margin-top:8px;font-weight:600}
  input, button {padding:10px;margin:6px 0;width:100%;box-sizing:border-box}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .half{flex:1 1 48%}
  #log{font-family:monospace;background:#111;color:#e6e6e6;padding:12px;border-radius:8px;min-height:220px;white-space:pre-wrap;overflow:auto}
  #manualHolder{margin-top:8px}
  .ok{color:limegreen}
  .err{color:crimson}
  small{color:#888}
</style>
</head>
<body>
  <h1>Gangtay — Firebase realtime + robust mobile play</h1>
  <p style="color:#666;margin:0 0 12px 0">
    Tries real-time streaming (EventSource) → falls back to polling. Numeric text payloads are treated as indexes (e.g. "2" → 0002.mp3). If autoplay blocked, a manual <code>&lt;audio controls&gt;</code> will appear.
  </p>

  <label>Audio base (folder or absolute URL)</label>
  <input id="audioBase" value="/audio/" />

  <label>Firebase message.json URL</label>
  <input id="firebaseUrl" value="https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json" />

  <div class="row">
    <button id="startSse" class="half">Start SSE (Realtime)</button>
    <button id="stopSse" class="half">Stop SSE</button>
  </div>

  <div class="row">
    <button id="fetchOne" class="half">Fetch Firebase (one-shot)</button>
    <button id="startPoll" class="half">Start Polling (fallback)</button>
  </div>

  <div class="row">
    <button id="stopPoll" class="half">Stop Polling</button>
    <input id="pollMs" class="half" type="number" value="800" min="100" />
  </div>

  <div class="row">
    <button id="unlockBtn" class="half">Unlock audio (tap once)</button>
    <button id="clearLog" class="half">Clear log</button>
  </div>

  <div id="manualHolder"></div>

  <div id="status" style="margin-top:10px">Status: idle</div>
  <pre id="log">Script not yet started...</pre>

<script>
/*
  Realtime + fallback player:
  - SSE target: firebaseUrl (should be the .json path like ".../message.json")
  - on SSE 'put'/'patch'/'message' parse and handle payload
  - fallback polling if SSE fails
  - mobile-friendly: will not force play when locked; will show manual control if autoplay blocked
*/

const audioBaseEl = document.getElementById('audioBase');
const firebaseUrlEl = document.getElementById('firebaseUrl');
const startSseBtn = document.getElementById('startSse');
const stopSseBtn = document.getElementById('stopSse');
const fetchOneBtn = document.getElementById('fetchOne');
const startPollBtn = document.getElementById('startPoll');
const stopPollBtn = document.getElementById('stopPoll');
const pollMsEl = document.getElementById('pollMs');
const unlockBtn = document.getElementById('unlockBtn');
const clearLogBtn = document.getElementById('clearLog');
const manualHolder = document.getElementById('manualHolder');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');

let audioCtx = null;
let masterGain = null;
let unlocked = false;

let sse = null;
let sseActive = false;

let pollId = null;
let inFlight = false;
let lastPayloadStr = null;

// single-slot pending while locked
let pendingPayload = null;

function now(){ return new Date().toLocaleTimeString(); }
function log(msg, cls){
  const line = `[${now()}] ${msg}`;
  logEl.textContent = line + '\n' + logEl.textContent;
  if (cls === 'err') statusEl.style.color = 'crimson';
  else if (cls === 'ok') statusEl.style.color = 'limegreen';
  else statusEl.style.color = '';
  console.log(line);
}
function setStatus(s){ statusEl.textContent = 'Status: ' + s; log(s); }

function pad4(n){ return String(n).padStart(4,'0'); }
function fileUrlForIndex(i){
  const base = (audioBaseEl.value || '/audio/').trim();
  const fname = pad4(i) + '.mp3';
  if (/^https?:\/\//i.test(base)) return (base.endsWith('/') ? base + fname : base + '/' + fname) + '?ts=' + Date.now();
  if (base.startsWith('/')) return location.origin + (base.endsWith('/') ? base + fname : base + '/' + fname) + '?ts=' + Date.now();
  return location.origin + '/' + (base.endsWith('/') ? base + fname : base + '/' + fname) + '?ts=' + Date.now();
}

/* --- Audio utilities --- */
function ensureAudioCtx(){
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 1.0;
    masterGain.connect(audioCtx.destination);
    log('AudioContext created', 'ok');
  } catch(e) {
    log('AudioContext creation failed: ' + e, 'err');
  }
}
async function tryUnlockSequence(){
  if (unlocked) return true;
  ensureAudioCtx();
  try {
    if (audioCtx.state === 'running') { unlocked = true; return true; }
    const a = new Audio(); a.muted = true;
    try { await a.play(); } catch(e){}
    if (audioCtx.state === 'running') { unlocked = true; return true; }
    // tone fallback
    const nowt = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine'; o.frequency.value = 880;
    g.gain.value = 0.0001;
    o.connect(g); g.connect(masterGain);
    g.gain.setValueAtTime(0.0001, nowt);
    g.gain.linearRampToValueAtTime(0.06, nowt + 0.01);
    o.start(nowt);
    g.gain.linearRampToValueAtTime(0.0001, nowt + 0.12);
    o.stop(nowt + 0.13);
    try { await audioCtx.resume(); } catch(e){}
    unlocked = (audioCtx.state === 'running');
    log('Unlock attempt finished — unlocked=' + unlocked);
    return unlocked;
  } catch(e) { log('Unlock error: ' + e, 'err'); return false; }
}

/* --- Play sequence (tries element -> blob element -> WebAudio decode) --- */
async function playSequenceForIndex(i) {
  const url = fileUrlForIndex(i);
  log('playSequence: index=' + i + ' url=' + url);

  // 1) direct element
  try {
    const el = new Audio(url);
    el.playsInline = true;
    el.crossOrigin = 'anonymous';
    el.preload = 'auto';
    el.onended = ()=> log('element ended', 'ok');
    el.onerror = ()=> log('element error', 'err');
    await el.play().then(()=> log('element play started','ok')).catch(e=>{ throw e; });
    return true;
  } catch(e1) {
    log('element play failed: ' + e1, 'err');
  }

  // 2) fetch -> blob -> element
  try {
    const r = await fetch(url, { cache: 'no-store' });
    log('blob fetch status ' + r.status);
    if (r.ok) {
      const blob = await r.blob();
      log('blob size ' + blob.size);
      const obj = URL.createObjectURL(blob);
      const el2 = new Audio(obj);
      el2.playsInline = true;
      el2.crossOrigin = 'anonymous';
      el2.onended = ()=> { log('blob-element ended', 'ok'); URL.revokeObjectURL(obj); };
      el2.onerror = ()=> { log('blob-element error', 'err'); URL.revokeObjectURL(obj); };
      try {
        await el2.play();
        log('blob-element play started', 'ok');
        return true;
      } catch(e2) {
        log('blob-element play rejected: ' + e2, 'err');
        URL.revokeObjectURL(obj);
      }
    } else {
      log('blob fetch returned ' + r.status, 'err');
    }
  } catch(e) {
    log('blob fetch/play exception: ' + e, 'err');
  }

  // 3) fetch -> arrayBuffer -> decode -> WebAudio
  try {
    ensureAudioCtx();
    const r3 = await fetch(url, { cache: 'no-store' });
    if (!r3.ok) { log('decode fetch failed ' + r3.status, 'err'); }
    else {
      const ab = await r3.arrayBuffer();
      const buf = await new Promise((resolve,reject)=>{
        try {
          const p = audioCtx.decodeAudioData(ab);
          if (p && typeof p.then === 'function') { p.then(resolve).catch(err=>{ try{ audioCtx.decodeAudioData(ab, resolve, reject); }catch(e){ reject(err||e); } }); return; }
        } catch(e){}
        try { audioCtx.decodeAudioData(ab, resolve, reject); } catch(e){ reject(e); }
      });
      const src = audioCtx.createBufferSource();
      src.buffer = buf;
      src.connect(masterGain);
      src.onended = ()=> log('webAudio ended', 'ok');
      src.start(0);
      log('webAudio started (duration ' + (buf.duration||0).toFixed(2) + 's)', 'ok');
      return true;
    }
  } catch(e) {
    log('webAudio decode/play error: ' + e, 'err');
  }

  // all failed
  log('All play attempts failed for index ' + i, 'err');
  return false;
}

/* --- manual control fallback --- */
function showManualControlForIndex(i) {
  manualHolder.innerHTML = '';
  const url = fileUrlForIndex(i);
  const container = document.createElement('div');
  const label = document.createElement('label');
  label.textContent = 'Manual control (tap Play if autoplay blocked)';
  container.appendChild(label);
  const a = document.createElement('audio');
  a.controls = true;
  a.playsInline = true;
  a.crossOrigin = 'anonymous';
  a.src = url;
  a.style.width = '100%';
  container.appendChild(a);
  manualHolder.appendChild(container);
  log('Manual control created for index ' + i + ' — tap Play', 'ok');
  // clicking the control is considered a user gesture: attempt unlock
  a.addEventListener('play', async ()=> {
    await tryUnlockSequence();
    unlocked = true;
    log('User played manual control — treated as unlocked', 'ok');
  }, {once:true});
  return a;
}

/* --- payload handling (numeric text treated as index) --- */
async function handlePayload(payload) {
  if (!payload) return;
  log('handlePayload: ' + JSON.stringify(payload));
  // determine index
  let idx = null;
  if (typeof payload.index === 'number') idx = payload.index;
  else if (typeof payload.text === 'string') {
    const t = payload.text.trim();
    if (/^\d+$/.test(t)) idx = parseInt(t, 10); // numeric text -> index
    // else mapping via T1.TXT could be added here if you upload T1.TXT
  }
  if (!idx) {
    log('Payload does not map to an index (no numeric text/index found)', 'err');
    return;
  }

  // try unlock first; if unlocked, play; if locked, show manual control and store pending
  const okUnlock = await tryUnlockSequence();
  if (okUnlock) {
    unlocked = true;
    const ok = await playSequenceForIndex(idx);
    if (!ok) {
      showManualControlForIndex(idx);
    }
    return;
  }

  // not unlocked -> store pending and show manual control to force user play
  pendingPayload = payload;
  showManualControlForIndex(idx);
  log('Autoplay blocked — manual control shown for index ' + idx, 'err');
}

/* ---------- SSE (EventSource) streaming ---------- */
function startSse() {
  if (sseActive) { log('SSE already active'); return; }
  const url = (firebaseUrlEl.value || '').trim();
  if (!url) { log('SSE start failed: Firebase URL empty', 'err'); return; }
  try {
    // EventSource will send Accept: text/event-stream
    sse = new EventSource(url);
  } catch(e) {
    log('SSE creation failed: ' + e, 'err');
    fallbackToPoll();
    return;
  }
  sseActive = true;
  log('SSE connecting to ' + url);
  setStatus('SSE connecting');
  sse.onopen = () => {
    log('SSE open', 'ok');
    setStatus('SSE open');
    // stop polling if running
    stopPolling();
  };
  sse.onerror = (err) => {
    log('SSE error or closed — falling back to polling', 'err');
    stopSse();
    fallbackToPoll();
  };
  // Firebase streams send events "put" and "patch"; also fallback to onmessage
  sse.addEventListener('put', (e) => {
    try {
      const d = JSON.parse(e.data);
      // d: { path: "...", data: ... }
      const payload = (d && d.data !== undefined) ? d.data : d;
      log('SSE put event: ' + JSON.stringify(payload));
      handlePayload(payload);
    } catch(ex) { log('SSE put parse error: ' + ex, 'err'); }
  });
  sse.addEventListener('patch', (e) => {
    try {
      const d = JSON.parse(e.data);
      const payload = (d && d.data !== undefined) ? d.data : d;
      log('SSE patch event: ' + JSON.stringify(payload));
      handlePayload(payload);
    } catch(ex) { log('SSE patch parse error: ' + ex, 'err'); }
  });
  sse.onmessage = (e) => {
    // generic messages — attempt parse
    try {
      const d = JSON.parse(e.data);
      const payload = (d && d.data !== undefined) ? d.data : d;
      log('SSE message event: ' + JSON.stringify(payload));
      handlePayload(payload);
    } catch(ex) { /* ignore non-json */ }
  };
}

function stopSse() {
  if (!sseActive) return;
  try { sse.close(); } catch(e){}
  sse = null;
  sseActive = false;
  log('SSE stopped');
  setStatus('SSE stopped');
}

/* ---------- Poll fallback ---------- */
async function fetchWithTimeout(url, timeout = 4000) {
  const ctrl = new AbortController();
  const id = setTimeout(()=>ctrl.abort(), timeout);
  try {
    const r = await fetch(url, { signal: ctrl.signal, cache: 'no-store' });
    clearTimeout(id);
    return r;
  } catch(e) { clearTimeout(id); throw e; }
}

async function fetchFirebaseOnce() {
  const fb = (firebaseUrlEl.value || '').trim();
  if (!fb) { log('Firebase URL not set', 'err'); return; }
  setStatus('Fetching Firebase...');
  try {
    const r = await fetchWithTimeout(fb, 4000);
    if (!r.ok) { log('Fetch failed ' + r.status, 'err'); setStatus('Fetch failed'); return; }
    const j = await r.json();
    setStatus('Fetched');
    const s = JSON.stringify(j);
    if (s === lastPayloadStr) { log('No change (deduped)'); return; }
    lastPayloadStr = s;
    handlePayload(j);
  } catch(e) {
    log('Fetch exception: ' + e, 'err');
  }
}

function startPolling() {
  if (pollId) { log('Polling already active'); return; }
  const ms = Math.max(100, Number(pollMsEl.value) || 800);
  pollId = setInterval(fetchFirebaseOnce, ms);
  setStatus('Polling every ' + ms + ' ms');
  log('Polling started', 'ok');
  // do one immediate fetch
  fetchFirebaseOnce();
}

function stopPolling() {
  if (!pollId) { log('Poller not running'); return; }
  clearInterval(pollId);
  pollId = null;
  setStatus('Polling stopped');
  log('Polling stopped');
}

function fallbackToPoll() {
  log('Falling back to polling');
  startPolling();
}

/* --- UI wiring --- */
startSseBtn.addEventListener('click', ()=> startSse());
stopSseBtn.addEventListener('click', ()=> stopSse());
fetchOneBtn.addEventListener('click', ()=> fetchFirebaseOnce());
startPollBtn.addEventListener('click', ()=> startPolling());
stopPollBtn.addEventListener('click', ()=> stopPolling());
unlockBtn.addEventListener('click', async ()=> {
  setStatus('Attempting unlock...');
  const ok = await tryUnlockSequence();
  if (ok) { unlocked = true; setStatus('Unlocked'); log('Unlocked by gesture', 'ok'); }
  else { setStatus('Unlock attempt finished (blocked)'); log('Unlock attempt finished', 'err'); }
});
clearLogBtn.addEventListener('click', ()=> logEl.textContent = '');

// If user interacts with manual control, consider that an unlock
manualHolder.addEventListener('click', ()=>{
  tryUnlockSequence().then(ok => { if (ok) { unlocked = true; log('Unlocked by manual control interaction', 'ok'); }});
});

/* --- init: try SSE then fallback to poll if SSE doesn't work --- */
(function init(){
  log('Script loaded — attempting SSE (EventSource) to Firebase message.json');
  // start SSE immediately
  try {
    startSse();
    // also attach a short watchdog: if SSE doesn't open within 4s, fallback to poll
    setTimeout(()=> {
      if (!sseActive && !pollId) {
        log('SSE did not become active quickly; falling back to polling');
        fallbackToPoll();
      }
    }, 4200);
  } catch(e) {
    log('SSE start exception: ' + e, 'err');
    fallbackToPoll();
  }
  setStatus('Initialized');
})();
</script>
</body>
</html>
