<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gangtay — Buttons fixed + Firebase</title>
<style>
  body{font-family:system-ui,Arial;padding:14px;max-width:980px;margin:auto}
  h1{margin:0 0 8px 0}
  label{display:block;margin-top:8px;font-weight:600}
  input, button, select {padding:10px;margin:6px 0;width:100%;box-sizing:border-box}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .half{flex:1 1 48%}
  #log{font-family:monospace;background:#111;color:#e6e6e6;padding:12px;border-radius:8px;min-height:220px;white-space:pre-wrap;overflow:auto}
  .ok{color:limegreen}
  .err{color:crimson}
</style>
</head>
<body>
  <h1>Gangtay — Fixed buttons + Firebase</h1>
  <p style="color:#666;margin:0 0 12px 0">Both buttons now attempt playback. Use Firebase controls to fetch/play DB payloads.</p>

  <label>Index to play (1-based)</label>
  <input id="indexInput" type="number" value="2" min="1" />

  <label>Audio base (folder or absolute URL)</label>
  <input id="audioBase" value="/audio/" />

  <div class="row">
    <button id="btn1" class="half" onclick="safeClick(1)">Test button 1 (inline onclick)</button>
    <button id="btn2" class="half">Test button 2 (addEventListener: fetch+blob+play)</button>
  </div>

  <label>Firebase message.json URL</label>
  <input id="firebaseUrl" value="https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json" />

  <div class="row">
    <button id="fbFetch" class="half">Fetch Firebase & Play</button>
    <button id="startPoll" class="half">Start polling</button>
  </div>
  <div class="row">
    <button id="stopPoll" class="half">Stop polling</button>
    <input id="pollMs" class="half" type="number" value="800" min="100"/>
  </div>

  <div class="row">
    <button id="unlockBtn" class="half">Unlock audio (tap once)</button>
    <button id="clearLog" class="half">Clear log</button>
  </div>

  <div id="status">Status: ready</div>
  <pre id="log">JS not yet executed...</pre>

<script>
/* Both buttons now play audio.
   - btn1 (safeClick) uses new Audio(url).play()
   - btn2 fetches the mp3 as blob -> createObjectURL -> audio.play()
   - Firebase fetch will read message.json and play index field (or try to map text)
   - Poller can auto-check DB and invoke play when payload differs
   - Mobile: press Unlock audio once to allow autoplay; both methods still attempt play and will fall back.
*/

const idxEl = document.getElementById('indexInput');
const audioBaseEl = document.getElementById('audioBase');
const firebaseUrlEl = document.getElementById('firebaseUrl');
const fbFetchBtn = document.getElementById('fbFetch');
const startPollBtn = document.getElementById('startPoll');
const stopPollBtn = document.getElementById('stopPoll');
const pollMsEl = document.getElementById('pollMs');
const unlockBtn = document.getElementById('unlockBtn');
const clearLogBtn = document.getElementById('clearLog');
const logEl = document.getElementById('log');
const statusEl = document.getElementById('status');
let audioCtx = null;
let masterGain = null;
let unlocked = false;
let currentAudio = null;
let pollId = null;
let lastPayloadStr = null;

// logging helpers
function now(){ return new Date().toLocaleTimeString(); }
function log(msg, cls){
  const line = `[${now()}] ${msg}`;
  logEl.textContent = line + '\n' + logEl.textContent;
  if(cls === 'err') statusEl.style.color = 'crimson';
  else if(cls === 'ok') statusEl.style.color = 'limegreen';
  else statusEl.style.color = '';
  console.log(line);
}
function setStatus(s){ statusEl.textContent = 'Status: ' + s; log(s); }

// build file url for index i
function pad4(n){ return String(n).padStart(4,'0'); }
function fileUrlForIndex(i){
  const base = (audioBaseEl.value || '/audio/').trim();
  const fname = pad4(i) + '.mp3';
  if (/^https?:\/\//i.test(base)) return base.endsWith('/') ? base + fname : base + '/' + fname;
  if (base.startsWith('/')) return location.origin + (base.endsWith('/') ? base + fname : base + '/' + fname);
  return location.origin + '/' + (base.endsWith('/') ? base + fname : base + '/' + fname);
}

/* --- Audio helpers --- */
function ensureAudioCtx(){
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 1.0;
    masterGain.connect(audioCtx.destination);
    log('AudioContext created', 'ok');
  } catch(e) {
    log('AudioContext creation failed: ' + e, 'err');
  }
}

// primary method: direct element play
async function playViaElement(url){
  try {
    const a = new Audio(url);
    a.playsInline = true;
    a.crossOrigin = 'anonymous';
    a.preload = 'auto';
    a.onended = ()=> log('Element ended', 'ok');
    a.onerror = (ev)=> log('Element error: ' + (ev && ev.message ? ev.message : 'unknown'), 'err');
    currentAudio = a;
    await a.play();
    log('Element play started: ' + url, 'ok');
    return true;
  } catch(e) {
    log('Element play rejected: ' + e, 'err');
    return false;
  }
}

// fetch->blob->objectURL then play element
async function fetchBlobAndPlay(url){
  try {
    const r = await fetch(url, {cache:'no-store'});
    log('fetch status ' + r.status);
    if (!r.ok) { log('fetch failed ' + r.status, 'err'); return false; }
    const blob = await r.blob();
    log('blob size ' + blob.size);
    const obj = URL.createObjectURL(blob);
    const a = new Audio(obj);
    a.playsInline = true;
    a.crossOrigin = 'anonymous';
    a.onended = ()=> { log('Blob-element ended', 'ok'); URL.revokeObjectURL(obj); };
    a.onerror = ()=> { log('Blob-element error', 'err'); URL.revokeObjectURL(obj); };
    currentAudio = a;
    try {
      await a.play();
      log('Blob-element play started', 'ok');
      return true;
    } catch(e) {
      log('Blob-element play rejected: ' + e, 'err');
      URL.revokeObjectURL(obj);
      return false;
    }
  } catch(e) {
    log('fetchBlobAndPlay exception: ' + e, 'err');
    return false;
  }
}

// WebAudio fallback: fetch->arrayBuffer->decode->play
async function fetchDecodeAndPlay(url){
  try {
    ensureAudioCtx();
    const r = await fetch(url, {cache:'no-store'});
    log('fetch (decode) status ' + r.status);
    if (!r.ok) { log('fetch decode failed ' + r.status, 'err'); return false; }
    const ab = await r.arrayBuffer();
    const buf = await new Promise((resolve,reject)=>{
      try {
        const p = audioCtx.decodeAudioData(ab);
        if (p && typeof p.then === 'function') { p.then(resolve).catch(err=>{ try{ audioCtx.decodeAudioData(ab, resolve, reject); } catch(e){ reject(err||e); } }); return; }
      } catch(e){}
      try { audioCtx.decodeAudioData(ab, resolve, reject); } catch(e){ reject(e); }
    });
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    src.connect(masterGain);
    src.onended = ()=> log('WebAudio ended', 'ok');
    src.start(0);
    log('WebAudio started (duration ' + (buf.duration||0).toFixed(2) + 's)', 'ok');
    return true;
  } catch(e) {
    log('fetchDecodeAndPlay error: ' + e, 'err');
    return false;
  }
}

/* --- Button handlers --- */

// inline safeClick (keeps inline onclick for gesture compatibility)
window.safeClick = async function(n){
  log('safeClick(' + n + ') invoked (inline onclick)');
  // try unlock first
  await tryUnlockSequence();
  const i = Number(idxEl.value) || 1;
  const url = fileUrlForIndex(i) + '?ts=' + Date.now();
  log('safeClick: attempting direct element play: ' + url);
  const ok = await playViaElement(url);
  if (!ok) {
    log('safeClick: element failed, trying blob->play', 'err');
    const ok2 = await fetchBlobAndPlay(url);
    if (!ok2) {
      log('safeClick: blob failed, trying decode fallback', 'err');
      await fetchDecodeAndPlay(url);
    }
  }
};

// btn2 uses addEventListener but now actually plays
document.getElementById('btn2').addEventListener('click', async ()=>{
  log('btn2 click (addEventListener) invoked');
  await tryUnlockSequence();
  const i = Number(idxEl.value) || 1;
  const url = fileUrlForIndex(i) + '?ts=' + Date.now();
  log('btn2: fetch+blob+play -> ' + url);
  // try blob path first (robust)
  const ok = await fetchBlobAndPlay(url);
  if (!ok) {
    log('btn2: blob path failed, trying element then decode fallback', 'err');
    const ok2 = await playViaElement(url);
    if (!ok2) await fetchDecodeAndPlay(url);
  }
});

// Firebase one-shot fetch & play
fbFetchBtn.addEventListener('click', async ()=>{
  const fb = (firebaseUrlEl.value || '').trim();
  if (!fb) { alert('Set Firebase URL'); return; }
  setStatus('Fetching Firebase...');
  try {
    const r = await fetch(fb, {cache:'no-store'});
    if (!r.ok) { setStatus('Firebase fetch failed: ' + r.status); log('Firebase fetch failed ' + r.status,'err'); return; }
    const j = await r.json();
    log('Firebase payload: ' + JSON.stringify(j));
    // if contains index - play it
    if (typeof j.index === 'number') {
      idxEl.value = j.index;
      lastPayloadStr = JSON.stringify(j);
      // play using blob path (btn2 logic)
      document.getElementById('btn2').click();
    } else if (typeof j.text === 'string') {
      log('Firebase has text: ' + j.text);
      // optional: you could map text to T1.TXT on the site (not implemented here)
    } else {
      log('Unknown payload shape', 'err');
    }
  } catch(e) {
    setStatus('Firebase fetch exception');
    log('Firebase fetch exception: ' + e, 'err');
  }
});

// Poller
startPollBtn.addEventListener('click', ()=>{
  if (pollId) { log('Poller already running'); return; }
  const ms = Math.max(100, Number(pollMsEl.value) || 800);
  const fb = (firebaseUrlEl.value || '').trim();
  if (!fb) { alert('Set Firebase URL'); return; }
  pollId = setInterval(async ()=>{
    try {
      const r = await fetch(fb, {cache:'no-store'});
      if (!r.ok) { log('Poll fetch failed: ' + r.status, 'err'); return; }
      const j = await r.json();
      const s = JSON.stringify(j);
      if (s === lastPayloadStr) return; // no change
      lastPayloadStr = s;
      log('Poll: new payload ' + s);
      // if has index, play
      if (typeof j.index === 'number') {
        idxEl.value = j.index;
        // play via btn2 flow
        document.getElementById('btn2').click();
      }
    } catch(e) {
      log('Poll exception: ' + e, 'err');
    }
  }, ms);
  setStatus('Polling every ' + ms + ' ms');
  log('Poller started', 'ok');
});

stopPollBtn.addEventListener('click', ()=>{
  if (!pollId) { log('Poller not running'); return; }
  clearInterval(pollId); pollId = null;
  setStatus('Polling stopped');
  log('Poller stopped');
});

// Unlock audio button
unlockBtn.addEventListener('click', async ()=>{
  setStatus('Attempting unlock...');
  const ok = await tryUnlockSequence();
  if (ok) { unlocked = true; setStatus('Unlocked — try play'); log('Unlocked by user gesture', 'ok'); }
  else { setStatus('Unlock attempt finished (may be blocked)'); log('Unlock attempt finished'); }
});

// clear log
clearLogBtn.addEventListener('click', ()=> logEl.textContent = '');

// unlock helper
async function tryUnlockSequence(){
  if (unlocked) return true;
  ensureAudioCtx();
  try {
    if (audioCtx.state === 'running') { unlocked = true; return true; }
    const a = new Audio(); a.muted = true;
    try { await a.play(); } catch(e){}
    if (audioCtx.state === 'running') { unlocked = true; return true; }
    // fallback tone
    const nowt = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine'; o.frequency.value = 880;
    g.gain.value = 0.0001;
    o.connect(g); g.connect(masterGain);
    g.gain.setValueAtTime(0.0001, nowt);
    g.gain.linearRampToValueAtTime(0.06, nowt + 0.01);
    o.start(nowt);
    g.gain.linearRampToValueAtTime(0.0001, nowt + 0.12);
    o.stop(nowt + 0.13);
    try { await audioCtx.resume(); } catch(e){}
    unlocked = (audioCtx.state === 'running');
    return unlocked;
  } catch(e) { log('tryUnlockSequence error: ' + e, 'err'); return false; }
}

// global error handlers
window.addEventListener('error', (e)=> log('window.error: ' + (e && e.message ? e.message : JSON.stringify(e)), 'err'));
window.addEventListener('unhandledrejection', (ev)=> log('unhandledrejection: ' + JSON.stringify(ev.reason), 'err'));

// quick status
log('Script loaded and handlers attached.');
setStatus('Ready');
</script>
</body>
</html>
