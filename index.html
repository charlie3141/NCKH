<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H·ªá th·ªëng D·ªãch Th·ªß Ng·ªØ - Phi√™n b·∫£n Ho√†n thi·ªán</title>
    <style>
        /* === RESET & BASE === */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a237e 0%, #311b92 100%);
            color: #212121;
            min-height: 100vh;
            padding: 20px;
            position: relative;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            position: relative;
        }

        /* === HEADER === */
        header {
            background: linear-gradient(to right, #0d47a1, #1a237e);
            color: white;
            padding: 24px 20px;
            text-align: center;
            position: relative;
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 8px;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        .header-subtitle {
            font-size: 1rem;
            opacity: 0.9;
            margin-bottom: 12px;
        }

        .system-indicators {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .indicator-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4caf50;
            animation: pulse 2s infinite;
        }

        .indicator.offline .indicator-dot {
            background: #f44336;
            animation: none;
        }

        /* === DASHBOARD LAYOUT === */
        .dashboard {
            padding: 24px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 24px;
        }

        .card {
            background: #ffffff;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            border: 1px solid #e0e0e0;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            overflow: hidden;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }

        .card h3 {
            color: #1a237e;
            margin-bottom: 16px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e3f2fd;
            font-size: 1.3rem;
            font-weight: 600;
        }

        /* === WORD CONSTRUCTION === */
        .display-box {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border: 2px solid #2196f3;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            text-align: center;
            position: relative;
        }

        .display-label {
            font-size: 0.85rem;
            color: #1565c0;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .display-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #0d47a1;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            word-break: break-word;
            line-height: 1.4;
        }

        .display-value.empty {
            color: #757575;
            font-style: italic;
        }

        .word-list-container {
            margin: 15px 0;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #e0e0e0;
        }

        .word-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .word-item {
            padding: 8px 15px;
            background: #e3f2fd;
            border-radius: 20px;
            border: 1px solid #bbdefb;
            font-weight: 500;
            color: #1565c0;
            transition: all 0.2s;
        }

        .word-item:hover {
            background: #bbdefb;
            transform: scale(1.05);
        }

        /* === CONTROLS === */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(to right, #0d47a1, #1a237e);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.95rem;
            min-width: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(13, 71, 161, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button.primary {
            background: linear-gradient(to right, #0d47a1, #1a237e);
        }

        button.success {
            background: linear-gradient(to right, #2e7d32, #388e3c);
        }

        button.warning {
            background: linear-gradient(to right, #f57c00, #ff9800);
        }

        button.danger {
            background: linear-gradient(to right, #c62828, #d32f2f);
        }

        button.info {
            background: linear-gradient(to right, #0277bd, #0288d1);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        /* === CALIBRATION === */
        .calibration-section {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 100%);
            border-radius: 10px;
            border: 2px solid #ffb300;
        }

        .calibration-section h4 {
            color: #e65100;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .threshold-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .threshold-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .threshold-card.bent {
            border-left-color: #ff9800;
        }

        .threshold-label {
            font-size: 0.8rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .threshold-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #333;
        }

        .calibration-progress {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, #4caf50, #8bc34a);
            width: 0%;
            transition: width 0.3s;
            border-radius: 4px;
        }

        .calibration-timer {
            text-align: center;
            font-size: 0.9rem;
            color: #666;
            margin: 10px 0;
            font-weight: 600;
        }

        /* === AI SUGGESTIONS === */
        .ai-section {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-radius: 10px;
            border: 2px solid #4caf50;
        }

        .history-words {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #c8e6c9;
            min-height: 60px;
            max-height: 120px;
            overflow-y: auto;
        }

        .history-word {
            padding: 6px 12px;
            background: #e8f5e9;
            border-radius: 15px;
            font-size: 0.85rem;
            color: #2e7d32;
            border: 1px solid #a5d6a7;
        }

        .ai-suggestions-list {
            margin: 15px 0;
            max-height: 300px;
            overflow-y: auto;
        }

        .ai-suggestion-item {
            padding: 12px;
            margin: 8px 0;
            background: white;
            border-radius: 8px;
            border: 1px solid #c8e6c9;
            cursor: pointer;
            transition: all 0.2s;
        }

        .ai-suggestion-item:hover {
            background: #f1f8e9;
            transform: translateX(5px);
            border-color: #4caf50;
        }

        .suggestion-text {
            font-size: 0.95rem;
            color: #333;
            margin-bottom: 8px;
        }

        .suggestion-actions {
            display: flex;
            gap: 8px;
        }

        .suggestion-btn {
            padding: 4px 12px;
            font-size: 0.8rem;
            border-radius: 4px;
            border: none;
            cursor: pointer;
        }

        .suggestion-btn.speak {
            background: #2196f3;
            color: white;
        }

        .suggestion-btn.use {
            background: #4caf50;
            color: white;
        }

        /* === SENSOR DISPLAY === */
        .sensor-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .sensor-card {
            padding: 15px;
            background: #f5f5f5;
            border-radius: 8px;
            border-left: 4px solid;
        }

        .sensor-card.mpu {
            border-left-color: #2196f3;
            background: #e3f2fd;
        }

        .sensor-card.flex {
            border-left-color: #ff9800;
            background: #fff3e0;
        }

        .sensor-title {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .sensor-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #333;
            margin: 8px 0;
        }

        .flex-boxes {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
        }

        .flex-box {
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f5f5f5;
            border-radius: 8px;
            font-weight: 700;
            font-size: 1.2rem;
            border: 2px solid #ddd;
            transition: all 0.2s;
        }

        .flex-box.state-0 {
            background: #4caf50;
            color: white;
            border-color: #388e3c;
        }

        .flex-box.state-1 {
            background: #ff9800;
            color: white;
            border-color: #f57c00;
        }

        .flex-box.state-2 {
            background: #f44336;
            color: white;
            border-color: #d32f2f;
        }

        /* === TRANSLATION === */
        .translation-section {
            margin: 20px 0;
        }

        textarea {
            width: 100%;
            height: 120px;
            padding: 15px;
            border: 2px solid #4caf50;
            border-radius: 8px;
            font-size: 1rem;
            resize: vertical;
            background: #f1f8e9;
            color: #333;
            font-family: inherit;
        }

        textarea:focus {
            outline: none;
            border-color: #2e7d32;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
        }

        .language-selector {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        select {
            padding: 10px 15px;
            border: 2px solid #2196f3;
            border-radius: 6px;
            background: white;
            font-size: 0.95rem;
            min-width: 150px;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: #0d47a1;
        }

        /* === SPEECH === */
        .speech-section {
            margin: 20px 0;
            padding: 20px;
            background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
            border-radius: 10px;
            border: 2px solid #9c27b0;
        }

        .voice-selector {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .voice-option {
            padding: 8px 16px;
            border: 2px solid #9c27b0;
            border-radius: 20px;
            background: white;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .voice-option.active {
            background: #9c27b0;
            color: white;
        }

        .tts-toggle {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
        }

        .tts-btn {
            padding: 8px 20px;
            border: 2px solid #673ab7;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .tts-btn.active {
            background: #673ab7;
            color: white;
        }

        .speech-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }

        /* === LOG === */
        .log-container {
            max-height: 300px;
            overflow-y: auto;
            background: #f5f5f5;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border-left: 4px solid #2196f3;
            font-size: 0.85rem;
        }

        .log-time {
            color: #666;
            font-size: 0.8rem;
            margin-right: 10px;
        }

        .log-source {
            font-weight: 600;
            color: #1a237e;
            margin-right: 5px;
        }

        /* === STATUS BAR === */
        .status-bar {
            background: #f5f5f5;
            padding: 15px 20px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .last-update {
            font-size: 0.9rem;
            color: #666;
        }

        /* === ANIMATIONS === */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .shake {
            animation: shake 0.5s ease-in-out;
        }

        .slide-in {
            animation: slideIn 0.3s ease-out;
        }

        /* === PERFORMANCE === */
        .performance-info {
            font-size: 0.8rem;
            color: #666;
            text-align: center;
            margin-top: 10px;
        }

        .fast-mode-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4caf50;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* === LOADING STATES === */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #2196f3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* === RESPONSIVE === */
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
                padding: 16px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="fast-mode-indicator" id="fastModeIndicator">üöÄ Turbo Mode</div>
    
    <div class="container">
        <header>
            <h1>H·ªÜ TH·ªêNG D·ªäCH TH·ª¶ NG·ªÆ</h1>
            <div class="header-subtitle">Gi√°m s√°t th·ªùi gian th·ª±c v√† x·ª≠ l√Ω ng√¥n ng·ªØ th·ªß ng·ªØ</div>
            
            <div class="system-indicators">
                <div class="indicator" id="connectionIndicator">
                    <div class="indicator-dot"></div>
                    <span id="connectionText">K·∫øt n·ªëi Firebase</span>
                </div>
                <div class="indicator">
                    <div class="indicator-dot" style="background: #2196f3;"></div>
                    <span id="updateStatus">C·∫≠p nh·∫≠t: --:--:--</span>
                </div>
                <div class="indicator">
                    <div class="indicator-dot" style="background: #ff9800;"></div>
                    <span id="performanceStatus">FPS: --</span>
                </div>
            </div>
        </header>

        <div class="dashboard">
            <!-- CARD 1: X√ÇY D·ª∞NG C√ÇU -->
            <div class="card">
                <h3>X√ÇY D·ª∞NG C√ÇU T·ª™ TH·ª¶ NG·ªÆ</h3>
                
                <div class="display-box">
                    <div class="display-label">T·ª™ HI·ªÜN T·∫†I (M√£ h√≥a)</div>
                    <div class="display-value" id="currentWordDisplay">---</div>
                </div>
                
                <div class="display-box">
                    <div class="display-label">T·ª™ HI·ªÜN T·∫†I (Ti·∫øng Vi·ªát)</div>
                    <div class="display-value" id="convertedWordDisplay">---</div>
                </div>
                
                <div class="word-list-container">
                    <div class="display-label">C√ÇU ƒêANG X√ÇY D·ª∞NG</div>
                    <div class="display-value" id="sentenceDisplay">Ch∆∞a c√≥ t·ª´ n√†o</div>
                    
                    <div class="word-items" id="wordItems">
                        <!-- T·ª´ s·∫Ω ƒë∆∞·ª£c th√™m ·ªü ƒë√¢y -->
                    </div>
                </div>
                
                <div class="controls">
                    <button class="danger" onclick="clearCurrentWord()">
                        <span>‚úï</span> X√≥a t·ª´
                    </button>
                    <button class="warning" onclick="backspace()">
                        <span>‚å´</span> X√≥a k√Ω t·ª±
                    </button>
                    <button class="success" onclick="addWordToSentence()">
                        <span>+</span> Th√™m t·ª´
                    </button>
                    <button class="primary" onclick="commitSentence()">
                        <span>‚úì</span> Ho√†n th√†nh
                    </button>
                </div>
                
                <!-- ƒê·ªÄ XU·∫§T AI -->
                <div class="ai-section">
                    <h4>ü§ñ ƒê·ªÄ XU·∫§T T·ª™ AI</h4>
                    
                    <div class="history-words" id="historyWords">
                        <!-- L·ªãch s·ª≠ t·ª´ s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y -->
                    </div>
                    
                    <div class="ai-suggestions-list" id="aiSuggestionsList">
                        <!-- ƒê·ªÅ xu·∫•t AI s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y -->
                    </div>
                    
                    <div class="controls">
                        <button class="info" onclick="generateAISuggestions()" id="aiSuggestBtn">
                            <span>‚ú®</span> T·∫°o ƒë·ªÅ xu·∫•t
                        </button>
                        <button class="warning" onclick="clearHistory()">
                            <span>üóëÔ∏è</span> X√≥a l·ªãch s·ª≠
                        </button>
                    </div>
                </div>
            </div>

            <!-- CARD 2: D·ªäCH V√Ä GI·ªåNG N√ìI -->
            <div class="card">
                <h3>D·ªäCH THU·∫¨T V√Ä GI·ªåNG N√ìI</h3>
                
                <div class="translation-section">
                    <div class="display-label">VƒÇN B·∫¢N D·ªäCH</div>
                    <textarea id="translationInput" placeholder="Nh·∫≠p vƒÉn b·∫£n ti·∫øng Vi·ªát ho·∫∑c s·ª≠ d·ª•ng c√¢u ƒë√£ x√¢y d·ª±ng..."></textarea>
                    
                    <div class="language-selector">
                        <div>
                            <div class="display-label">Ng√¥n ng·ªØ ƒë√≠ch</div>
                            <select id="targetLanguage">
                                <option value="en">Ti·∫øng Anh</option>
                                <option value="ja">Ti·∫øng Nh·∫≠t</option>
                                <option value="ko">Ti·∫øng H√†n</option>
                                <option value="zh">Ti·∫øng Trung</option>
                                <option value="fr">Ti·∫øng Ph√°p</option>
                            </select>
                        </div>
                        <div>
                            <div class="display-label">Ng√¥n ng·ªØ gi·ªçng n√≥i</div>
                            <select id="speechLanguage">
                                <option value="vi-VN">Ti·∫øng Vi·ªát</option>
                                <option value="en-US">Ti·∫øng Anh</option>
                                <option value="ja-JP">Ti·∫øng Nh·∫≠t</option>
                                <option value="ko-KR">Ti·∫øng H√†n</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="display-box">
                        <div class="display-label">K·∫æT QU·∫¢ D·ªäCH</div>
                        <div class="display-value" id="translationResult">Ch∆∞a c√≥ b·∫£n d·ªãch</div>
                    </div>
                    
                    <div class="controls">
                        <button class="primary" onclick="translateText()">
                            <span>üåê</span> D·ªãch vƒÉn b·∫£n
                        </button>
                        <button class="danger" onclick="clearTranslation()">
                            <span>‚úï</span> X√≥a d·ªãch
                        </button>
                    </div>
                </div>
                
                <!-- PH·∫¶N GI·ªåNG N√ìI -->
                <div class="speech-section">
                    <h4>üé§ T·ªîNG H·ª¢P GI·ªåNG N√ìI</h4>
                    
                    <div class="tts-toggle">
                        <button class="tts-btn active" id="ttsGemini" onclick="setTTSEngine('gemini')">Gemini AI</button>
                        <button class="tts-btn" id="ttsWeb" onclick="setTTSEngine('web')">Web Speech</button>
                    </div>
                    
                    <div class="voice-selector">
                        <div class="voice-option active" data-lang="vi-VN" data-gender="male" onclick="selectVoice(this)">
                            üë® Nam Vi·ªát
                        </div>
                        <div class="voice-option" data-lang="vi-VN" data-gender="female" onclick="selectVoice(this)">
                            üë© N·ªØ Vi·ªát
                        </div>
                        <div class="voice-option" data-lang="en-US" data-gender="male" onclick="selectVoice(this)">
                            üë® Nam Anh
                        </div>
                        <div class="voice-option" data-lang="en-US" data-gender="female" onclick="selectVoice(this)">
                            üë© N·ªØ Anh
                        </div>
                    </div>
                    
                    <div class="speech-controls">
                        <button class="success" onclick="speakVietnamese()" id="speakVnBtn">
                            <span>üîä</span> ƒê·ªçc ti·∫øng Vi·ªát
                        </button>
                        <button class="info" onclick="speakTranslation()" id="speakTransBtn">
                            <span>üîà</span> ƒê·ªçc b·∫£n d·ªãch
                        </button>
                        <button class="danger" onclick="stopSpeech()" id="stopSpeechBtn">
                            <span>‚èπÔ∏è</span> D·ª´ng ƒë·ªçc
                        </button>
                    </div>
                </div>
            </div>

            <!-- CARD 3: C·∫¢M BI·∫æN V√Ä CALIBRATION -->
            <div class="card">
                <h3>GI√ÅM S√ÅT C·∫¢M BI·∫æN</h3>
                
                <div class="sensor-grid">
                    <div class="sensor-card mpu">
                        <div class="sensor-title">ƒê·ªäNH H∆Ø·ªöNG MPU6050</div>
                        <div class="sensor-value" id="mpuOrientation">--</div>
                        <div class="sensor-title">TR·∫†NG TH√ÅI L·∫ÆC</div>
                        <div class="sensor-value" id="shakeState">Kh√¥ng</div>
                    </div>
                    
                    <div class="sensor-card flex">
                        <div class="sensor-title">C·∫¢M BI·∫æN U·ªêN</div>
                        <div class="flex-boxes">
                            <div class="flex-box" id="flexBox0">0</div>
                            <div class="flex-box" id="flexBox1">1</div>
                            <div class="flex-box" id="flexBox2">2</div>
                            <div class="flex-box" id="flexBox3">3</div>
                        </div>
                        <div class="sensor-title">GI√Å TR·ªä TH√î</div>
                        <div class="sensor-value" id="rawValues">--, --, --, --</div>
                    </div>
                </div>
                
                <!-- CALIBRATION SECTION -->
                <div class="calibration-section">
                    <h4>‚öôÔ∏è CALIBRATION C·∫¢M BI·∫æN U·ªêN</h4>
                    
                    <div class="threshold-grid">
                        <div class="threshold-card">
                            <div class="threshold-label">NG∆Ø·ª†NG TH·∫≤NG</div>
                            <div class="threshold-value" id="straightThresholds">100, 150, 150, 150</div>
                        </div>
                        <div class="threshold-card bent">
                            <div class="threshold-label">NG∆Ø·ª†NG U·ªêN</div>
                            <div class="threshold-value" id="bentThresholds">300, 450, 350, 300</div>
                        </div>
                    </div>
                    
                    <div class="calibration-progress" id="calibrationProgress" style="display: none;">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="calibration-timer" id="calibrationTimer" style="display: none;">
                        Th·ªùi gian c√≤n l·∫°i: <span id="timeRemaining">10</span> gi√¢y
                    </div>
                    
                    <div class="controls">
                        <button class="info" onclick="setStraightThreshold()">
                            <span>üìè</span> Set Straight
                        </button>
                        <button class="warning" onclick="startCalibration()" id="calibrateBtn">
                            <span>üéØ</span> Calibrate
                        </button>
                        <button class="danger" onclick="resetCalibration()">
                            <span>üîÑ</span> Reset
                        </button>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="primary" onclick="refreshData()">
                        <span>üîÑ</span> L√†m m·ªõi
                    </button>
                    <button class="success" onclick="toggleAutoRefresh()" id="autoRefreshBtn">
                        <span>‚è±Ô∏è</span> T·ª± ƒë·ªông: B·∫¨T
                    </button>
                    <button class="info" onclick="toggleTurboMode()" id="turboBtn">
                        <span>üöÄ</span> Turbo Mode
                    </button>
                </div>
            </div>

            <!-- CARD 4: NH·∫¨T K√ù H·ªÜ TH·ªêNG -->
            <div class="card">
                <h3>NH·∫¨T K√ù H·ªÜ TH·ªêNG</h3>
                
                <div class="log-container" id="logContainer">
                    <!-- Nh·∫≠t k√Ω s·∫Ω ƒë∆∞·ª£c th√™m ·ªü ƒë√¢y -->
                </div>
                
                <div class="controls">
                    <button class="danger" onclick="clearLog()">
                        <span>üóëÔ∏è</span> X√≥a nh·∫≠t k√Ω
                    </button>
                    <button class="primary" onclick="exportLog()">
                        <span>üì•</span> Xu·∫•t nh·∫≠t k√Ω
                    </button>
                </div>
                
                <div class="performance-info">
                    ƒê·ªô tr·ªÖ: <span id="latencyDisplay">--</span>ms | 
                    FPS: <span id="fpsDisplay">--</span> | 
                    Polling: <span id="pollingDisplay">--</span>ms
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div class="connection-status">
                <div class="indicator-dot"></div>
                <span id="statusText">ƒêang k·∫øt n·ªëi v·ªõi Firebase...</span>
            </div>
            <div class="last-update">
                C·∫≠p nh·∫≠t l·∫ßn cu·ªëi: <span id="lastUpdateTime">--:--:--</span>
            </div>
        </div>
    </div>

    <script>
        // ==============================================
        // C·∫§U H√åNH H·ªÜ TH·ªêNG
        // ==============================================
        const FIREBASE_URL = "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/sensorData.json";
        const GEMINI_API_KEY = "AIzaSyDdUj2SX83qODeZ1hhru0e9KN1fwDrtUP8";
        const GEMINI_TTS_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent";
        const GEMINI_TEXT_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent";

        // ==============================================
        // BI·∫æN TO√ÄN C·ª§C
        // ==============================================
        // Firebase v√† hi·ªáu nƒÉng
        let firebaseData = null;
        let lastFirebaseData = null;
        let lastUpdateTime = 0;
        let autoRefresh = true;
        let autoRefreshInterval = null;
        let isFetching = false;
        let currentFetchController = null;
        let pollingInterval = 300;
        let turboMode = false;
        
        // Hi·ªáu nƒÉng monitoring
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let currentFPS = 60;
        
        // X√¢y d·ª±ng c√¢u
        let currentWord = "";
        let convertedWord = "";
        let sentenceWords = [];
        let sentenceText = "";
        
        // C·∫£m bi·∫øn u·ªën
        let flexStates = [0, 0, 0, 0];
        let lastFlexStates = [-1, -1, -1, -1];
        let stableCount = 0;
        let holdStartTime = 0;
        let holdFired = false;
        const DEBOUNCE_COUNT = 3;
        const HOLD_MS_DEFAULT = 800;
        const POST_HOLD_COOLDOWN = 600;
        let lastActionTime = 0;
        
        // Calibration
        let straightThresholds = [100, 150, 150, 150];
        let bentThresholds = [300, 450, 350, 300];
        let isCalibrating = false;
        let calibrationTimeLeft = 10;
        let calibrationTimer = null;
        let calibrationMaxValues = [0, 0, 0, 0];
        let calibrationBaseValues = [0, 0, 0, 0];
        
        // L·ªãch s·ª≠ v√† AI
        let wordHistory = [];
        const MAX_HISTORY = 50;
        let isGeneratingAI = false;
        
        // Gi·ªçng n√≥i
        let currentVoice = { lang: 'vi-VN', gender: 'male' };
        let ttsEngine = 'gemini'; // 'gemini' ho·∫∑c 'web'
        let isSpeaking = false;
        let currentSpeech = null;
        
        // Cache
        const mappingCache = new Map();
        const vietnameseCache = new Map();
        const translationCache = new Map();
        const audioCache = new Map();
        
        // Nh·∫≠t k√Ω
        let logEntries = [];
        const MAX_LOG_ENTRIES = 100;

        // ==============================================
        // B·∫¢NG D·ªÆ LI·ªÜU (gi·ªØ nguy√™n t·ª´ code g·ªëc)
        // ==============================================
        const tableA = [
            ["IAY","IC","ICH","IE","IEC","IEM","IEN","IENG","IEO"],
            ["IEP","IET","IEU","IM","IN","ING","INH","IO","IOI"],
            ["ENG","ENH","EO","EP","ET","EU","I","IA","IAC"],
            ["IAI","IAM","IAN","IANG","IANH","IAO","IAP","IAT","IAU"],
            ["AP","AT","AU","AY","E","EC","ECH","EM","EN"],
            ["A","AC","ACH","AI","AM","AN","ANG","ANH","AO"],
            ["IUN","IUONG","IUP","O","OA","OAC","OACH","OAI","OAM"],
            ["ION","IONG","IOT","IP","IT","IU","IUA","IUC","IUI"]
        ];

        const tableB = [
            ["UE","UECH","UEN","UENH","UEO","UET","UI","UM","UN"],
            ["UNG","UO","UOC","UOI","UOM","UON","UONG","UOP","OUT"],
            ["ONG","OOC","OONG","OP","OT","U","UA","UAC","UACH"],
            ["UAI","UAM","UAN","UANG","UANH","UAO","UAT","UAY","UC"],
            ["OAY","OC","OE","OEN","OEO","OET","OI","OM","ON"],
            ["COMMIT","_","nullptr","nullptr","OAN","OANG","OANH","OAP","OAT"],
            ["UYNH","UYP","UYT","UYU","Y","YEM","YEN","YET","YEU"],
            ["UOU","UP","UT","UU","UY","UYA","UYCH","UYEN","UYET"]
        ];

        const tableC = [
            [ ["B","C","D"],["ƒê","G","H"],["K","L","M"] ],
            [ ["N","P","Q"],["R","S","T"],["V","X","CH"] ],
            [ ["GH","KH","NG"],["NGH","NH","PH"],["TH","TR","_"] ]
        ];

        // B·∫£ng chuy·ªÉn ƒë·ªïi ti·∫øng Vi·ªát (r√∫t g·ªçn ƒë·ªÉ ti·∫øt ki·ªám kh√¥ng gian)
        const vietnameseTable = [
            {key: "IAY", forms: ["i√°y","i√†y","i·∫£y","i√£y","i·∫°y","iay","i·∫•y","i·∫ßy","i·∫©y","i·∫´y","i·∫≠y","i√¢y","i·∫Øy","i·∫±y","i·∫≥y","i·∫µy","i·∫∑y","iƒÉy"]},
            {key: "IC", forms: ["√≠c","√¨c","·ªâc","ƒ©c","·ªãc","ic","√≠c","√¨c","·ªâc","ƒ©c","·ªãc","ic","√≠c","√¨c","·ªâc","ƒ©c","·ªãc","ic"]},
            {key: "ICH", forms: ["√≠ch","√¨ch","·ªâch","ƒ©ch","·ªãch","ich","√≠ch","√¨ch","·ªâch","ƒ©ch","·ªãch","ich","√≠ch","√¨ch","·ªâch","ƒ©ch","·ªãch","ich"]},
            {key: "IE", forms: ["i√©","i√®","i·∫ª","i·∫Ω","i·∫π","ie","i·∫ø","i·ªÅ","i·ªÉ","i·ªÖ","i·ªá","i√™","i√©","i√®","i·∫ª","i·∫Ω","i·∫π","ie"]},
            {key: "IEC", forms: ["i√©c","i√®c","i·∫ªc","i·∫Ωc","i·∫πc","iec","i·∫øc","i·ªÅc","i·ªÉc","i·ªÖc","i·ªác","i√™c","i√©c","i√®c","i·∫ªc","i·∫Ωc","i·∫πc","iec"]},
            {key: "IEM", forms: ["i√©m","i√®m","i·ªÉm","i·∫Ωm","·ªãem","iem","i·∫øm","i·ªÅm","i·ªÉm","i·ªÖm","i·ªám","i√™m","i√©m","i√®m","i·ªÉm","i·∫Ωm","·ªãem","iem"]},
            {key: "IEN", forms: ["ien","i√®n","i·∫ªn","i·∫Ωn","i·∫πn","ien","i√™n","i·ªÅn","i·ªÉn","i·ªÖn","i·ªán","i√™n","ien","i√®n","i·∫ªn","i·∫Ωn","i·∫πn","ien"]},
            {key: "IENG", forms: ["ieng","i√®ng","i·∫ªng","i·∫Ωng","i·∫πng","ieng","i√™ng","i·ªÅng","i·ªÉng","i·ªÖng","i·ªáng","i√™ng","ieng","i√®ng","i·∫ªng","i·∫Ωng","i·∫πng","ieng"]},
            {key: "IEO", forms: ["i√©o","i√®o","i·∫ªo","i·∫Ωo","i·∫πo","ieo","i·∫øo","i·ªÅo","i·ªÉo","i·ªÖo","i·ªáo","i√™o","i√©o","i√®o","i·∫ªo","i·∫Ωo","i·∫πo","ieo"]},
            {key: "IEP", forms: ["i√©p","i√®p","i·∫ªp","i·∫Ωp","i·∫πp","iep","i·∫øp","i·ªÅp","i·ªÉp","i·ªÖp","i·ªáp","i√™p","i√©p","i√®p","i·∫ªp","i·∫Ωp","i·∫πp","iep"]}
        ];

        // ==============================================
        // H√ÄM KH·ªûI T·∫†O
        // ==============================================
        document.addEventListener('DOMContentLoaded', function() {
            console.log('H·ªá th·ªëng D·ªãch Th·ªß Ng·ªØ ƒëang kh·ªüi ƒë·ªông...');
            
            // Kh·ªüi t·∫°o c√°c th√†nh ph·∫ßn
            initSystem();
            loadCalibration();
            loadHistory();
            
            // B·∫Øt ƒë·∫ßu monitoring hi·ªáu nƒÉng
            startPerformanceMonitor();
            
            // K·∫øt n·ªëi Firebase
            setTimeout(() => {
                fetchFirebaseData();
                startAutoRefresh();
            }, 500);
            
            logSystem('H·ªá th·ªëng ƒë√£ kh·ªüi ƒë·ªông th√†nh c√¥ng');
        });

        function initSystem() {
            // C·∫≠p nh·∫≠t UI ban ƒë·∫ßu
            updateWordDisplays();
            updateSensorDisplays();
            updateLogDisplay();
            
            // Thi·∫øt l·∫≠p s·ª± ki·ªán
            setupEventListeners();
            
            // Kh·ªüi t·∫°o speech synthesis
            if ('speechSynthesis' in window) {
                window.speechSynthesis.getVoices();
            }
        }

        function setupEventListeners() {
            // T·ª± ƒë·ªông d·ªãch khi nh·∫≠p xong
            let translationTimeout;
            document.getElementById('translationInput').addEventListener('input', function() {
                clearTimeout(translationTimeout);
                translationTimeout = setTimeout(() => {
                    if (this.value.trim().length > 0) {
                        translateText();
                    }
                }, 1000);
            });
            
            // Enter ƒë·ªÉ d·ªãch
            document.getElementById('translationInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    translateText();
                }
            });
        }

        // ==============================================
        // FIREBASE DATA FETCHING
        // ==============================================
        async function fetchFirebaseData() {
            if (isFetching) return;
            
            isFetching = true;
            const startTime = performance.now();
            
            // H·ªßy request tr∆∞·ªõc n·∫øu c√≥
            if (currentFetchController) {
                currentFetchController.abort();
            }
            
            currentFetchController = new AbortController();
            
            try {
                const response = await fetch(`${FIREBASE_URL}?t=${Date.now()}`, {
                    signal: currentFetchController.signal,
                    headers: {
                        'Cache-Control': 'no-cache'
                    }
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                const fetchTime = performance.now() - startTime;
                
                // C·∫≠p nh·∫≠t ƒë·ªô tr·ªÖ
                document.getElementById('latencyDisplay').textContent = Math.round(fetchTime);
                
                // Ch·ªâ x·ª≠ l√Ω n·∫øu d·ªØ li·ªáu thay ƒë·ªïi
                if (JSON.stringify(data) !== JSON.stringify(lastFirebaseData)) {
                    lastFirebaseData = data;
                    firebaseData = data;
                    lastUpdateTime = Date.now();
                    
                    // X·ª≠ l√Ω d·ªØ li·ªáu
                    processSensorData(data);
                    
                    // C·∫≠p nh·∫≠t UI
                    updateUI();
                    
                    logSystem(`D·ªØ li·ªáu c·∫≠p nh·∫≠t (${Math.round(fetchTime)}ms)`);
                    
                    // ƒêi·ªÅu ch·ªânh polling interval
                    adjustPollingInterval(fetchTime);
                }
                
                // C·∫≠p nh·∫≠t th·ªùi gian
                updateTimeDisplay();
                
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Fetch error:', error);
                    setConnectionStatus(false);
                    logSystem(`L·ªói k·∫øt n·ªëi: ${error.message}`);
                    
                    // TƒÉng interval khi c√≥ l·ªói
                    pollingInterval = Math.min(pollingInterval * 2, 5000);
                    updatePollingDisplay();
                }
            } finally {
                isFetching = false;
            }
        }

        function processSensorData(data) {
            // C·∫≠p nh·∫≠t MPU
            if (data.o) {
                document.getElementById('mpuOrientation').textContent = data.o;
            }
            if (data.d) {
                document.getElementById('shakeState').textContent = data.d;
            }
            
            // C·∫≠p nh·∫≠t c·∫£m bi·∫øn u·ªën
            if (data.f0 !== undefined) {
                const flexValues = [
                    data.f0 || 0,
                    data.f1 || 0,
                    data.f2 || 0,
                    data.f3 || 0
                ];
                
                // Hi·ªÉn th·ªã gi√° tr·ªã th√¥
                document.getElementById('rawValues').textContent = flexValues.join(', ');
                
                // C·∫≠p nh·∫≠t calibration n·∫øu ƒëang calibrate
                if (isCalibrating) {
                    updateCalibrationValues(flexValues);
                }
                
                // T√≠nh to√°n tr·∫°ng th√°i
                for (let i = 0; i < 4; i++) {
                    const newState = calculateFlexState(flexValues[i], i);
                    if (flexStates[i] !== newState) {
                        flexStates[i] = newState;
                        updateFlexBox(i, newState);
                    }
                }
                
                // X·ª≠ l√Ω x√¢y d·ª±ng t·ª´
                processWordConstruction();
            }
        }

        function calculateFlexState(value, sensorIndex) {
            const straight = straightThresholds[sensorIndex];
            const bent = bentThresholds[sensorIndex];
            
            if (value <= straight) return 0;
            if (value <= bent) return 1;
            return 2;
        }

        function processWordConstruction() {
            // L·∫•y tr·∫°ng th√°i MPU
            const mpuState = getMPUState();
            
            // X√°c ƒë·ªãnh h√†nh ƒë·ªông d·ª±a tr√™n tr·∫°ng th√°i
            const action = determineAction(mpuState, flexStates);
            
            if (action) {
                executeAction(action, mpuState, flexStates);
            }
        }

        function getMPUState() {
            if (!firebaseData) return -1;
            
            const orientation = firebaseData.o || '';
            const shake = firebaseData.d || '';
            
            if (shake === "Shake Left") return 6;
            if (shake === "Shake Right") return 7;
            
            switch(orientation) {
                case "Up": return 0;
                case "Down": return 1;
                case "Left": return 2;
                case "Right": return 3;
                case "Forward": return 4;
                case "Backward": return 5;
                default: return -1;
            }
        }

        function determineAction(mpuState, flexStates) {
            const cacheKey = `${mpuState}_${flexStates.join('_')}`;
            
            if (mappingCache.has(cacheKey)) {
                return mappingCache.get(cacheKey);
            }
            
            const action = determineActionLogic(mpuState, flexStates);
            mappingCache.set(cacheKey, action);
            
            return action;
        }

        function determineActionLogic(mpuState, flexStates) {
            const [a0, a1, a2, a3] = flexStates;
            
            if (mpuState < 0 || mpuState > 7) return null;
            
            if (a3 === 2) {
                if (a0 < 3 && a1 < 3 && a2 < 3) {
                    return tableC[a0][a1][a2];
                }
                return null;
            }
            
            const a3bin = a3 === 1 ? 1 : 0;
            if (a1 < 0 || a1 >= 3 || a2 < 0 || a2 >= 3) return null;
            
            const index = a1 * 3 + a2;
            if (index >= 0 && index < 9) {
                return a3bin === 0 ? tableA[mpuState][index] : tableB[mpuState][index];
            }
            
            return null;
        }

        function executeAction(action, mpuState, flexStates) {
            const now = Date.now();
            const [a0, a1, a2, a3] = flexStates;
            
            // Ki·ªÉm tra debounce
            if (now - lastActionTime < POST_HOLD_COOLDOWN) return;
            
            switch(action) {
                case '_':
                    addWordToSentence();
                    break;
                    
                case 'COMMIT':
                    commitSentence();
                    break;
                    
                case 'nullptr':
                    break;
                    
                default:
                    // X√¢y d·ª±ng t·ª´
                    if (a3 === 2) {
                        const mode = getModeFromA0(a0);
                        currentWord += `${action}_${mode}`;
                    } else {
                        currentWord += `${action}_${mpuState}`;
                    }
                    
                    updateWordDisplays();
                    logSystem(`Th√™m k√Ω t·ª±: ${action}`);
                    break;
            }
            
            lastActionTime = now;
        }

        function getModeFromA0(a0) {
            switch(a0) {
                case 0: return 's';
                case 1: return 'b';
                case 2: return 'p';
                default: return 'x';
            }
        }

        // ==============================================
        // X√ÇY D·ª∞NG C√ÇU
        // ==============================================
        function updateWordDisplays() {
            // Hi·ªÉn th·ªã t·ª´ hi·ªán t·∫°i
            const wordDisplay = document.getElementById('currentWordDisplay');
            wordDisplay.textContent = currentWord || '---';
            wordDisplay.className = `display-value ${currentWord ? '' : 'empty'}`;
            
            // Chuy·ªÉn ƒë·ªïi sang ti·∫øng Vi·ªát
            convertedWord = convertToVietnamese(currentWord);
            const convertedDisplay = document.getElementById('convertedWordDisplay');
            convertedDisplay.textContent = convertedWord || '---';
            convertedDisplay.className = `display-value ${convertedWord ? '' : 'empty'}`;
            
            // Hi·ªÉn th·ªã c√¢u
            const sentenceDisplay = document.getElementById('sentenceDisplay');
            sentenceText = sentenceWords.join(' ');
            sentenceDisplay.textContent = sentenceText || 'Ch∆∞a c√≥ t·ª´ n√†o';
            sentenceDisplay.className = `display-value ${sentenceText ? '' : 'empty'}`;
            
            // Hi·ªÉn th·ªã c√°c t·ª´
            updateWordItems();
        }

        function convertToVietnamese(encodedWord) {
            if (!encodedWord || encodedWord === '---') return '';
            
            if (vietnameseCache.has(encodedWord)) {
                return vietnameseCache.get(encodedWord);
            }
            
            // Logic chuy·ªÉn ƒë·ªïi (gi·∫£n l∆∞·ª£c)
            let result = encodedWord;
            
            // T√¨m trong b·∫£ng vietnameseTable
            for (const item of vietnameseTable) {
                if (encodedWord.includes(item.key)) {
                    result = encodedWord.replace(item.key, item.forms[0]);
                    break;
                }
            }
            
            vietnameseCache.set(encodedWord, result);
            return result;
        }

        function updateWordItems() {
            const container = document.getElementById('wordItems');
            container.innerHTML = '';
            
            sentenceWords.forEach((word, index) => {
                const div = document.createElement('div');
                div.className = 'word-item';
                div.textContent = convertToVietnamese(word);
                container.appendChild(div);
            });
        }

        function clearCurrentWord() {
            currentWord = '';
            convertedWord = '';
            updateWordDisplays();
            logSystem('ƒê√£ x√≥a t·ª´ hi·ªán t·∫°i');
        }

        function backspace() {
            if (currentWord.length > 0) {
                currentWord = currentWord.slice(0, -1);
                updateWordDisplays();
                logSystem('ƒê√£ x√≥a k√Ω t·ª± cu·ªëi');
            }
        }

        function addWordToSentence() {
            if (!currentWord || currentWord === '---') {
                logSystem('Kh√¥ng th·ªÉ th√™m t·ª´ r·ªóng');
                return;
            }
            
            if (sentenceWords.length >= 10) {
                logSystem('C√¢u ƒë√£ ƒë·∫ßy (t·ªëi ƒëa 10 t·ª´)');
                return;
            }
            
            sentenceWords.push(currentWord);
            
            // Th√™m v√†o l·ªãch s·ª≠
            addToHistory(currentWord);
            
            // Reset t·ª´ hi·ªán t·∫°i
            clearCurrentWord();
            
            logSystem(`ƒê√£ th√™m t·ª´ v√†o c√¢u (${sentenceWords.length}/10)`);
        }

        function commitSentence() {
            if (sentenceWords.length === 0) {
                logSystem('Kh√¥ng c√≥ t·ª´ n√†o ƒë·ªÉ ho√†n th√†nh');
                return;
            }
            
            // Th√™m t·ª´ ƒëang x√¢y d·ª±ng n·∫øu c√≥
            if (currentWord && currentWord !== '---') {
                addWordToSentence();
            }
            
            const vietnameseSentence = sentenceWords.map(word => convertToVietnamese(word)).join(' ');
            
            logSystem('=== C√ÇU ƒê√É HO√ÄN TH√ÄNH ===');
            logSystem(`Ti·∫øng Vi·ªát: ${vietnameseSentence}`);
            
            // T·ª± ƒë·ªông ƒëi·ªÅn v√†o √¥ d·ªãch thu·∫≠t
            document.getElementById('translationInput').value = vietnameseSentence;
            
            // T·ª± ƒë·ªông d·ªãch
            translateText();
            
            // Reset c√¢u
            sentenceWords = [];
            updateWordDisplays();
        }

        // ==============================================
        // L·ªäCH S·ª¨ V√Ä ƒê·ªÄ XU·∫§T AI
        // ==============================================
        function addToHistory(word) {
            const vietnameseWord = convertToVietnamese(word);
            if (!vietnameseWord || vietnameseWord === word) return;
            
            wordHistory.push(vietnameseWord);
            
            if (wordHistory.length > MAX_HISTORY) {
                wordHistory.shift();
            }
            
            saveHistory();
            updateHistoryDisplay();
            
            // Hi·ªÉn th·ªã panel AI n·∫øu c√≥ ƒë·ªß t·ª´
            if (wordHistory.length >= 3) {
                document.getElementById('aiSuggestionsList').style.display = 'block';
            }
        }

        function saveHistory() {
            localStorage.setItem('wordHistory', JSON.stringify(wordHistory));
        }

        function loadHistory() {
            try {
                const saved = localStorage.getItem('wordHistory');
                if (saved) {
                    wordHistory = JSON.parse(saved);
                    updateHistoryDisplay();
                }
            } catch (e) {
                console.error('L·ªói load history:', e);
                wordHistory = [];
            }
        }

        function updateHistoryDisplay() {
            const container = document.getElementById('historyWords');
            container.innerHTML = '';
            
            const recent = wordHistory.slice(-10);
            
            if (recent.length === 0) {
                container.innerHTML = '<div style="color: #666; text-align: center;">Ch∆∞a c√≥ t·ª´ trong l·ªãch s·ª≠</div>';
                return;
            }
            
            recent.forEach(word => {
                const span = document.createElement('span');
                span.className = 'history-word';
                span.textContent = word;
                container.appendChild(span);
            });
        }

        function clearHistory() {
            wordHistory = [];
            saveHistory();
            updateHistoryDisplay();
            document.getElementById('aiSuggestionsList').innerHTML = '';
            logSystem('ƒê√£ x√≥a l·ªãch s·ª≠ t·ª´');
        }

        async function generateAISuggestions() {
            if (wordHistory.length < 3) {
                logSystem('C·∫ßn √≠t nh·∫•t 3 t·ª´ trong l·ªãch s·ª≠');
                return;
            }
            
            if (isGeneratingAI) return;
            
            isGeneratingAI = true;
            const button = document.getElementById('aiSuggestBtn');
            button.innerHTML = '<span class="loading"></span> ƒêang t·∫°o...';
            button.disabled = true;
            
            const container = document.getElementById('aiSuggestionsList');
            container.innerHTML = '<div style="text-align: center; padding: 20px;"><div class="loading"></div><p>AI ƒëang t·∫°o ƒë·ªÅ xu·∫•t...</p></div>';
            
            try {
                const recentWords = wordHistory.slice(-15).join(', ');
                
                const prompt = `D·ª±a tr√™n c√°c t·ª´ ti·∫øng Vi·ªát sau: ${recentWords}
                
                H√£y ƒë·ªÅ xu·∫•t 5 c√¢u ti·∫øng Vi·ªát t·ª± nhi√™n, ng·∫Øn g·ªçn (d∆∞·ªõi 10 t·ª´) ph√π h·ª£p cho giao ti·∫øp h√†ng ng√†y.
                Ch·ªâ tr·∫£ v·ªÅ c√°c c√¢u, m·ªói c√¢u m·ªôt d√≤ng, kh√¥ng ƒë√°nh s·ªë, kh√¥ng gi·∫£i th√≠ch.`;
                
                const response = await fetch(`${GEMINI_TEXT_URL}?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.7,
                            maxOutputTokens: 200
                        }
                    })
                });
                
                if (!response.ok) throw new Error(`API error: ${response.status}`);
                
                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                
                const suggestions = text.split('\n')
                    .map(s => s.trim())
                    .filter(s => s.length > 5 && s.length < 100)
                    .slice(0, 5);
                
                displayAISuggestions(suggestions);
                logSystem(`ƒê√£ t·∫°o ${suggestions.length} ƒë·ªÅ xu·∫•t t·ª´ AI`);
                
            } catch (error) {
                console.error('AI suggestion error:', error);
                container.innerHTML = `<div style="color: #d32f2f; text-align: center; padding: 20px;">L·ªói: ${error.message}</div>`;
                logSystem(`L·ªói AI: ${error.message}`);
            } finally {
                isGeneratingAI = false;
                button.innerHTML = '<span>‚ú®</span> T·∫°o ƒë·ªÅ xu·∫•t';
                button.disabled = false;
            }
        }

        function displayAISuggestions(suggestions) {
            const container = document.getElementById('aiSuggestionsList');
            container.innerHTML = '';
            
            if (suggestions.length === 0) {
                container.innerHTML = '<div style="color: #666; text-align: center;">Kh√¥ng t·∫°o ƒë∆∞·ª£c ƒë·ªÅ xu·∫•t</div>';
                return;
            }
            
            suggestions.forEach((suggestion, index) => {
                const div = document.createElement('div');
                div.className = 'ai-suggestion-item slide-in';
                div.style.animationDelay = `${index * 0.1}s`;
                
                div.innerHTML = `
                    <div class="suggestion-text">${suggestion}</div>
                    <div class="suggestion-actions">
                        <button class="suggestion-btn speak" onclick="speakText('${suggestion.replace(/'/g, "\\'")}', 'vi-VN')">
                            üîä ƒê·ªçc
                        </button>
                        <button class="suggestion-btn use" onclick="useAISuggestion('${suggestion.replace(/'/g, "\\'")}')">
                            üìù D√πng
                        </button>
                    </div>
                `;
                
                container.appendChild(div);
            });
        }

        function useAISuggestion(suggestion) {
            document.getElementById('translationInput').value = suggestion;
            translateText();
            logSystem(`ƒê√£ s·ª≠ d·ª•ng ƒë·ªÅ xu·∫•t AI: "${suggestion.substring(0, 30)}..."`);
        }

        // ==============================================
        // D·ªäCH THU·∫¨T
        // ==============================================
        async function translateText() {
            const input = document.getElementById('translationInput').value.trim();
            const targetLang = document.getElementById('targetLanguage').value;
            const resultElement = document.getElementById('translationResult');
            
            if (!input) {
                resultElement.textContent = 'Vui l√≤ng nh·∫≠p vƒÉn b·∫£n';
                resultElement.className = 'display-value empty';
                return;
            }
            
            const cacheKey = `${input}|${targetLang}`;
            if (translationCache.has(cacheKey)) {
                resultElement.textContent = translationCache.get(cacheKey);
                resultElement.className = 'display-value';
                return;
            }
            
            resultElement.innerHTML = '<span class="loading"></span> ƒêang d·ªãch...';
            resultElement.className = 'display-value';
            
            try {
                // S·ª≠ d·ª•ng MyMemory Translation API
                const response = await fetch(
                    `https://api.mymemory.translated.net/get?q=${encodeURIComponent(input)}&langpair=vi|${targetLang}`
                );
                
                const data = await response.json();
                
                if (data.responseStatus === 200) {
                    const translated = data.responseData.translatedText;
                    translationCache.set(cacheKey, translated);
                    resultElement.textContent = translated;
                    logSystem(`ƒê√£ d·ªãch sang ${targetLang}: ${translated.substring(0, 30)}...`);
                } else {
                    throw new Error('D·ªãch thu·∫≠t th·∫•t b·∫°i');
                }
            } catch (error) {
                console.error('Translation error:', error);
                resultElement.textContent = 'L·ªói d·ªãch thu·∫≠t';
                resultElement.className = 'display-value empty';
                logSystem(`L·ªói d·ªãch: ${error.message}`);
            }
        }

        function clearTranslation() {
            document.getElementById('translationInput').value = '';
            document.getElementById('translationResult').textContent = 'Ch∆∞a c√≥ b·∫£n d·ªãch';
            document.getElementById('translationResult').className = 'display-value empty';
        }

        // ==============================================
        // GI·ªåNG N√ìI
        // ==============================================
        function setTTSEngine(engine) {
            ttsEngine = engine;
            
            document.getElementById('ttsGemini').classList.toggle('active', engine === 'gemini');
            document.getElementById('ttsWeb').classList.toggle('active', engine === 'web');
            
            logSystem(`Chuy·ªÉn sang engine TTS: ${engine}`);
        }

        function selectVoice(element) {
            document.querySelectorAll('.voice-option').forEach(btn => {
                btn.classList.remove('active');
            });
            
            element.classList.add('active');
            currentVoice = {
                lang: element.dataset.lang,
                gender: element.dataset.gender
            };
            
            logSystem(`Ch·ªçn gi·ªçng: ${currentVoice.lang} - ${currentVoice.gender}`);
        }

        function speakVietnamese() {
            const text = sentenceText || document.getElementById('translationInput').value;
            if (!text || text === 'Ch∆∞a c√≥ t·ª´ n√†o') {
                logSystem('Kh√¥ng c√≥ vƒÉn b·∫£n ƒë·ªÉ ƒë·ªçc');
                return;
            }
            
            speakText(text, 'vi-VN');
        }

        function speakTranslation() {
            const text = document.getElementById('translationResult').textContent;
            if (!text || text === 'Ch∆∞a c√≥ b·∫£n d·ªãch') {
                logSystem('Kh√¥ng c√≥ b·∫£n d·ªãch ƒë·ªÉ ƒë·ªçc');
                return;
            }
            
            const lang = document.getElementById('speechLanguage').value;
            speakText(text, lang);
        }

        async function speakText(text, lang) {
            if (isSpeaking) {
                stopSpeech();
                return;
            }
            
            isSpeaking = true;
            updateSpeechButtons();
            
            try {
                if (ttsEngine === 'gemini' && GEMINI_API_KEY) {
                    await speakWithGemini(text, lang);
                } else {
                    speakWithWebSpeech(text, lang);
                }
            } catch (error) {
                console.error('Speech error:', error);
                speakWithWebSpeech(text, lang);
            }
        }

        async function speakWithGemini(text, lang) {
            const voiceName = getGeminiVoiceName(lang, currentVoice.gender);
            
            const response = await fetch(`${GEMINI_TTS_URL}?key=${GEMINI_API_KEY}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text }] }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName }
                            }
                        }
                    }
                })
            });
            
            if (!response.ok) throw new Error('Gemini TTS failed');
            
            const data = await response.json();
            const audioData = data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
            
            if (!audioData) throw new Error('No audio data');
            
            // Chuy·ªÉn ƒë·ªïi v√† ph√°t audio
            const audioBlob = pcmToWav(atob(audioData));
            const url = URL.createObjectURL(audioBlob);
            playAudio(url);
            
            logSystem(`Gemini TTS: "${text.substring(0, 30)}..."`);
        }

        function speakWithWebSpeech(text, lang) {
            if (!('speechSynthesis' in window)) {
                logSystem('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ speech synthesis');
                return;
            }
            
            window.speechSynthesis.cancel();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = lang;
            utterance.rate = 0.9;
            utterance.pitch = currentVoice.gender === 'male' ? 0.8 : 1.2;
            utterance.volume = 1;
            
            const voices = speechSynthesis.getVoices();
            const voice = voices.find(v => v.lang.startsWith(lang.split('-')[0]));
            if (voice) utterance.voice = voice;
            
            utterance.onstart = () => {
                isSpeaking = true;
                updateSpeechButtons();
                logSystem(`B·∫Øt ƒë·∫ßu ƒë·ªçc: "${text.substring(0, 30)}..."`);
            };
            
            utterance.onend = () => {
                isSpeaking = false;
                updateSpeechButtons();
            };
            
            currentSpeech = utterance;
            speechSynthesis.speak(utterance);
        }

        function playAudio(url) {
            const audio = new Audio(url);
            audio.onended = () => {
                isSpeaking = false;
                updateSpeechButtons();
                URL.revokeObjectURL(url);
            };
            
            audio.onerror = () => {
                isSpeaking = false;
                updateSpeechButtons();
                URL.revokeObjectURL(url);
            };
            
            currentSpeech = audio;
            audio.play();
        }

        function pcmToWav(pcmData) {
            // Gi·∫£n l∆∞·ª£c - th·ª±c t·∫ø c·∫ßn x·ª≠ l√Ω PCM ƒë√∫ng c√°ch
            return new Blob([pcmData], { type: 'audio/wav' });
        }

        function getGeminiVoiceName(lang, gender) {
            const voices = {
                'vi-VN': { male: 'Aoede', female: 'Kore' },
                'en-US': { male: 'Kore', female: 'Aoede' },
                'ja-JP': { male: 'Aoede', female: 'Kore' },
                'ko-KR': { male: 'Kore', female: 'Aoede' }
            };
            
            return voices[lang]?.[gender] || 'Aoede';
        }

        function stopSpeech() {
            if (currentSpeech) {
                if (currentSpeech.pause) {
                    currentSpeech.pause();
                    currentSpeech.currentTime = 0;
                }
                if (window.speechSynthesis) {
                    window.speechSynthesis.cancel();
                }
            }
            
            isSpeaking = false;
            updateSpeechButtons();
            logSystem('ƒê√£ d·ª´ng ƒë·ªçc');
        }

        function updateSpeechButtons() {
            const speakVnBtn = document.getElementById('speakVnBtn');
            const speakTransBtn = document.getElementById('speakTransBtn');
            const stopBtn = document.getElementById('stopSpeechBtn');
            
            const hasVietnamese = sentenceText || document.getElementById('translationInput').value;
            const hasTranslation = document.getElementById('translationResult').textContent !== 'Ch∆∞a c√≥ b·∫£n d·ªãch';
            
            speakVnBtn.disabled = !hasVietnamese || isSpeaking;
            speakTransBtn.disabled = !hasTranslation || isSpeaking;
            stopBtn.disabled = !isSpeaking;
            
            if (isSpeaking) {
                speakVnBtn.innerHTML = '<span>üîä</span> ƒêang ƒë·ªçc...';
            } else {
                speakVnBtn.innerHTML = '<span>üîä</span> ƒê·ªçc ti·∫øng Vi·ªát';
            }
        }

        // ==============================================
        // CALIBRATION
        // ==============================================
        function loadCalibration() {
            try {
                const savedStraight = localStorage.getItem('straightThresholds');
                const savedBent = localStorage.getItem('bentThresholds');
                
                if (savedStraight) straightThresholds = JSON.parse(savedStraight);
                if (savedBent) bentThresholds = JSON.parse(savedBent);
                
                updateThresholdDisplay();
                logSystem('ƒê√£ t·∫£i calibration');
            } catch (e) {
                console.error('Load calibration error:', e);
            }
        }

        function saveCalibration() {
            localStorage.setItem('straightThresholds', JSON.stringify(straightThresholds));
            localStorage.setItem('bentThresholds', JSON.stringify(bentThresholds));
        }

        function updateThresholdDisplay() {
            document.getElementById('straightThresholds').textContent = straightThresholds.join(', ');
            document.getElementById('bentThresholds').textContent = bentThresholds.join(', ');
        }

        function setStraightThreshold() {
            if (!firebaseData) {
                logSystem('Kh√¥ng c√≥ d·ªØ li·ªáu c·∫£m bi·∫øn');
                return;
            }
            
            const values = [
                firebaseData.f0 || 0,
                firebaseData.f1 || 0,
                firebaseData.f2 || 0,
                firebaseData.f3 || 0
            ];
            
            straightThresholds = [...values];
            saveCalibration();
            updateThresholdDisplay();
            
            logSystem(`ƒê√£ set straight thresholds: ${straightThresholds}`);
        }

        function startCalibration() {
            if (isCalibrating) {
                stopCalibration();
                return;
            }
            
            if (!firebaseData) {
                logSystem('Kh√¥ng c√≥ d·ªØ li·ªáu c·∫£m bi·∫øn');
                return;
            }
            
            isCalibrating = true;
            calibrationTimeLeft = 10;
            calibrationMaxValues = [0, 0, 0, 0];
            
            // L·∫•y gi√° tr·ªã ban ƒë·∫ßu
            calibrationBaseValues = [
                firebaseData.f0 || 0,
                firebaseData.f1 || 0,
                firebaseData.f2 || 0,
                firebaseData.f3 || 0
            ];
            
            // C·∫≠p nh·∫≠t UI
            const btn = document.getElementById('calibrateBtn');
            btn.innerHTML = '<span>‚è∏Ô∏è</span> D·ª´ng';
            btn.classList.add('warning');
            
            document.getElementById('calibrationProgress').style.display = 'block';
            document.getElementById('calibrationTimer').style.display = 'block';
            
            // B·∫Øt ƒë·∫ßu ƒë·∫øm ng∆∞·ª£c
            calibrationTimer = setInterval(() => {
                calibrationTimeLeft--;
                updateCalibrationUI();
                
                if (calibrationTimeLeft <= 0) {
                    finishCalibration();
                }
            }, 1000);
            
            logSystem('B·∫Øt ƒë·∫ßu calibration - U·ªën ng√≥n tay h·∫øt m·ª©c trong 10 gi√¢y');
        }

        function updateCalibrationValues(currentValues) {
            for (let i = 0; i < 4; i++) {
                if (currentValues[i] > calibrationMaxValues[i]) {
                    calibrationMaxValues[i] = currentValues[i];
                }
            }
        }

        function updateCalibrationUI() {
            const progress = ((10 - calibrationTimeLeft) / 10) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
            document.getElementById('timeRemaining').textContent = calibrationTimeLeft;
        }

        function stopCalibration() {
            if (!isCalibrating) return;
            
            clearInterval(calibrationTimer);
            isCalibrating = false;
            
            const btn = document.getElementById('calibrateBtn');
            btn.innerHTML = '<span>üéØ</span> Calibrate';
            btn.classList.remove('warning');
            
            document.getElementById('calibrationProgress').style.display = 'none';
            document.getElementById('calibrationTimer').style.display = 'none';
            
            logSystem('ƒê√£ d·ª´ng calibration');
        }

        function finishCalibration() {
            clearInterval(calibrationTimer);
            isCalibrating = false;
            
            // T√≠nh to√°n bent thresholds
            for (let i = 0; i < 4; i++) {
                if (calibrationMaxValues[i] > straightThresholds[i] + 50) {
                    bentThresholds[i] = calibrationMaxValues[i];
                } else {
                    bentThresholds[i] = straightThresholds[i] + 200;
                }
            }
            
            saveCalibration();
            updateThresholdDisplay();
            
            // Reset UI
            const btn = document.getElementById('calibrateBtn');
            btn.innerHTML = '<span>üéØ</span> Calibrate';
            btn.classList.remove('warning');
            
            document.getElementById('calibrationProgress').style.display = 'none';
            document.getElementById('calibrationTimer').style.display = 'none';
            
            logSystem(`Calibration ho√†n th√†nh! Bent thresholds: ${bentThresholds}`);
        }

        function resetCalibration() {
            straightThresholds = [100, 150, 150, 150];
            bentThresholds = [300, 450, 350, 300];
            
            saveCalibration();
            updateThresholdDisplay();
            logSystem('ƒê√£ reset calibration v·ªÅ m·∫∑c ƒë·ªãnh');
        }

        // ==============================================
        // HI·ªÜU NƒÇNG V√Ä CONTROLS
        // ==============================================
        function startPerformanceMonitor() {
            function updateFPS() {
                frameCount++;
                const currentTime = performance.now();
                
                if (currentTime - lastFrameTime >= 1000) {
                    currentFPS = frameCount;
                    frameCount = 0;
                    lastFrameTime = currentTime;
                    
                    document.getElementById('fpsDisplay').textContent = currentFPS;
                    document.getElementById('performanceStatus').textContent = `FPS: ${currentFPS}`;
                    
                    // ƒêi·ªÅu ch·ªânh hi·ªáu nƒÉng
                    if (currentFPS < 30 && pollingInterval > 150) {
                        pollingInterval = Math.min(pollingInterval * 1.5, 1000);
                        updatePollingDisplay();
                    } else if (currentFPS > 50 && pollingInterval < 1000) {
                        pollingInterval = Math.max(pollingInterval * 0.8, 150);
                        updatePollingDisplay();
                    }
                }
                
                requestAnimationFrame(updateFPS);
            }
            
            updateFPS();
        }

        function refreshData() {
            fetchFirebaseData();
        }

        function startAutoRefresh() {
            if (autoRefreshInterval) clearInterval(autoRefreshInterval);
            
            autoRefreshInterval = setInterval(() => {
                if (autoRefresh && !isFetching) {
                    fetchFirebaseData();
                }
            }, pollingInterval);
            
            updatePollingDisplay();
        }

        function toggleAutoRefresh() {
            autoRefresh = !autoRefresh;
            const btn = document.getElementById('autoRefreshBtn');
            
            if (autoRefresh) {
                btn.innerHTML = '<span>‚è±Ô∏è</span> T·ª± ƒë·ªông: B·∫¨T';
                btn.classList.remove('danger');
                btn.classList.add('success');
                startAutoRefresh();
                logSystem(`B·∫≠t auto refresh (${pollingInterval}ms)`);
            } else {
                btn.innerHTML = '<span>‚è±Ô∏è</span> T·ª± ƒë·ªông: T·∫ÆT';
                btn.classList.remove('success');
                btn.classList.add('danger');
                if (autoRefreshInterval) clearInterval(autoRefreshInterval);
                logSystem('T·∫Øt auto refresh');
            }
        }

        function toggleTurboMode() {
            turboMode = !turboMode;
            const btn = document.getElementById('turboBtn');
            const indicator = document.getElementById('fastModeIndicator');
            
            if (turboMode) {
                pollingInterval = 150;
                btn.innerHTML = '<span>üöÄ</span> Turbo: B·∫¨T';
                btn.classList.remove('info');
                btn.classList.add('danger');
                indicator.style.display = 'block';
                logSystem('B·∫≠t Turbo Mode (150ms)');
            } else {
                pollingInterval = 300;
                btn.innerHTML = '<span>üöÄ</span> Turbo Mode';
                btn.classList.remove('danger');
                btn.classList.add('info');
                indicator.style.display = 'none';
                logSystem('T·∫Øt Turbo Mode (300ms)');
            }
            
            updatePollingDisplay();
            startAutoRefresh();
        }

        function updatePollingDisplay() {
            document.getElementById('pollingDisplay').textContent = pollingInterval;
        }

        function adjustPollingInterval(fetchTime) {
            if (fetchTime < 100) {
                pollingInterval = turboMode ? 100 : 200;
            } else if (fetchTime > 500) {
                pollingInterval = Math.min(pollingInterval * 1.5, 2000);
            }
        }

        // ==============================================
        // UI UPDATES
        // ==============================================
        function updateUI() {
            updateWordDisplays();
            updateSensorDisplays();
            updateTimeDisplay();
            updateSpeechButtons();
        }

        function updateSensorDisplays() {
            // C·∫≠p nh·∫≠t flex boxes
            for (let i = 0; i < 4; i++) {
                const box = document.getElementById(`flexBox${i}`);
                if (box) {
                    box.textContent = flexStates[i];
                    box.className = `flex-box state-${flexStates[i]}`;
                }
            }
        }

        function updateFlexBox(index, state) {
            const box = document.getElementById(`flexBox${index}`);
            if (box) {
                box.textContent = state;
                box.className = `flex-box state-${state}`;
            }
        }

        function updateTimeDisplay() {
            const timeString = new Date().toLocaleTimeString('vi-VN');
            document.getElementById('lastUpdateTime').textContent = timeString;
            document.getElementById('updateStatus').textContent = `C·∫≠p nh·∫≠t: ${timeString}`;
        }

        function setConnectionStatus(connected) {
            const indicator = document.querySelector('.connection-status');
            const dot = indicator.querySelector('.indicator-dot');
            const text = document.getElementById('statusText');
            const connectionIndicator = document.getElementById('connectionIndicator');
            
            if (connected) {
                dot.style.background = '#4caf50';
                dot.style.animation = 'pulse 2s infinite';
                text.textContent = 'ƒê√£ k·∫øt n·ªëi Firebase';
                connectionIndicator.classList.remove('offline');
                logSystem('K·∫øt n·ªëi Firebase ·ªïn ƒë·ªãnh');
            } else {
                dot.style.background = '#f44336';
                dot.style.animation = 'none';
                text.textContent = 'M·∫•t k·∫øt n·ªëi Firebase';
                connectionIndicator.classList.add('offline');
            }
        }

        // ==============================================
        // LOGGING SYSTEM
        // ==============================================
        function logSystem(message) {
            const timestamp = new Date().toLocaleTimeString('vi-VN', { 
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            
            const entry = {
                timestamp,
                message,
                type: 'system'
            };
            
            logEntries.unshift(entry);
            if (logEntries.length > MAX_LOG_ENTRIES) {
                logEntries.pop();
            }
            
            updateLogDisplay();
            console.log(`[${timestamp}] ${message}`);
        }

        function updateLogDisplay() {
            const container = document.getElementById('logContainer');
            container.innerHTML = '';
            
            logEntries.forEach(entry => {
                const div = document.createElement('div');
                div.className = 'log-entry';
                div.innerHTML = `
                    <span class="log-time">[${entry.timestamp}]</span>
                    <span class="log-source">SYSTEM:</span>
                    <span>${entry.message}</span>
                `;
                container.appendChild(div);
            });
        }

        function clearLog() {
            logEntries = [];
            updateLogDisplay();
            logSystem('ƒê√£ x√≥a nh·∫≠t k√Ω');
        }

        function exportLog() {
            const logText = logEntries.map(entry => 
                `[${entry.timestamp}] ${entry.message}`
            ).join('\n');
            
            const blob = new Blob([logText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dich_thu_ngu_log_${new Date().toISOString().slice(0, 10)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            logSystem('ƒê√£ xu·∫•t nh·∫≠t k√Ω');
        }
    </script>
</body>
</html>
