<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Gangtay — Multi-method Mobile Audio Tester</title>
<style>
  body{font-family:system-ui,Arial,sans-serif;padding:14px;max-width:980px;margin:auto}
  h1{font-size:1.1rem;margin-bottom:.2rem}
  p.muted{color:#666;margin-top:0;margin-bottom:8px}
  label{display:block;margin-top:10px;font-weight:600}
  input, button, select {padding:10px;margin:6px 0;width:100%;box-sizing:border-box}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .half{flex:1 1 48%}
  #log{font-family:monospace;background:#f6f6f6;padding:10px;border-radius:6px;max-height:320px;overflow:auto;white-space:pre-wrap}
  button.small{padding:8px}
  .ok{color:green}
  .err{color:crimson}
  .methods{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
</style>
</head>
<body>
  <h1>Gangtay — Multi-method Mobile Audio Tester</h1>
  <p class="muted">Fetch the latest index from Firebase or enter an index, unlock audio once, then test different playback methods.</p>

  <label>Index to play (1-based)</label>
  <input id="indexInput" type="number" value="2" min="1" />

  <div class="row">
    <button id="fetchIndexBtn" class="half">Fetch latest index (one-shot)</button>
    <button id="useLastBtn" class="half" style="display:none">Use last payload</button>
  </div>

  <label>Audio base URL (folder or absolute URL, must end with slash if folder)</label>
  <input id="audioBase" type="text" value="/audio/" />

  <label>Firebase message.json URL (read only when you press Fetch)</label>
  <input id="firebaseUrl" type="text" value="https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json" />

  <div class="row" style="margin-top:8px;">
    <button id="unlockBtn" class="half">Unlock audio (tap once)</button>
    <button id="runAllBtn" class="half">Run all methods (sequence)</button>
  </div>

  <label style="margin-top:12px">Individual methods (tap to try one)</label>
  <div class="methods">
    <button id="m1">1. HTMLAudio element</button>
    <button id="m2">2. Fetch → Blob → Audio</button>
    <button id="m3">3. Fetch → decodeAudioData → WebAudio</button>
    <button id="m4">4. Fetch → Blob → objectURL Audio (alt)</button>
    <button id="m5">5. MediaSource API append (try)</button>
    <button id="m6">6. Create controls audio (manual play)</button>
  </div>

  <div style="margin-top:12px" class="row">
    <button id="clearLog" class="half">Clear log</button>
    <button id="copyLog" class="half">Copy log</button>
  </div>

  <div id="status" style="margin-top:10px">Status: ready</div>
  <pre id="log"></pre>

<script>
/* Multi-method audio test page
   - Put on your site; set audioBase and index then press buttons.
   - Run All executes each method sequentially with small delays.
   - Mobile note: you must call Unlock audio (one tap) at least once if autoplay blocked.
*/

const idxEl = document.getElementById('indexInput');
const audioBaseEl = document.getElementById('audioBase');
const fetchIndexBtn = document.getElementById('fetchIndexBtn');
const firebaseUrlEl = document.getElementById('firebaseUrl');
const unlockBtn = document.getElementById('unlockBtn');
const runAllBtn = document.getElementById('runAllBtn');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
const clearLogBtn = document.getElementById('clearLog');
const copyLogBtn = document.getElementById('copyLog');
const useLastBtn = document.getElementById('useLastBtn');

let audioCtx = null;
let masterGain = null;
let unlocked = false;
let lastPayload = null; // store last fetched payload

function now(){ return new Date().toLocaleTimeString(); }
function log(s, cls){ const line = `[${now()}] ${s}`; logEl.textContent = line + '\n' + logEl.textContent; if(cls) statusEl.className = cls; }
function setStatus(s){ statusEl.textContent = 'Status: ' + s; log(s); }

function pad4(n){ return String(n).padStart(4, '0'); }
function fileUrlForIndex(i) {
  const base = (audioBaseEl.value || '/audio/').trim();
  const fname = pad4(i) + '.mp3';
  if (/^https?:\/\//i.test(base)) return base.endsWith('/') ? base + fname : base + '/' + fname;
  if (base.startsWith('/')) return location.origin + (base.endsWith('/') ? base + fname : base + '/' + fname);
  return location.origin + '/' + (base.endsWith('/') ? base + fname : base + '/' + fname);
}

/* --- Unlock helpers --- */
function ensureAudioCtx() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 1.0;
  masterGain.connect(audioCtx.destination);
  log('AudioContext created');
}
async function tryUnlock() {
  if (unlocked) return true;
  ensureAudioCtx();
  try {
    // try muted audio element first
    const a = new Audio();
    a.muted = true;
    try { await a.play(); } catch(e){}
    if (audioCtx.state === 'running') { unlocked = true; log('Unlocked via muted element'); return true; }
    // else play small tone via WebAudio
    const nowt = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'sine'; osc.frequency.value = 880;
    g.gain.value = 0.0001;
    osc.connect(g); g.connect(masterGain);
    g.gain.setValueAtTime(0.0001, nowt);
    g.gain.linearRampToValueAtTime(0.06, nowt + 0.01);
    osc.start(nowt);
    g.gain.linearRampToValueAtTime(0.0001, nowt + 0.12);
    osc.stop(nowt + 0.13);
    try { await audioCtx.resume(); } catch(e){}
    await new Promise(r=>setTimeout(r,160));
    unlocked = (audioCtx.state === 'running');
    log('Tried WebAudio tone unlock — unlocked=' + unlocked);
    return unlocked;
  } catch(e) {
    log('Unlock exception: ' + e, 'err');
    return false;
  }
}

/* --- Playback methods --- */

/* Method 1: simple HTMLAudio element */
async function method1_play(i){
  const url = fileUrlForIndex(i);
  log('M1: HTMLAudio.play() -> ' + url);
  const a = new Audio(url);
  a.playsInline = true;
  a.crossOrigin = 'anonymous';
  a.preload = 'auto';
  a.onended = ()=> log('M1: ended', 'ok');
  a.onerror = (ev)=> log('M1: element error: ' + ev?.message || 'error', 'err');
  try {
    await a.play();
    log('M1: play started', 'ok');
  } catch(e) {
    log('M1: play rejected: ' + e, 'err');
  }
}

/* Method 2: fetch -> blob -> audio element */
async function method2_play(i){
  const url = fileUrlForIndex(i);
  log('M2: fetch->blob->Audio -> ' + url);
  try {
    const r = await fetch(url, {cache:'no-store'});
    log('M2: fetch status ' + r.status);
    if (!r.ok) { log('M2: fetch failed', 'err'); return; }
    const blob = await r.blob();
    const obj = URL.createObjectURL(blob);
    const a = new Audio(obj);
    a.playsInline = true;
    a.crossOrigin = 'anonymous';
    a.onended = ()=> { log('M2: ended', 'ok'); URL.revokeObjectURL(obj); };
    a.onerror = (ev)=> { log('M2: element error', 'err'); URL.revokeObjectURL(obj); };
    try { await a.play(); log('M2: play started', 'ok'); }
    catch(e){ log('M2: play rejected: ' + e, 'err'); URL.revokeObjectURL(obj); }
  } catch(e) {
    log('M2: exception: ' + e, 'err');
  }
}

/* Method 3: fetch -> arrayBuffer -> decodeAudioData -> AudioBufferSourceNode (WebAudio) */
async function method3_play(i){
  const url = fileUrlForIndex(i);
  log('M3: fetch->decodeAudioData(WebAudio) -> ' + url);
  ensureAudioCtx();
  try {
    const r = await fetch(url, {cache:'no-store'});
    log('M3: fetch status ' + r.status);
    if (!r.ok) { log('M3: fetch failed', 'err'); return; }
    const ab = await r.arrayBuffer();
    // decode compat
    const buf = await new Promise((resolve,reject) => {
      try {
        const p = audioCtx.decodeAudioData(ab);
        if (p && typeof p.then === 'function') { p.then(resolve).catch(err=>{ try{ audioCtx.decodeAudioData(ab, resolve, reject); } catch(e){ reject(err||e); } }); return; }
      } catch(e){}
      try { audioCtx.decodeAudioData(ab, resolve, reject); } catch(e){ reject(e); }
    });
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    src.connect(masterGain);
    src.onended = ()=> log('M3: ended (duration ' + (buf.duration||0).toFixed(2) + 's)', 'ok');
    src.start(0);
    log('M3: started', 'ok');
  } catch(e) {
    log('M3: exception: ' + e, 'err');
  }
}

/* Method 4: fetch->blob->objectURL Audio (alternative path) */
async function method4_play(i){
  // same as M2 but keep slight differences (shows an alternate code path)
  const url = fileUrlForIndex(i);
  log('M4: fetch->blob->objectURL Audio -> ' + url);
  try {
    const r = await fetch(url, {cache:'no-store'});
    if (!r.ok) { log('M4: fetch failed ' + r.status, 'err'); return; }
    const data = await r.arrayBuffer();
    const blob = new Blob([data], {type: 'audio/mpeg'});
    const obj = URL.createObjectURL(blob);
    const a = new Audio(obj);
    a.playsInline = true;
    a.crossOrigin = 'anonymous';
    a.onended = ()=> { log('M4: ended', 'ok'); URL.revokeObjectURL(obj); };
    a.onerror = ()=> { log('M4: element error', 'err'); URL.revokeObjectURL(obj); };
    try { await a.play(); log('M4: play started', 'ok'); }
    catch(e) { log('M4: play rejected: ' + e, 'err'); URL.revokeObjectURL(obj); }
  } catch(e) { log('M4: exception: ' + e, 'err'); }
}

/* Method 5: MediaSource API (append buffer) — may not be supported on some mobiles */
async function method5_play(i){
  const url = fileUrlForIndex(i);
  log('M5: MediaSource append -> ' + url);
  try {
    if (!('MediaSource' in window)) { log('M5: MediaSource not supported', 'err'); return; }
    const r = await fetch(url, {cache:'no-store'});
    if (!r.ok) { log('M5: fetch failed ' + r.status, 'err'); return; }
    const ab = await r.arrayBuffer();
    const ms = new MediaSource();
    const audio = new Audio();
    audio.playsInline = true;
    audio.crossOrigin = 'anonymous';
    audio.src = URL.createObjectURL(ms);
    ms.addEventListener('sourceopen', () => {
      try {
        const mime = 'audio/mpeg';
        const sb = ms.addSourceBuffer(mime);
        sb.addEventListener('updateend', () => {
          try { ms.endOfStream(); audio.play().then(()=>log('M5: play started', 'ok')).catch(e=>log('M5: play rejected: '+e,'err')); }
          catch(e){ log('M5: play start failed: '+e,'err'); }
        });
        sb.appendBuffer(new Uint8Array(ab));
      } catch(e) { log('M5: sourceopen error: '+e,'err'); }
    });
    audio.onerror = ()=> log('M5: audio element error', 'err');
  } catch(e) { log('M5: exception: ' + e, 'err'); }
}

/* Method 6: Create <audio controls> element so user can manually press play (guaranteed if file reachable) */
async function method6_play(i){
  const url = fileUrlForIndex(i);
  log('M6: create <audio controls> -> ' + url);
  // remove previous test control if any
  const old = document.getElementById('manual-control');
  if (old) old.remove();
  const a = document.createElement('audio');
  a.id = 'manual-control';
  a.controls = true;
  a.playsInline = true;
  a.crossOrigin = 'anonymous';
  a.src = url + '?ts=' + Date.now();
  a.style.width = '100%';
  document.body.appendChild(a);
  log('M6: control inserted — press Play manually', 'ok');
  a.onplay = ()=> log('M6: user pressed Play', 'ok');
  a.onended = ()=> log('M6: ended', 'ok');
  a.onerror = ()=> log('M6: element error', 'err');
}

/* --- Helpers to run & orchestration --- */
async function runMethodById(id, i) {
  try {
    switch(id){
      case 1: await method1_play(i); break;
      case 2: await method2_play(i); break;
      case 3: await method3_play(i); break;
      case 4: await method4_play(i); break;
      case 5: await method5_play(i); break;
      case 6: await method6_play(i); break;
    }
  } catch(e) {
    log('Run method ' + id + ' exception: ' + e, 'err');
  }
}

document.getElementById('m1').addEventListener('click', ()=> runMethodById(1, Number(idxEl.value || 1)));
document.getElementById('m2').addEventListener('click', ()=> runMethodById(2, Number(idxEl.value || 1)));
document.getElementById('m3').addEventListener('click', ()=> runMethodById(3, Number(idxEl.value || 1)));
document.getElementById('m4').addEventListener('click', ()=> runMethodById(4, Number(idxEl.value || 1)));
document.getElementById('m5').addEventListener('click', ()=> runMethodById(5, Number(idxEl.value || 1)));
document.getElementById('m6').addEventListener('click', ()=> runMethodById(6, Number(idxEl.value || 1)));

unlockBtn.addEventListener('click', async ()=> {
  setStatus('Attempting unlock...');
  const ok = await tryUnlock();
  if (ok) { unlocked = true; setStatus('Unlocked — you can now try play methods'); log('Unlocked by user gesture', 'ok'); }
  else { setStatus('Unlock attempt finished (may be blocked)'); log('Unlock attempt finished'); }
});

runAllBtn.addEventListener('click', async
