<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gangtay — Auto Play (auto-unlock + queue)</title>
<style>
  body{font-family:system-ui,Arial;padding:18px;max-width:900px;margin:auto}
  h1{font-size:1.3rem;margin-bottom:.2rem}
  .muted{color:#666;font-size:.9rem}
  label{display:block;margin-top:10px;font-weight:600}
  input[type="text"], input[type="url"]{width:100%;padding:8px;margin-top:6px;box-sizing:border-box}
  button{padding:12px 16px;margin:8px 6px;font-size:1rem}
  .row{display:flex;gap:8px;align-items:center;margin-top:8px}
  #status{margin-top:10px;color:#333}
  #log{white-space:pre-wrap;font-family:monospace;margin-top:10px;background:#f6f6f6;padding:8px;border-radius:6px;max-height:260px;overflow:auto}
  .bigManual{background:#ff4757;color:white;border:none;padding:12px 18px;font-weight:700;border-radius:6px}
  .controls{display:flex;gap:8px;align-items:center;margin-top:8px}
</style>
</head>
<body>
  <h1>Gangtay — Auto Play (auto-unlock + queue)</h1>
  <p class="muted">Tap anywhere on the page or press <strong>Manual Play (tap once)</strong> to unlock audio. After unlock the page will automatically play queued audio files when Firebase messages arrive.</p>

  <label>1) T1.TXT (site root /T1.TXT or upload local)</label>
  <div class="row">
    <input type="file" id="fileInput" accept=".txt">
    <button id="reloadTxt">Try fetch /T1.TXT</button>
  </div>
  <div id="txtInfo" class="muted">Trying to fetch /T1.TXT ...</div>

  <label>2) Audio base path</label>
  <input id="audioBase" type="text" value="/audio/" />

  <label>3) Firebase message URL</label>
  <input id="firebaseUrl" type="url" value="https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json" />

  <div class="row">
    <button id="enableBtn">Enable audio & Start polling</button>
    <button id="stopBtn" disabled>Stop polling</button>
    <button id="previewBtn">Preview 0001</button>
    <button id="manualPlay" class="bigManual" style="display:none">Manual Play (tap once)</button>
  </div>

  <label>Volume (gain)</label>
  <div class="controls">
    <input id="gainSlider" type="range" min="0.2" max="4.0" step="0.05" value="1.2">
    <div id="gainVal">Gain x1.20</div>
  </div>

  <div id="status">Status: idle</div>
  <div id="log"></div>

<script>
/* Auto-unlock + queue flush page
 - If play is blocked: queue requested plays and show Manual Play button
 - Listen for first touch/click anywhere and use it to unlock (so user doesn't have to aim for the small button)
 - Use an audible oscillator "tone" to unlock WebAudio reliably
 - After unlock, flush the queued items
*/

const FIREBASE_DEFAULT = "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json";
const POLL_INTERVAL_MS = 1000;

const fileInput = document.getElementById('fileInput');
const reloadTxtBtn = document.getElementById('reloadTxt');
const txtInfo = document.getElementById('txtInfo');
const audioBaseEl = document.getElementById('audioBase');
const firebaseUrlEl = document.getElementById('firebaseUrl');
const enableBtn = document.getElementById('enableBtn');
const stopBtn = document.getElementById('stopBtn');
const previewBtn = document.getElementById('previewBtn');
const manualBtn = document.getElementById('manualPlay');
const gainSlider = document.getElementById('gainSlider');
const gainVal = document.getElementById('gainVal');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');

let lines = [];
let pollHandle = null;
let lastTs = null;
let audioCtx = null;
let masterGain = null;
let currentAudio = null;
let pendingQueue = []; // queued {type:'index'|'text', value}
let unlocked = false;

// util
function log(msg){ const t = new Date().toLocaleTimeString(); logEl.textContent = `[${t}] ${msg}\n` + logEl.textContent; }
function setStatus(s){ statusEl.textContent = 'Status: ' + s; log(s); }
function pad4(n){ return String(n).padStart(4,'0'); }

// T1.TXT
async function fetchRemoteTxt(){
  setStatus('Fetching /T1.TXT ...');
  try {
    const r = await fetch('/T1.TXT', { cache: 'no-store' });
    if (!r.ok) { setStatus('/T1.TXT not found (HTTP ' + r.status + ')'); return false; }
    const txt = await r.text();
    parseTxt(txt);
    setStatus(`Loaded /T1.TXT (${lines.length} entries)`);
    return true;
  } catch (e) {
    setStatus('Fetch /T1.TXT failed: ' + e.message);
    return false;
  }
}
function parseTxt(txt){ const raw = txt.split(/\r?\n/); lines = raw.map(l => l.trim()).filter(l => l.length>0); log('Parsed lines: '+lines.length); }
fileInput.addEventListener('change', async (ev) => { const f = ev.target.files && ev.target.files[0]; if(!f) return; setStatus('Reading '+f.name); try{ const txt = await f.text(); parseTxt(txt); setStatus('Loaded local '+f.name+' ('+lines.length+' lines)'); }catch(e){ setStatus('Read failed: '+e.message);} });
reloadTxtBtn.addEventListener('click', fetchRemoteTxt);

// AudioContext + gain
function createAudioCtxIfNeeded(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = parseFloat(gainSlider.value || 1.0);
  masterGain.connect(audioCtx.destination);
  log('AudioContext created, gain=' + masterGain.gain.toFixed(2));
}
gainSlider.addEventListener('input', ()=>{ const v = parseFloat(gainSlider.value); gainVal.textContent = `Gain x${v.toFixed(2)}`; if(masterGain && audioCtx) masterGain.gain.setValueAtTime(v, audioCtx.currentTime); });

// unlock strategies
async function unlockWithTone(){
  try {
    createAudioCtxIfNeeded();
    if (audioCtx.state === 'running') { unlocked = true; return true; }
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = 880;
    g.gain.value = 0.0001;
    osc.connect(g);
    g.connect(masterGain);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.linearRampToValueAtTime(0.08, now + 0.01);
    osc.start(now);
    g.gain.linearRampToValueAtTime(0.0001, now + 0.18);
    osc.stop(now + 0.19);
    try { await audioCtx.resume(); } catch(e){}
    await new Promise(r => setTimeout(r, 250));
    if (audioCtx.state === 'running') { unlocked = true; log('Unlocked (tone)'); return true; }
    log('unlockWithTone: audioCtx state=' + audioCtx.state);
    return false;
  } catch (e) {
    console.warn('unlockWithTone error', e);
    return false;
  }
}

// fallback: try to play a tiny muted HTMLAudio then unmute (some browsers accept HTMLAudio gesture)
async function unlockWithHtmlAudio() {
  try {
    createAudioCtxIfNeeded();
    const a = new Audio();
    // use a short silent/empty track via WebAudio approach is complicated; attempt to play without src (gesture)
    a.muted = false;
    try { await a.play(); } catch(e){ /* ignore */ }
    await new Promise(r => setTimeout(r, 50));
    if (audioCtx && audioCtx.state === 'running') { unlocked = true; log('Unlocked (html audio)'); return true; }
    return false;
  } catch(e) { console.warn('unlockWithHtmlAudio error', e); return false; }
}

// call sequence to unlock using any gesture
async function tryUnlockSequence() {
  if (unlocked) return true;
  let ok = await unlockWithTone();
  if (ok) return true;
  // second attempt: html audio fallback
  ok = await unlockWithHtmlAudio();
  if (ok) return true;
  // still blocked
  return false;
}

// make MediaElementSource if possible
function makeAudioElement(url){
  createAudioCtxIfNeeded();
  const a = new Audio(url);
  a.crossOrigin = 'anonymous';
  try {
    if (currentAudio && currentAudio._mediaSource) try { currentAudio._mediaSource.disconnect(); } catch(e){}
    const src = audioCtx.createMediaElementSource(a);
    src.connect(masterGain);
    a._mediaSource = src;
  } catch(e) {
    console.warn('createMediaElementSource/connect failed', e);
    a.volume = Math.min(1.0, parseFloat(gainSlider.value || 1.0));
  }
  return a;
}

async function tryPlayElement(el){
  try {
    if (audioCtx && audioCtx.state === 'suspended') try { await audioCtx.resume(); } catch(e){}
    await el.play();
    return true;
  } catch(e) {
    console.warn('play rejected', e);
    return false;
  }
}

// fallback decode
async function fetchAndPlayBuffer(url){
  try {
    createAudioCtxIfNeeded();
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error('fetch status '+res.status);
    const ab = await res.arrayBuffer();
    const buf = await audioCtx.decodeAudioData(ab);
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    src.connect(masterGain);
    if (audioCtx.state === 'suspended') try { await audioCtx.resume(); } catch(e){}
    src.start(0);
    await new Promise(r => setTimeout(r, Math.max(300, buf.duration*1000+100)));
    return true;
  } catch(e) { console.warn('fetchAndPlayBuffer failed', e); return false; }
}

// main play
async function playFileByIndex(idx){
  if (idx <= 0) { setStatus('Invalid index'); return; }
  const name = pad4(idx) + '.mp3';
  let base = audioBaseEl.value.trim() || '/audio/';
  if (!base.endsWith('/')) base += '/';
  const url = (base.startsWith('http') ? base : base) + name + '?ts=' + Date.now();
  setStatus('Play request: ' + name + ' → ' + url);
  try {
    if (currentAudio) { try { currentAudio.pause(); currentAudio.src = ""; } catch(e){} currentAudio = null; }
    const a = makeAudioElement(url);
    currentAudio = a;
    const ok = await tryPlayElement(a);
    if (ok) {
      a.onended = ()=> setStatus('Finished ' + name);
      a.onerror = ()=> setStatus('Audio element error ' + name);
      return true;
    }
    // blocked -> queue and show manual
    setStatus('Play blocked by browser — queuing and showing Manual Play');
    pendingQueue.push({type:'index', value: idx});
    showManualButton();
    return false;
  } catch(e) {
    console.warn('play exception', e);
    const ok2 = await fetchAndPlayBuffer(url);
    if (!ok2) {
      setStatus('Play failed (both). Queued and show Manual Play.');
      pendingQueue.push({type:'index', value: idx});
      showManualButton();
      return false;
    } else {
      setStatus('Played via buffer ' + name);
      return true;
    }
  }
}

function findIndexForText(text){
  if (!text) return -1;
  const k = text.trim().toLowerCase();
  for (let i=0;i<lines.length;i++){
    if ((lines[i]||'').toLowerCase() === k) return i+1;
  }
  return -1;
}

async function handleMessageObject(obj){
  if (!obj) return;
  if (typeof obj.index === 'number') {
    await playFileByIndex(obj.index);
    return;
  }
  const t = (typeof obj.text === 'string') ? obj.text : (typeof obj.message === 'string' ? obj.message : null);
  if (!t) return;
  const idx = findIndexForText(t);
  if (idx > 0) await playFileByIndex(idx);
  else {
    setStatus(`Text not found in T1.TXT: "${t}"`);
    log('Text not found: '+t);
    pendingQueue.push({type:'text', value: t});
    showManualButton();
  }
}

async function flushPending(){
  while (pendingQueue.length > 0) {
    const it = pendingQueue.shift();
    if (it.type === 'index') {
      await playFileByIndex(it.value);
      await new Promise(r=>setTimeout(r, 250));
    } else if (it.type === 'text') {
      const idx = findIndexForText(it.value);
      if (idx>0) { await playFileByIndex(idx); await new Promise(r=>setTimeout(r,250)); }
      else log('Queued text still not found: '+it.value);
    }
  }
}

// show manual play button prominently
function showManualButton(){
  manualBtn.style.display = 'inline-block';
  manualBtn.focus();
}

// hide manual button
function hideManualButton(){ manualBtn.style.display = 'none'; }

// poll once
async function pollOnce(){
  const url = firebaseUrlEl.value.trim() || FIREBASE_DEFAULT;
  try {
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) { setStatus('Firebase fetch failed: '+r.status); return; }
    const j = await r.json();
    const t = j && (j.ts || j.timestamp || JSON.stringify(j));
    if (!t) return;
    if (String(t) !== String(lastTs)) {
      lastTs = t;
      log('New firebase message: ' + JSON.stringify(j));
      await handleMessageObject(j);
    }
  } catch(e){ console.warn('poll error', e); setStatus('Poll error: '+(e.message||e)); }
}

// manual button handler
manualBtn.addEventListener('click', async ()=>{
  setStatus('Manual Play tapped — attempting unlock with tone & HTMLAudio');
  const ok = await tryUnlockSequence();
  if (ok) {
    setStatus('Unlocked (gesture). Flushing queued plays...');
    hideManualButton();
    await flushPending();
  } else {
    setStatus('Unlock attempt failed. Please check site permissions and tap again.');
  }
});

// also listen for first tap anywhere on page to treat as unlock gesture
function firstGestureListener(e){
  // remove listener immediately
  document.removeEventListener('touchstart', firstGestureListener, {passive:true});
  document.removeEventListener('click', firstGestureListener);
  log('Detected first user gesture (page tap) — attempting unlock');
  // async unlock but don't block UI
  tryUnlockSequence().then(ok=>{
    if (ok) {
      setStatus('Unlocked (gesture). Flushing queued plays...');
      hideManualButton();
      flushPending().catch(e=>console.warn(e));
    } else {
      log('Gesture unlock failed; Manual Play button shown');
      showManualButton();
    }
  });
}

// enable/start
enableBtn.addEventListener('click', async ()=>{
  setStatus('Enable pressed — attempting audible unlock now...');
  // attach global gesture listeners (so a general tap counts)
  document.addEventListener('touchstart', firstGestureListener, {passive:true});
  document.addEventListener('click', firstGestureListener);
  const ok = await tryUnlockSequence();
  if (!ok) {
    setStatus('Audio locked — please tap Manual Play or tap anywhere on page once');
    showManualButton();
    // still start polling so we see logs; playback will wait for unlock
    if (!pollHandle) { pollHandle = setInterval(pollOnce, POLL_INTERVAL_MS); setStatus('Polling started (playback blocked until unlock)'); enableBtn.disabled=true; stopBtn.disabled=false; }
    return;
  }
  setStatus('Unlocked immediately. Starting poll & flushing queued plays.');
  if (!pollHandle) { pollHandle = setInterval(pollOnce, POLL_INTERVAL_MS); enableBtn.disabled=true; stopBtn.disabled=false; }
  await flushPending();
});

// stop
stopBtn.addEventListener('click', ()=>{ if (pollHandle) { clearInterval(pollHandle); pollHandle=null; setStatus('Polling stopped'); enableBtn.disabled=false; stopBtn.disabled=true; } });

// preview
previewBtn.addEventListener('click', ()=>{ createAudioCtxIfNeeded(); playFileByIndex(1); });

// init
(async function init(){
  firebaseUrlEl.value = firebaseUrlEl.value || FIREBASE_DEFAULT;
  const ok = await fetchRemoteTxt();
  if (!ok) txtInfo.textContent = '/T1.TXT not found on server — upload local file or add to site.';
  else txtInfo.textContent = `Loaded /T1.TXT (${lines.length} entries)`;
  setStatus('Ready. Click "Enable audio & Start polling" or tap the page to unlock audio when needed.');
})();
</script>
</body>
</html>
