<!doctype html>
<html lang="en"> 
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gangtay — Firebase -> T1.TXT -> play</title>
<style>
  body{font-family:system-ui,Arial;padding:18px;max-width:980px;margin:auto}
  h1{font-size:1.2rem}
  label{display:block;margin-top:10px;font-weight:600}
  input[type="text"], input[type="url"]{width:100%;padding:8px;margin-top:6px;box-sizing:border-box}
  button{padding:10px 14px;margin:8px 6px;font-size:1rem}
  .row{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
  #status{margin-top:10px;color:#333}
  #log{white-space:pre-wrap;font-family:monospace;margin-top:10px;background:#f6f6f6;padding:10px;border-radius:6px;max-height:340px;overflow:auto}
  .bigManual{background:#ff4757;color:white;border:none;padding:12px 18px;font-weight:700;border-radius:6px}
</style>
</head>
<body>
  <h1>Gangtay — Firebase → T1.TXT → play</h1>
  <p>Load T1.TXT (site root) or upload your T1.TXT locally, set audio base path, click <strong>Enable audio & Start polling</strong>. Send Firebase messages with <code>{"text":"xin chao","ts":...}</code> or <code>{"index":5,"ts":...}</code>.</p>

  <label>Load T1.TXT (site root /T1.TXT or upload local)</label>
  <div class="row">
    <input id="fileInput" type="file" accept=".txt">
    <button id="reloadTxt">Fetch /T1.TXT</button>
  </div>
  <div id="txtInfo" style="color:#666;margin-top:6px">Status: not loaded</div>

  <label>Audio base path</label>
  <input id="audioBase" type="text" value="/audio/" />

  <label>Firebase message URL</label>
  <input id="firebaseUrl" type="url" value="https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json" />

  <div class="row">
    <button id="enableBtn">Enable audio & Start polling</button>
    <button id="stopBtn" disabled>Stop polling</button>
    <button id="previewBtn">Preview 0001</button>
    <button id="manualPlay" class="bigManual" style="display:none">Manual Play (tap once)</button>
  </div>

  <div id="status">Status: idle</div>
  <div id="log"></div>

<script>
/* Firebase -> T1.TXT -> play
   - Poll interval: 1s (POLL_INTERVAL_MS)
   - T1.TXT lines: exact match (case-insensitive)
   - Filename format: 4-digit zero-padded (0001.mp3)
   - Includes mobile audio unlock + decodeAudioDataCompat
*/

const POLL_INTERVAL_MS = 1000;

const fileInput = document.getElementById('fileInput');
const reloadTxtBtn = document.getElementById('reloadTxt');
const txtInfo = document.getElementById('txtInfo');
const audioBaseEl = document.getElementById('audioBase');
const firebaseUrlEl = document.getElementById('firebaseUrl');
const enableBtn = document.getElementById('enableBtn');
const stopBtn = document.getElementById('stopBtn');
const previewBtn = document.getElementById('previewBtn');
const manualBtn = document.getElementById('manualPlay');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');

let lines = [];                    // T1.TXT lines array
let pollHandle = null;
let lastFirebaseTs = null;         // avoid replaying same ts
let audioCtx = null;
let masterGain = null;
let currentAudio = null;
let unlocked = false;

function now(){ return new Date().toLocaleTimeString(); }
function lg(m){ logEl.textContent = `[${now()}] ${m}\n` + logEl.textContent; }
function setStatus(s){ statusEl.textContent = 'Status: ' + s; lg(s); }
function pad4(n){ return String(n).padStart(4,'0'); }

// load remote /T1.TXT
async function fetchRemoteTxt(){
  setStatus('Fetching /T1.TXT ...');
  try {
    const r = await fetch('/T1.TXT', { cache: 'no-store' });
    if (!r.ok) { setStatus('/T1.TXT not found (HTTP ' + r.status + ')'); txtInfo.textContent = 'T1.TXT: not found'; return false; }
    const t = await r.text();
    parseTxt(t);
    txtInfo.textContent = `T1.TXT loaded (${lines.length} lines)`;
    setStatus('T1.TXT loaded');
    return true;
  } catch (e) {
    setStatus('Fetch /T1.TXT failed: ' + e.message);
    txtInfo.textContent = 'T1.TXT: fetch failed';
    return false;
  }
}
function parseTxt(txt){
  const raw = txt.split(/\r?\n/);
  lines = raw.map(l => l.trim()).filter(l => l.length > 0);
  lg('Parsed T1.TXT lines: ' + lines.length);
}
fileInput.addEventListener('change', async (ev)=>{
  const f = ev.target.files && ev.target.files[0];
  if (!f) return;
  setStatus('Reading local file ' + f.name);
  try {
    const txt = await f.text();
    parseTxt(txt);
    txtInfo.textContent = `Loaded local ${f.name} (${lines.length} lines)`;
    setStatus('Local T1.TXT loaded');
  } catch (e) {
    setStatus('Read file failed: ' + e.message);
  }
});
reloadTxtBtn.addEventListener('click', fetchRemoteTxt);

// audio context and gain
function createAudioCtx(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 1.0;
  masterGain.connect(audioCtx.destination);
  lg('AudioContext created');
}

// mobile unlock (tone)
async function unlockWithTone(){
  try {
    createAudioCtx();
    if (audioCtx.state === 'running') { unlocked = true; return true; }
    const nowt = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'sine'; osc.frequency.value = 880;
    g.gain.value = 0.0001;
    osc.connect(g); g.connect(masterGain);
    g.gain.setValueAtTime(0.0001, nowt);
    g.gain.linearRampToValueAtTime(0.05, nowt + 0.01);
    osc.start(nowt);
    g.gain.linearRampToValueAtTime(0.0001, nowt + 0.12);
    osc.stop(nowt + 0.13);
    try { await audioCtx.resume(); } catch(e){}
    await new Promise(r => setTimeout(r, 180));
    if (audioCtx.state === 'running') { unlocked = true; lg('Unlocked audio'); return true; }
    lg('unlock attempt ended, state=' + audioCtx.state);
    return false;
  } catch (e) {
    console.warn('unlock error', e);
    return false;
  }
}
async function tryUnlockSequence(){
  if (unlocked) return true;
  if (await unlockWithTone()) return true;
  // try simple HTMLAudio as fallback
  try {
    createAudioCtx();
    const a = new Audio();
    a.muted = true;
    try { await a.play(); } catch(e){}
    await new Promise(r=>setTimeout(r,50));
    if (audioCtx.state === 'running') { unlocked = true; lg('Unlocked by HTMLAudio fallback'); return true; }
  } catch(e) {}
  return false;
}
function showManual(){ manualBtn.style.display = 'inline-block'; manualBtn.focus(); }
function hideManual(){ manualBtn.style.display = 'none'; }

// decodeAudioData compatibility wrapper
function decodeAudioDataCompat(ab) {
  return new Promise((resolve, reject) => {
    try {
      const p = audioCtx.decodeAudioData(ab);
      if (p && typeof p.then === 'function') {
        p.then(resolve).catch(err => {
          try {
            audioCtx.decodeAudioData(ab, resolve, reject);
          } catch(cbErr) { reject(err || cbErr); }
        });
        return;
      }
    } catch (e) {}
    // callback form
    try {
      audioCtx.decodeAudioData(ab, resolve, reject);
    } catch(e) { reject(e); }
  });
}

// play file by 1-based index
async function playByIndex(idx) {
  if (idx <= 0) { lg('Invalid index ' + idx); return; }
  const fname = pad4(idx) + '.mp3';
  let base = audioBaseEl.value.trim() || '/audio/';
  if (!base.endsWith('/')) base += '/';
  const url = (base.startsWith('http') ? base : base) + fname + '?ts=' + Date.now();
  setStatus('Playing ' + fname);
  try {
    // prefer HTMLAudio element (simpler), connect to WebAudio if possible
    createAudioCtx();
    if (currentAudio) { try { currentAudio.pause(); currentAudio.src = ""; } catch(e){} currentAudio = null; }
    const a = new Audio(url);
    a.crossOrigin = 'anonymous';
    try {
      const src = audioCtx.createMediaElementSource(a);
      src.connect(masterGain);
      a._mediaSource = src;
    } catch(e) {
      // ignore if cannot connect
      a.volume = 1.0;
    }
    currentAudio = a;
    // resume audioCtx if suspended (older iOS)
    if (audioCtx.state === 'suspended') try { await audioCtx.resume(); } catch(e){}
    const ok = await a.play().then(()=>true).catch(()=>false);
    if (ok) { lg('Element play started: ' + fname); a.onended = ()=> setStatus('Finished ' + fname); return; }
    // if blocked or element failed, try fetch+decode fallback
    lg('Element play blocked or failed, trying fetch+decode fallback');
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) { lg('Fetch failed: ' + r.status); return; }
    const ab = await r.arrayBuffer();
    const buffer = await decodeAudioDataCompat(ab);
    const srcBuf = audioCtx.createBufferSource();
    srcBuf.buffer = buffer;
    srcBuf.connect(masterGain);
    if (audioCtx.state === 'suspended') try { await audioCtx.resume(); } catch(e){}
    srcBuf.start(0);
    lg('Played via buffer: ' + fname);
  } catch (e) {
    lg('Play error: ' + (e && e.message ? e.message : e));
    showManual();
  }
}

// find index of exact text in T1.TXT (case-insensitive)
function findIndexForText(text) {
  if (!text) return -1;
  const k = text.trim().toLowerCase();
  for (let i = 0; i < lines.length; i++) {
    if ((lines[i] || '').toLowerCase() === k) return i + 1; // 1-based
  }
  return -1;
}

// poll firebase and handle message
async function pollOnce() {
  const url = firebaseUrlEl.value.trim();
  if (!url) { lg('Firebase URL empty'); return; }
  try {
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) { lg('Firebase fetch failed: ' + r.status); return; }
    const j = await r.json();
    // ignore if same ts repeated
    const ts = j && (j.ts || j.timestamp || null);
    if (ts && ts === lastFirebaseTs) {
      // nothing new
      return;
    }
    lastFirebaseTs = ts;
    lg('Firebase message: ' + JSON.stringify(j));
    // if index present -> play
    if (typeof j.index === 'number') {
      await playByIndex(j.index);
      return;
    }
    // try text
    const t = (typeof j.text === 'string') ? j.text : (typeof j.message === 'string' ? j.message : null);
    if (t) {
      const idx = findIndexForText(t);
      if (idx > 0) {
        await playByIndex(idx);
      } else {
        lg('Text not found in T1.TXT: "' + t + '"');
        showManual();
      }
    }
  } catch (e) {
    lg('Poll error: ' + (e && e.message ? e.message : e));
  }
}

// UI & event wiring
enableBtn.addEventListener('click', async () => {
  setStatus('Attempting unlock and starting poll');
  document.addEventListener('touchstart', () => tryUnlockSequence(), {once:true, passive:true});
  document.addEventListener('click', () => tryUnlockSequence(), {once:true});
  const ok = await tryUnlockSequence();
  if (!ok) { setStatus('Audio locked — tap Manual Play'); showManual(); }
  if (!pollHandle) {
    pollHandle = setInterval(pollOnce, POLL_INTERVAL_MS);
    setStatus('Polling started');
    enableBtn.disabled = true;
    stopBtn.disabled = false;
  }
});

stopBtn.addEventListener('click', () => {
  if (pollHandle) { clearInterval(pollHandle); pollHandle = null; setStatus('Polling stopped'); enableBtn.disabled = false; stopBtn.disabled = true; }
});

manualBtn.addEventListener('click', async () => {
  setStatus('Manual Play tapped: trying unlock');
  const ok = await tryUnlockSequence();
  if (ok) { setStatus('Unlocked (manual)'); hideManual(); }
  else setStatus('Manual unlock failed — try tapping the page or check settings');
});

previewBtn.addEventListener('click', async () => {
  createAudioCtx();
  await playByIndex(1);
});

// initial attempt to load T1.TXT from site root
(async function init(){
  firebaseUrlEl.value = firebaseUrlEl.value || '';
  const ok = await fetchRemoteTxt();
  if (!ok) txtInfo.textContent = 'T1.TXT not found on server — upload or use file input';
  setStatus('Ready');
})();

</script>
</body>
</html>
