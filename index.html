<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gangtay — Firebase play (numeric-text fix + mobile fallback)</title>
<style>
  body{font-family:system-ui,Arial;padding:14px;max-width:980px;margin:auto}
  h1{margin:0 0 8px 0}
  label{display:block;margin-top:8px;font-weight:600}
  input, button {padding:10px;margin:6px 0;width:100%;box-sizing:border-box}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .half{flex:1 1 48%}
  #log{font-family:monospace;background:#111;color:#e6e6e6;padding:12px;border-radius:8px;min-height:220px;white-space:pre-wrap;overflow:auto}
  #manualHolder{margin-top:8px}
  .ok{color:limegreen}
  .err{color:crimson}
</style>
</head>
<body>
  <h1>Gangtay — Firebase play (mobile-friendly)</h1>
  <p style="color:#666;margin:0 0 12px 0">This page treats numeric `text` payloads as indexes (e.g. "1" → 0001.mp3). If autoplay is blocked it will show a manual audio control to tap play.</p>

  <label>Audio base (folder or absolute URL)</label>
  <input id="audioBase" value="/audio/" />

  <label>Firebase message.json URL</label>
  <input id="firebaseUrl" value="https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json" />

  <div class="row">
    <button id="fetchOne" class="half">Fetch Firebase & Play (one-shot)</button>
    <button id="startPoll" class="half">Start polling</button>
  </div>
  <div class="row">
    <button id="stopPoll" class="half">Stop polling</button>
    <input id="pollMs" class="half" type="number" value="800" min="100" />
  </div>

  <div class="row">
    <button id="unlockBtn" class="half">Unlock audio (tap once)</button>
    <button id="clearLog" class="half">Clear log</button>
  </div>

  <div id="manualHolder"></div>

  <div id="status" style="margin-top:10px">Status: ready</div>
  <pre id="log">Script not yet started...</pre>

<script>
/* Updated page:
 - treat numeric payload.text as index (e.g. "1" => 0001.mp3)
 - attempt to unlock before play; if locked, store pendingPayload and show manual <audio controls>
 - play sequence: element -> blob->element -> decode->WebAudio
 - robust logs for debugging
*/

const audioBaseEl = document.getElementById('audioBase');
const firebaseUrlEl = document.getElementById('firebaseUrl');
const fetchOneBtn = document.getElementById('fetchOne');
const startPollBtn = document.getElementById('startPoll');
const stopPollBtn = document.getElementById('stopPoll');
const pollMsEl = document.getElementById('pollMs');
const unlockBtn = document.getElementById('unlockBtn');
const clearLogBtn = document.getElementById('clearLog');
const logEl = document.getElementById('log');
const statusEl = document.getElementById('status');
const manualHolder = document.getElementById('manualHolder');

let audioCtx = null;
let masterGain = null;
let unlocked = false;
let pollId = null;
let inFlight = false;
let pendingPayload = null; // single slot when locked
let lastPayloadStr = null; // dedupe from poll

function now(){ return new Date().toLocaleTimeString(); }
function log(msg, cls) {
  const line = `[${now()}] ${msg}`;
  logEl.textContent = line + '\n' + logEl.textContent;
  if (cls === 'err') statusEl.style.color = 'crimson';
  else if (cls === 'ok') statusEl.style.color = 'limegreen';
  else statusEl.style.color = '';
  console.log(line);
}
function setStatus(s) { statusEl.textContent = 'Status: ' + s; log(s); }

function pad4(n){ return String(n).padStart(4,'0'); }
function fileUrlForIndex(i) {
  const base = (audioBaseEl.value || '/audio/').trim();
  const fname = pad4(i) + '.mp3';
  if (/^https?:\/\//i.test(base)) return (base.endsWith('/') ? base + fname : base + '/' + fname) + '?ts=' + Date.now();
  if (base.startsWith('/')) return location.origin + (base.endsWith('/') ? base + fname : base + '/' + fname) + '?ts=' + Date.now();
  return location.origin + '/' + (base.endsWith('/') ? base + fname : base + '/' + fname) + '?ts=' + Date.now();
}

/* --- Audio helpers --- */
function ensureAudioCtx() {
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 1.0;
    masterGain.connect(audioCtx.destination);
    log('AudioContext created', 'ok');
  } catch(e) {
    log('AudioContext creation failed: ' + e, 'err');
  }
}

async function tryUnlockSequence() {
  if (unlocked) return true;
  ensureAudioCtx();
  try {
    if (audioCtx.state === 'running') { unlocked = true; return true; }
    // Try tiny muted audio element
    const a = new Audio();
    a.muted = true;
    try { await a.play(); } catch(e){}
    if (audioCtx.state === 'running') { unlocked = true; return true; }
    // fallback: short tone
    const nowt = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine'; o.frequency.value = 880;
    g.gain.value = 0.0001;
    o.connect(g); g.connect(masterGain);
    g.gain.setValueAtTime(0.0001, nowt);
    g.gain.linearRampToValueAtTime(0.06, nowt + 0.01);
    o.start(nowt);
    g.gain.linearRampToValueAtTime(0.0001, nowt + 0.12);
    o.stop(nowt + 0.13);
    try { await audioCtx.resume(); } catch(e){}
    unlocked = (audioCtx.state === 'running');
    log('Unlock attempt finished, unlocked=' + unlocked);
    return unlocked;
  } catch(e) {
    log('Unlock sequence error: ' + e, 'err');
    return false;
  }
}

/* --- Play attempt chain --- 
   returns true on success, false on failure.
*/
async function playSequenceForIndex(i) {
  const url = fileUrlForIndex(i);
  log('playSequence: starting for index ' + i + ' -> ' + url);

  // 1) try direct element
  try {
    const a = new Audio(url);
    a.playsInline = true;
    a.crossOrigin = 'anonymous';
    a.preload = 'auto';
    a.onended = ()=> log('element: ended', 'ok');
    a.onerror = ()=> log('element: error', 'err');
    try {
      await a.play();
      log('element: play started', 'ok');
      return true;
    } catch(e) {
      log('element: play rejected: ' + e, 'err');
    }
  } catch(e) {
    log('element: creation error: ' + e, 'err');
  }

  // 2) try fetch->blob->objectURL -> element
  try {
    const r = await fetch(url, { cache: 'no-store' });
    log('fetch status ' + r.status);
    if (!r.ok) { log('fetch failed ' + r.status, 'err'); }
    else {
      const blob = await r.blob();
      log('blob size ' + blob.size);
      const obj = URL.createObjectURL(blob);
      const a2 = new Audio(obj);
      a2.playsInline = true;
      a2.crossOrigin = 'anonymous';
      a2.onended = ()=> { log('blob-element: ended', 'ok'); URL.revokeObjectURL(obj); };
      a2.onerror = ()=> { log('blob-element: error', 'err'); URL.revokeObjectURL(obj); };
      try {
        await a2.play();
        log('blob-element: play started', 'ok');
        return true;
      } catch(e) {
        log('blob-element: play rejected: ' + e, 'err');
        URL.revokeObjectURL(obj);
      }
    }
  } catch(e) {
    log('blob fetch/play error: ' + e, 'err');
  }

  // 3) try fetch->arrayBuffer->decodeAudioData -> WebAudio
  try {
    ensureAudioCtx();
    const r2 = await fetch(url, { cache: 'no-store' });
    if (!r2.ok) { log('fetch (decode) failed ' + r2.status, 'err'); }
    else {
      const ab = await r2.arrayBuffer();
      const buf = await new Promise((resolve, reject) => {
        try {
          const p = audioCtx.decodeAudioData(ab);
          if (p && typeof p.then === 'function') { p.then(resolve).catch(err => { try { audioCtx.decodeAudioData(ab, resolve, reject); } catch(e){ reject(err||e); } }); return; }
        } catch(e){}
        try { audioCtx.decodeAudioData(ab, resolve, reject); } catch(e){ reject(e); }
      });
      const s = audioCtx.createBufferSource();
      s.buffer = buf;
      s.connect(masterGain);
      s.onended = ()=> log('webAudio: ended', 'ok');
      s.start(0);
      log('webAudio: started (duration ' + (buf.duration||0).toFixed(2) + 's)', 'ok');
      return true;
    }
  } catch(e) {
    log('webAudio decode/play error: ' + e, 'err');
  }

  // failed all methods
  log('All play attempts failed for index ' + i, 'err');
  return false;
}

/* --- manual control helper (visible fallback) --- */
function showManualControlForIndex(i) {
  manualHolder.innerHTML = ''; // remove previous
  const url = fileUrlForIndex(i);
  const p = document.createElement('div');
  p.innerHTML = `<label>Manual control (tap Play if autoplay blocked)</label>`;
  const a = document.createElement('audio');
  a.controls = true;
  a.playsInline = true;
  a.crossOrigin = 'anonymous';
  a.src = url;
  a.style.width = '100%';
  p.appendChild(a);
  manualHolder.appendChild(p);
  log('Manual control created for index ' + i + ' — tap Play on device', 'ok');
  return a;
}

/* --- payload handling:
   If payload.text looks numeric -> treat as index.
   If unlocked -> try to play immediately.
   If not unlocked -> store pendingPayload and show manual control.
*/
async function handlePayload(payload) {
  if (!payload) return;
  log('Received payload: ' + JSON.stringify(payload));
  // determine index
  let idx = null;
  if (typeof payload.index === 'number') idx = payload.index;
  else if (typeof payload.text === 'string') {
    const trimmed = payload.text.trim();
    // numeric string? treat as index
    if (/^\d+$/.test(trimmed)) idx = parseInt(trimmed, 10);
    // else: if T1.TXT mapping desired, that code could be placed here (not implemented)
  }
  if (!idx) {
    log('Payload does not contain index and text not numeric; cannot map to file', 'err');
    return;
  }

  // try to unlock first (best-effort)
  const okUnlock = await tryUnlockSequence();
  if (okUnlock) {
    log('Unlocked — attempting play for index ' + idx);
    const ok = await playSequenceForIndex(idx);
    if (!ok) {
      // if play fails but unlocked, provide manual control
      showManualControlForIndex(idx);
    }
    return;
  }

  // not unlocked: store pending and show manual control so user can tap
  pendingPayload = payload;
  showManualControlForIndex(idx);
  log('Playback blocked by autoplay — created manual control for index ' + idx, 'err');
}

/* --- Firebase fetch & poll --- */
async function fetchFirebaseOnce() {
  const fb = (firebaseUrlEl.value || '').trim();
  if (!fb) { log('Firebase URL not set', 'err'); return; }
  setStatus('Fetching Firebase...');
  try {
    const r = await fetch(fb, { cache: 'no-store' });
    if (!r.ok) { log('Firebase fetch failed: ' + r.status, 'err'); setStatus('Firebase fetch failed'); return; }
    const j = await r.json();
    setStatus('Fetched');
    // dedupe on exact JSON string
    const s = JSON.stringify(j);
    if (s === lastPayloadStr) { log('No change in payload (deduped)'); return; }
    lastPayloadStr = s;
    // handle text or index
    if (typeof j.text === 'string' || typeof j.index === 'number') {
      // prefer index field if present, else treat numeric text as index
      if (typeof j.index === 'number' || /^\d+$/.test(String(j.text || ''))) {
        log('Firebase has index/text numeric; handling...');
        await handlePayload(j);
      } else {
        log('Firebase has text but not numeric; text mapping not implemented here', 'err');
      }
    } else {
      log('Firebase payload shape unknown: ' + s, 'err');
    }
  } catch(e) {
    log('Firebase fetch exception: ' + e, 'err');
    setStatus('Firebase fetch error');
  }
}

fetchOneBtn.addEventListener('click', fetchFirebaseOnce);

startPollBtn.addEventListener('click', ()=>{
  if (pollId) { log('Poller already running'); return; }
  const ms = Math.max(100, Number(pollMsEl.value) || 800);
  pollId = setInterval(fetchFirebaseOnce, ms);
  setStatus('Polling every ' + ms + ' ms');
  log('Poller started', 'ok');
});

stopPollBtn.addEventListener('click', ()=>{
  if (!pollId) { log('Poller not running'); return; }
  clearInterval(pollId); pollId = null;
  setStatus('Polling stopped');
  log('Poller stopped');
});

// Unlock button
unlockBtn.addEventListener('click', async ()=>{
  setStatus('Attempting unlock...');
  const ok = await tryUnlockSequence();
  if (ok) { unlocked = true; setStatus('Unlocked'); log('Unlocked by gesture', 'ok'); }
  else { setStatus('Unlock attempt finished'); log('Unlock failed or blocked'); }
});

// If the user presses a visible manual control and it plays, we should clear pendingPayload
manualHolder.addEventListener('click', (ev) => {
  // If user tapped the manual audio control and it played, consider that an unlock gesture
  // We can't detect play reliably here, but treat click as user intent: call tryUnlockSequence
  tryUnlockSequence().then(ok => {
    if (ok) { unlocked = true; log('Assumed unlocked after manual control interaction', 'ok'); }
  });
});

// clear log
clearLogBtn.addEventListener('click', ()=> logEl.textContent = '');

// initial status
log('Script loaded. Poller is idle. Use "Fetch Firebase & Play" or "Start polling".');
setStatus('Ready');

</script>
</body>
</html>
