<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Sensor Monitor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        h1 {
            font-size: 2rem;
            margin-bottom: 5px;
        }
        
        .dashboard {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }
        
        .card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            border: 1px solid #eaeaea;
        }
        
        .card h3 {
            color: #4A00E0;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .sensor-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .sensor-item {
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid;
        }
        
        .sensor-item.mpu {
            border-left-color: #2196F3;
        }
        
        .sensor-item.flex {
            border-left-color: #4CAF50;
        }
        
        .sensor-item.shake {
            border-left-color: #FF9800;
        }
        
        .sensor-item.direction {
            border-left-color: #9C27B0;
        }
        
        .sensor-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
            margin: 5px 0;
        }
        
        .sensor-label {
            font-size: 0.8rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .flex-box {
            display: inline-block;
            width: 40px;
            height: 40px;
            line-height: 40px;
            text-align: center;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 2px;
            font-weight: bold;
            border: 2px solid transparent;
        }
        
        .flex-box.active-0 {
            background: #4CAF50;
            color: white;
        }
        
        .flex-box.active-1 {
            background: #FF9800;
            color: white;
        }
        
        .flex-box.active-2 {
            background: #F44336;
            color: white;
        }
        
        .flex-box.active-3 {
            background: #2196F3;
            color: white;
        }
        
        .flex-box.active-4 {
            background: #9C27B0;
            color: white;
        }
        
        .status-bar {
            background: #f8f9fa;
            padding: 15px;
            border-top: 1px solid #eaeaea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        
        .indicator.online {
            background: #4CAF50;
            animation: blink 1s infinite;
        }
        
        .indicator.offline {
            background: #F44336;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .shake-active {
            color: #FF5722 !important;
            font-weight: bold !important;
            animation: shake 0.5s infinite;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }
        
        .connection-status {
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
        }
        
        .connected {
            background: #E8F5E9;
            color: #2E7D32;
            border: 1px solid #C8E6C9;
        }
        
        .disconnected {
            background: #FFEBEE;
            color: #C62828;
            border: 1px solid #FFCDD2;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .raw-data {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 0.9rem;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .bonus-row {
            margin-top: 15px;
            padding: 15px;
            background: #E3F2FD;
            border-radius: 8px;
            border: 1px solid #bbdefb;
        }
        
        .bonus-row h4 {
            color: #1976D2;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ESP32 Sensor Monitor</h1>
            <div>Real-time data from Firebase</div>
        </header>
        
        <div class="dashboard">
            <!-- Main Sensors Card -->
            <div class="card">
                <h3>Main Sensors</h3>
                <div class="sensor-grid">
                    <div class="sensor-item mpu">
                        <div class="sensor-label">MPU6050 ORIENTATION</div>
                        <div class="sensor-value" id="mpuOrientation">---</div>
                        <div class="sensor-label">State Code</div>
                        <div class="sensor-value" id="mpuState">-1</div>
                    </div>
                    
                    <div class="sensor-item shake">
                        <div class="sensor-label">SHAKE STATUS</div>
                        <div class="sensor-value" id="shakeStatus">---</div>
                        <div class="sensor-label">Is Shaking</div>
                        <div class="sensor-value" id="isShaking">NO</div>
                    </div>
                    
                    <div class="sensor-item flex">
                        <div class="sensor-label">FLEX SENSORS</div>
                        <div>
                            <div>
                                <span class="flex-box" id="flex0-box">0</span>
                                <span class="flex-box" id="flex1-box">0</span>
                                <span class="flex-box" id="flex2-box">0</span>
                                <span class="flex-box" id="flex3-box">0</span>
                            </div>
                            <div class="sensor-label">Raw Values</div>
                            <div id="rawFlexValues">---</div>
                        </div>
                    </div>
                    
                    <div class="sensor-item direction">
                        <div class="sensor-label">SHAKE DIRECTION</div>
                        <div class="sensor-value" id="shakeDirection">---</div>
                        <div class="sensor-label">After Shake</div>
                        <div id="afterShakeStatus">---</div>
                    </div>
                </div>
                
                <div class="connection-status" id="connectionStatus">
                    <span class="indicator offline"></span>
                    Disconnected from Firebase
                </div>
            </div>
            
            <!-- Bonus Rows Card (Based on Direction) -->
            <div class="card">
                <h3>Bonus Rows</h3>
                <div class="bonus-row" id="bonusRow1">
                    <h4>Bonus Row 1</h4>
                    <div>Direction: <span id="bonusDir1">---</span></div>
                    <div>Function: <span id="bonusFunc1">---</span></div>
                    <div>Status: <span id="bonusStatus1">---</span></div>
                </div>
                
                <div class="bonus-row" id="bonusRow2">
                    <h4>Bonus Row 2</h4>
                    <div>Direction: <span id="bonusDir2">---</span></div>
                    <div>Function: <span id="bonusFunc2">---</span></div>
                    <div>Status: <span id="bonusStatus2">---</span></div>
                </div>
                
                <div class="controls">
                    <button onclick="simulateData()">Simulate Data</button>
                    <button onclick="toggleAutoRefresh()" id="autoRefreshBtn">Auto Refresh: ON</button>
                </div>
            </div>
            
            <!-- Raw Data Card -->
            <div class="card">
                <h3>Raw Data & Log</h3>
                <div class="raw-data" id="rawData">
                    Waiting for data...
                </div>
                <div class="controls">
                    <button onclick="clearLog()">Clear Log</button>
                    <button onclick="copyData()">Copy JSON</button>
                </div>
            </div>
            
            <!-- Word Construction Card (From ESP32 Logic) -->
            <div class="card">
                <h3>Word Construction</h3>
                <div style="margin-bottom: 15px;">
                    <div class="sensor-label">CURRENT WORD</div>
                    <div class="sensor-value" id="currentWord" style="font-size: 1.5rem; min-height: 40px;">---</div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <div class="sensor-label">SLOT 1</div>
                    <div id="slot1" style="font-size: 1.2rem;">---</div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <div class="sensor-label">SLOT 2</div>
                    <div id="slot2" style="font-size: 1.2rem;">---</div>
                </div>
                
                <div class="controls">
                    <button onclick="resetWord()">Reset Word</button>
                    <button onclick="simulateWord()">Simulate Word</button>
                </div>
            </div>
        </div>
        
        <div class="status-bar">
            <div>
                <span id="statusText">Fetching data...</span>
            </div>
            <div>
                <span id="lastUpdate">Last update: --:--:--</span>
            </div>
        </div>
    </div>

    <script>
        // Firebase configuration
        const FIREBASE_URL = 'https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/sensorData.json';
        
        // State variables
        let autoRefresh = true;
        let lastData = null;
        let logEntries = [];
        let lastUpdateTime = null;
        
        // Word construction state (from ESP32 code)
        let wordConstructionState = {
            slot1: '',
            slot2: '',
            currentWord: '',
            lastFlexStates: [-1, -1, -1, -1],
            stableCount: 0,
            holdStartMs: 0,
            holdFired: false
        };
        
        // Tables from ESP32 code (simplified for display)
        const tableA = [
            ["IAY","IC","ICH","IE","IEC","IEM","IEN","IENG","IEO"],
            ["IEP","IET","IEU","IM","IN","ING","INH","IO","IOI"],
            ["ENG","ENH","EO","EP","ET","EU","I","IA","IAC"],
            ["IAI","IAM","IAN","IANG","IANH","IAO","IAP","IAT","IAU"],
            ["AP","AT","AU","AY","E","EC","ECH","EM","EN"],
            ["A","AC","ACH","AI","AM","AN","ANG","ANH","AO"],
            ["IUN","IUONG","IUP","O","OA","OAC","OACH","OAI","OAM"],
            ["ION","IONG","IOT","IP","IT","IU","IUA","IUC","IUI"]
        ];
        
        const tableB = [
            ["UE","UECH","UEN","UENH","UEO","UET","UI","UM","UN"],
            ["UNG","UO","UOC","UOI","UOM","UON","UONG","UOP","OUT"],
            ["ONG","OOC","OONG","OP","OT","U","UA","UAC","UACH"],
            ["UAI","UAM","UAN","UANG","UANH","UAO","UAT","UAY","UC"],
            ["OAY","OC","OE","OEN","OEO","OET","OI","OM","ON"],
            ["COMMIT","_","nullptr","nullptr","OAN","OANG","OANH","OAP","OAT"],
            ["UYNH","UYP","UYT","UYU","Y","YEM","YEN","YET","YEU"],
            ["UOU","UP","UT","UU","UY","UYA","UYCH","UYEN","UYET"]
        ];
        
        // Format time
        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString([], { 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit' 
            });
        }
        
        // Fetch data from Firebase
        async function fetchData() {
            try {
                const response = await fetch(FIREBASE_URL);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const data = await response.json();
                lastUpdateTime = Date.now();
                
                // Update UI with new data
                updateDisplay(data);
                
                // Update connection status
                updateConnectionStatus(true);
                
                return data;
            } catch (error) {
                console.error('Error fetching data:', error);
                updateConnectionStatus(false);
                return null;
            }
        }
        
        // Update display with sensor data
        function updateDisplay(data) {
            if (!data) return;
            
            // Update MPU data
            document.getElementById('mpuOrientation').textContent = data.o || data.mpuOrientation || '---';
            document.getElementById('mpuState').textContent = data.m || data.mpuState || '-1';
            
            // Update shake data
            document.getElementById('shakeStatus').textContent = data.sf || data.shakeState || '---';
            document.getElementById('isShaking').textContent = data.isShaking ? 'YES' : 'NO';
            
            // Update flex sensors
            const flexValues = data.f || [data.f0, data.f1, data.f2, data.f3];
            const rawFlex = data.rawFlex || [0, 0, 0, 0];
            
            // Update flex boxes
            for (let i = 0; i < 4; i++) {
                const box = document.getElementById(`flex${i}-box`);
                if (box) {
                    const value = flexValues[i] || 0;
                    box.textContent = value;
                    
                    // Remove all classes
                    box.className = 'flex-box';
                    
                    // Add appropriate class
                    if (value === 0) box.classList.add('active-0');
                    else if (value === 1) box.classList.add('active-1');
                    else if (value === 2) box.classList.add('active-2');
                    else if (value === 3) box.classList.add('active-3');
                    else box.classList.add('active-4');
                }
            }
            
            // Update raw flex values
            document.getElementById('rawFlexValues').textContent = 
                `f0: ${flexValues[0] || 0}, f1: ${flexValues[1] || 0}, f2: ${flexValues[2] || 0}, f3: ${flexValues[3] || 0}`;
            
            // Update shake direction
            const direction = data.d || data.shakeState || 'None';
            document.getElementById('shakeDirection').textContent = direction;
            document.getElementById('afterShakeStatus').textContent = 
                direction !== 'None' ? 'Active' : 'Inactive';
            
            // Apply shake animation if shaking
            const shakeElement = document.getElementById('shakeStatus');
            if (data.isShaking || data.sh === true) {
                shakeElement.classList.add('shake-active');
            } else {
                shakeElement.classList.remove('shake-active');
            }
            
            // Update bonus rows based on direction
            updateBonusRows(direction, data);
            
            // Update raw data display
            updateRawData(data);
            
            // Update last update time
            document.getElementById('lastUpdate').textContent = 
                `Last update: ${formatTime(lastUpdateTime)}`;
            
            // Update word construction
            updateWordConstruction(data, flexValues);
            
            // Store last data
            lastData = data;
        }
        
        // Update bonus rows based on direction
        function updateBonusRows(direction, data) {
            const bonusRow1 = document.getElementById('bonusRow1');
            const bonusRow2 = document.getElementById('bonusRow2');
            
            // Reset bonus rows
            bonusRow1.style.display = 'block';
            bonusRow2.style.display = 'block';
            
            // Map directions to functions
            const directionMap = {
                'Left': { func: 'Navigate Back', status: 'Previous Page' },
                'Right': { func: 'Navigate Forward', status: 'Next Page' },
                'Up': { func: 'Scroll Up', status: 'Content Up' },
                'Down': { func: 'Scroll Down', status: 'Content Down' },
                'Forward': { func: 'Confirm', status: 'Action OK' },
                'Backward': { func: 'Cancel', status: 'Action Cancel' },
                'Shake Left': { func: 'Undo', status: 'Last Action' },
                'Shake Right': { func: 'Redo', status: 'Next Action' },
                'None': { func: 'Idle', status: 'Waiting' }
            };
            
            const dirInfo = directionMap[direction] || { func: 'Unknown', status: 'N/A' };
            
            // Update bonus row 1
            document.getElementById('bonusDir1').textContent = direction;
            document.getElementById('bonusFunc1').textContent = dirInfo.func;
            document.getElementById('bonusStatus1').textContent = dirInfo.status;
            
            // Bonus row 2 - Additional information
            document.getElementById('bonusDir2').textContent = data.isShaking ? 'SHAKING' : 'STABLE';
            document.getElementById('bonusFunc2').textContent = `BT: ${data.btConnected ? 'Connected' : 'Disconnected'}`;
            document.getElementById('bonusStatus2').textContent = `Heap: ${data.freeHeap || 0} bytes`;
            
            // Color code based on direction
            if (direction.includes('Shake')) {
                bonusRow1.style.background = '#FFF3CD';
                bonusRow1.style.borderColor = '#FFC107';
            } else if (direction !== 'None') {
                bonusRow1.style.background = '#D4EDDA';
                bonusRow1.style.borderColor = '#28A745';
            } else {
                bonusRow1.style.background = '#E3F2FD';
                bonusRow1.style.borderColor = '#bbdefb';
            }
        }
        
        // Update raw data display
        function updateRawData(data) {
            const rawDataElement = document.getElementById('rawData');
            const timestamp = new Date().toLocaleTimeString();
            
            // Create a formatted log entry
            const logEntry = `[${timestamp}] 
MPU: ${data.o || '---'} (State: ${data.m || -1})
Flex: [${data.f ? data.f.join(',') : `${data.f0},${data.f1},${data.f2},${data.f3}`}]
Shake: ${data.sf || 'NO'} | Direction: ${data.d || 'None'}
BT: ${data.btConnected ? 'Connected' : 'Disconnected'} | Heap: ${data.freeHeap || 0}
------------------------------`;
            
            // Add to log
            logEntries.unshift(logEntry);
            if (logEntries.length > 10) {
                logEntries.pop();
            }
            
            // Update display
            rawDataElement.textContent = logEntries.join('\n');
        }
        
        // Update word construction based on sensor data
        function updateWordConstruction(data, flexValues) {
            const mpuState = data.m || 0;
            
            // Simulate word construction logic from ESP32
            // This is a simplified version for display purposes
            
            // Check if flex states have changed
            const flexChanged = flexValues.some((val, idx) => 
                val !== wordConstructionState.lastFlexStates[idx]);
            
            if (flexChanged) {
                wordConstructionState.lastFlexStates = [...flexValues];
                wordConstructionState.stableCount = 0;
                wordConstructionState.holdStartMs = Date.now();
                wordConstructionState.holdFired = false;
            } else {
                wordConstructionState.stableCount++;
            }
            
            // If stable for "3 counts" (simulating debounce)
            if (wordConstructionState.stableCount >= 3) {
                const held = Date.now() - wordConstructionState.holdStartMs;
                
                // Simulate the table lookup logic
                if (!wordConstructionState.holdFired && held >= 800) {
                    // Determine which table to use based on flex[3]
                    const useTableC = flexValues[3] === 2;
                    
                    let mapping = '';
                    if (useTableC) {
                        // Simplified table C logic
                        mapping = `C[${mpuState}][${flexValues[0]}][${flexValues[1]}]`;
                    } else {
                        // Use table A or B based on flex[3]
                        const table = flexValues[3] === 1 ? tableB : tableA;
                        const flatIndex = flexValues[1] * 3 + flexValues[2];
                        
                        if (table[mpuState] && table[mpuState][flatIndex]) {
                            mapping = table[mpuState][flatIndex];
                        } else {
                            mapping = '---';
                        }
                    }
                    
                    // Update slots based on flex[3]
                    if (flexValues[3] === 2) {
                        wordConstructionState.slot1 = `${mapping}_${mpuState}`;
                    } else {
                        const mode = flexValues[0] === 0 ? 's' : 
                                    flexValues[0] === 1 ? 'b' : 'p';
                        wordConstructionState.slot2 = `${mapping}_${mode}`;
                    }
                    
                    // Update current word
                    wordConstructionState.currentWord = 
                        (wordConstructionState.slot1 + wordConstructionState.slot2).toLowerCase();
                    
                    wordConstructionState.holdFired = true;
                }
            }
            
            // Update display
            document.getElementById('slot1').textContent = wordConstructionState.slot1 || '---';
            document.getElementById('slot2').textContent = wordConstructionState.slot2 || '---';
            document.getElementById('currentWord').textContent = 
                wordConstructionState.currentWord || '---';
        }
        
        // Update connection status
        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connectionStatus');
            const indicator = statusElement.querySelector('.indicator');
            const text = connected ? 'Connected to Firebase' : 'Disconnected from Firebase';
            
            statusElement.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
            indicator.className = `indicator ${connected ? 'online' : 'offline'}`;
            statusElement.innerHTML = `<span class="indicator ${connected ? 'online' : 'offline'}"></span>${text}`;
            
            document.getElementById('statusText').textContent = 
                connected ? 'Connected - Receiving data' : 'Disconnected - Check connection';
        }
        
        // Toggle auto-refresh
        function toggleAutoRefresh() {
            autoRefresh = !autoRefresh;
            document.getElementById('autoRefreshBtn').textContent = 
                `Auto Refresh: ${autoRefresh ? 'ON' : 'OFF'}`;
            
            if (autoRefresh) {
                document.getElementById('statusText').textContent = 'Auto-refresh enabled';
            } else {
                document.getElementById('statusText').textContent = 'Auto-refresh disabled';
            }
        }
        
        // Clear log
        function clearLog() {
            logEntries = [];
            document.getElementById('rawData').textContent = 'Log cleared...';
        }
        
        // Copy data to clipboard
        function copyData() {
            if (lastData) {
                const jsonStr = JSON.stringify(lastData, null, 2);
                navigator.clipboard.writeText(jsonStr)
                    .then(() => {
                        document.getElementById('statusText').textContent = 'Data copied to clipboard!';
                        setTimeout(() => {
                            if (autoRefresh) {
                                document.getElementById('statusText').textContent = 'Connected - Receiving data';
                            }
                        }, 2000);
                    })
                    .catch(err => {
                        console.error('Failed to copy:', err);
                        document.getElementById('statusText').textContent = 'Failed to copy data';
                    });
            }
        }
        
        // Reset word construction
        function resetWord() {
            wordConstructionState = {
                slot1: '',
                slot2: '',
                currentWord: '',
                lastFlexStates: [-1, -1, -1, -1],
                stableCount: 0,
                holdStartMs: 0,
                holdFired: false
            };
            
            document.getElementById('slot1').textContent = '---';
            document.getElementById('slot2').textContent = '---';
            document.getElementById('currentWord').textContent = '---';
            
            document.getElementById('statusText').textContent = 'Word construction reset';
        }
        
        // Simulate word construction
        function simulateWord() {
            // Simulate random flex values
            const randomFlex = [
                Math.floor(Math.random() * 3),
                Math.floor(Math.random() * 3),
                Math.floor(Math.random() * 3),
                Math.floor(Math.random() * 3)
            ];
            
            // Create simulated data
            const simulatedData = {
                m: Math.floor(Math.random() * 8),
                f: randomFlex,
                o: ['Up', 'Down', 'Left', 'Right', 'Forward', 'Backward'][Math.floor(Math.random() * 6)],
                sf: Math.random() > 0.7 ? 'YES' : 'NO',
                d: Math.random() > 0.8 ? 'Shake Left' : (Math.random() > 0.6 ? 'Shake Right' : 'None'),
                isShaking: Math.random() > 0.7
            };
            
            // Update display with simulated data
            updateWordConstruction(simulatedData, randomFlex);
            
            document.getElementById('statusText').textContent = 'Simulated word construction';
        }
        
        // Simulate data for testing
        function simulateData() {
            const simulatedData = {
                btConnected: true,
                btLastSeen: Math.floor(Math.random() * 10000),
                c: Math.floor(Math.random() * 200),
                d: ['None', 'Shake Left', 'Shake Right', 'Left', 'Right'][Math.floor(Math.random() * 5)],
                f: [
                    Math.floor(Math.random() * 5),
                    Math.floor(Math.random() * 5),
                    Math.floor(Math.random() * 5),
                    Math.floor(Math.random() * 5)
                ],
                f0: Math.floor(Math.random() * 500),
                f1: Math.floor(Math.random() * 500),
                f2: Math.floor(Math.random() * 500),
                f3: Math.floor(Math.random() * 500),
                f4: Math.floor(Math.random() * 10),
                freeHeap: 200000 + Math.floor(Math.random() * 50000),
                interval: 50,
                isShaking: Math.random() > 0.7,
                isoTime: new Date().toISOString(),
                m: Math.floor(Math.random() * 8),
                messageId: Math.floor(Math.random() * 100),
                mo: ['Up', 'Down', 'Left', 'Right', 'Forward', 'Backward'][Math.floor(Math.random() * 6)],
                mpuOrientation: ['Up', 'Down', 'Left', 'Right', 'Forward', 'Backward'][Math.floor(Math.random() * 6)],
                mpuState: Math.floor(Math.random() * 8),
                ms: 1,
                o: ['Up', 'Down', 'Left', 'Right', 'Forward', 'Backward'][Math.floor(Math.random() * 6)],
                rawFlex: [
                    Math.floor(Math.random() * 3),
                    Math.floor(Math.random() * 3),
                    Math.floor(Math.random() * 3),
                    Math.floor(Math.random() * 3)
                ],
                s: Math.floor(Math.random() * 2),
                sb: Math.floor(Math.random() * 2),
                sf: Math.random() > 0.7 ? 'YES' : 'NO',
                sh: Math.random() > 0.7,
                shakeState: ['None', 'Shake Left', 'Shake Right'][Math.floor(Math.random() * 3)],
                ss: 'None',
                t: Math.floor(Math.random() * 100000),
                timestamp: Date.now(),
                w: -20 - Math.floor(Math.random() * 20),
                wifiRSSI: -30 - Math.floor(Math.random() * 20)
            };
            
            updateDisplay(simulatedData);
            document.getElementById('statusText').textContent = 'Using simulated data';
        }
        
        // Main update loop
        async function updateLoop() {
            if (autoRefresh) {
                await fetchData();
            }
            
            setTimeout(updateLoop, 1000); // Update every second
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Start the update loop
            updateLoop();
            
            // Initial fetch
            fetchData();
            
            // Set up auto-refresh button
            document.getElementById('autoRefreshBtn').addEventListener('click', toggleAutoRefresh);
        });
    </script>
</body>
</html>
