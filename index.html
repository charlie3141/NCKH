<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>·ª®ng d·ª•ng v√† c·∫£i ti·∫øn "C√¥ng ngh·ªá d·ªãch th·ªß ng·ªØ" - T·ªêI ∆ØU HI·ªÜU SU·∫§T</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-database-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        /* T·ªëi ∆∞u hi·ªáu su·∫•t rendering */
        .container, .card, .conversion-display, .sentence-display, .current-word-display,
        .sensor-value, .flex-box {
            will-change: transform, opacity;
            backface-visibility: hidden;
            transform: translateZ(0);
            contain: content;
        }

        /* T·∫Øt animation khi kh√¥ng c·∫ßn thi·∫øt */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            
            .indicator.online,
            .shake-active,
            .calibrating {
                animation: none !important;
            }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            padding: 20px;
            text-align: center;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .dashboard {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            border: 1px solid #eaeaea;
        }

        .card h3 {
            color: #4A00E0;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }

        .conversion-display {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2196F3;
            margin: 10px 0;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #E3F2FD;
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #2196F3;
            line-height: 1.4;
        }

        .sentence-display {
            font-size: 1.8rem;
            font-weight: bold;
            color: #4CAF50;
            margin: 10px 0;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #E8F5E9;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #4CAF50;
            line-height: 1.4;
        }

        .current-word-display {
            font-size: 2rem;
            font-weight: bold;
            color: #FF5722;
            margin: 10px 0;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #FFF8E1;
            border-radius: 10px;
            padding: 15px;
            border: 2px dashed #FFC107;
        }

        .word-list {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #eaeaea;
        }

        .word-item {
            display: inline-block;
            padding: 8px 15px;
            margin: 5px;
            background: #e3f2fd;
            border-radius: 20px;
            border: 1px solid #bbdefb;
        }

        .word-count {
            font-size: 0.9rem;
            color: #666;
            margin-top: 10px;
        }

        .sensor-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .sensor-item {
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid;
        }

        .sensor-item.mpu {
            border-left-color: #2196F3;
        }

        .sensor-item.flex {
            border-left-color: #4CAF50;
        }

        .sensor-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
            margin: 5px 0;
        }

        .sensor-label {
            font-size: 0.8rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .flex-box {
            display: inline-block;
            width: 40px;
            height: 40px;
            line-height: 40px;
            text-align: center;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 2px;
            font-weight: bold;
            border: 2px solid transparent;
        }

        .flex-box.active-0 { background: #4CAF50; color: white; }
        .flex-box.active-1 { background: #FF9800; color: white; }
        .flex-box.active-2 { background: #F44336; color: white; }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        button.red {
            background: linear-gradient(to right, #FF416C, #FF4B2B);
        }

        button.green {
            background: linear-gradient(to right, #00b09b, #96c93d);
        }

        button.blue {
            background: linear-gradient(to right, #2196F3, #21CBF3);
        }

        .status-bar {
            background: #f8f9fa;
            padding: 15px;
            border-top: 1px solid #eaeaea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        .indicator.online {
            background: #4CAF50;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .calibration-status {
            margin: 15px 0;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
        }

        .calibrating {
            background: #FFF3CD;
            border: 2px solid #FFC107;
            color: #856404;
            animation: pulse 1s infinite;
        }

        .calibrated {
            background: #D4EDDA;
            border: 2px solid #28A745;
            color: #155724;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        .shake-active {
            color: #FF5722 !important;
            font-weight: bold !important;
            animation: shake 0.5s infinite;
        }

        .language-select {
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid #ccc;
            background: white;
            font-size: 1rem;
        }

        .phrase-btn {
            padding: 8px 15px;
            background: linear-gradient(to right, #FF9800, #FF5722);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .phrase-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(255,87,34,0.3);
        }

        .loading {
            animation: pulse 1s infinite;
            color: #2196F3 !important;
        }

        .error {
            color: #F44336 !important;
            border-color: #F44336 !important;
            background: #FFEBEE !important;
        }

        .success {
            color: #4CAF50 !important;
            border-color: #4CAF50 !important;
            background: #E8F5E9 !important;
        }

        textarea {
            width: 100%;
            height: 120px;
            font-size: 1.5rem;
            padding: 15px;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            background: #E8F5E9;
            color: #333;
            resize: vertical;
        }

        select {
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid #ccc;
            min-width: 150px;
        }

        .radio-group {
            display: flex;
            gap: 15px;
            margin-top: 5px;
        }

        .firebase-status {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

        .last-update {
            font-size: 0.8rem;
            color: #999;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }

        /* New styles for phrase suggestions */
        .phrase-suggestions {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #eaeaea;
        }

        .phrase-suggestions h4 {
            margin-bottom: 10px;
            color: #4A00E0;
            font-size: 1rem;
        }

        .phrase-pills {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .phrase-pill {
            padding: 6px 12px;
            background: linear-gradient(to right, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .phrase-pill:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(76,175,80,0.3);
        }

        .phrase-pill.blue {
            background: linear-gradient(to right, #2196F3, #1976D2);
        }

        /* Speech controls */
        .speech-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        .speech-btn {
            padding: 10px 20px;
            background: linear-gradient(to right, #9C27B0, #673AB7);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .speech-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(156,39,176,0.3);
        }

        .speech-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .speech-btn.speaking {
            background: linear-gradient(to right, #FF5722, #E64A19);
            animation: pulse 1s infinite;
        }

        .audio-visualizer {
            margin-top: 10px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
        }

        .audio-bar {
            width: 4px;
            background: #4CAF50;
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        /* Dynamic suggestions styles */
        .dynamic-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .dynamic-suggestions.show {
            display: block;
        }

        .suggestion-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background 0.2s;
        }

        .suggestion-item:hover {
            background: #f0f7ff;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .text-input-container {
            position: relative;
        }

        /* Gender selection */
        .gender-selection {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }

        .gender-btn {
            padding: 8px 16px;
            background: #f0f0f0;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }

        .gender-btn.active {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            border-color: #4A00E0;
        }

        .gender-btn.male {
            background: linear-gradient(to right, #2196F3, #1976D2);
            color: white;
        }

        .gender-btn.female {
            background: linear-gradient(to right, #E91E63, #C2185B);
            color: white;
        }

        /* Auto-suggestions panel */
        .auto-suggestions-panel {
            margin-top: 15px;
            padding: 15px;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
            border-radius: 10px;
            border: 2px solid #e0e6ff;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .auto-suggestions-title {
            font-size: 0.9rem;
            font-weight: bold;
            color: #4A00E0;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .auto-suggestions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
        }

        .auto-suggestion-item {
            padding: 12px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .auto-suggestion-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-color: #4A00E0;
        }

        .auto-suggestion-text {
            font-size: 0.9rem;
            margin-bottom: 8px;
        }

        .auto-suggestion-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .auto-suggestion-btn {
            padding: 4px 8px;
            font-size: 0.75rem;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            flex: 1;
            text-align: center;
        }

        .auto-suggestion-btn.speak {
            background: linear-gradient(to right, #9C27B0, #673AB7);
            color: white;
        }

        .auto-suggestion-btn.use {
            background: linear-gradient(to right, #4CAF50, #45a049);
            color: white;
        }

        .auto-suggestion-btn.translate {
            background: linear-gradient(to right, #2196F3, #1976D2);
            color: white;
        }

        .voice-options {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .voice-btn {
            padding: 6px 12px;
            background: linear-gradient(to right, #FF9800, #FF5722);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .voice-btn.active {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            box-shadow: 0 2px 8px rgba(74,0,224,0.3);
        }

        .language-voice-display {
            font-size: 0.8rem;
            color: #666;
            text-align: center;
            margin-top: 5px;
        }

        .ai-speech-status {
            margin-top: 5px;
            font-size: 0.8rem;
            color: #4CAF50;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .ai-loading {
            animation: pulse 1s infinite;
        }

        .tts-toggle {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .tts-toggle-btn {
            padding: 6px 12px;
            background: #f0f0f0;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .tts-toggle-btn.active {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            border-color: #4A00E0;
        }

        /* Performance Monitor */
        .performance-monitor {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: #0f0;
            padding: 8px 12px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 1000;
            display: none;
            border: 1px solid #0f0;
            box-shadow: 0 0 10px rgba(0,255,0,0.3);
        }

        .performance-monitor.visible {
            display: block;
        }

        .performance-monitor div {
            margin: 3px 0;
        }

        .performance-monitor span {
            font-weight: bold;
        }

        /* Connection quality indicator */
        .connection-quality {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-left: 5px;
        }

        .quality-excellent { background: #4CAF50; }
        .quality-good { background: #8BC34A; }
        .quality-fair { background: #FFC107; }
        .quality-poor { background: #FF5722; }
        .quality-bad { background: #F44336; }

        /* Minimal animations for performance */
        .sensor-value, .conversion-display, .sentence-display {
            transition: color 0.1s ease, background-color 0.1s ease;
        }

        /* Optimize flex boxes for GPU */
        .flex-box {
            transform: translateZ(0);
        }
    </style>
</head>
<body>
    <!-- Performance Monitor -->
    <div class="performance-monitor" id="perfMonitor">
        <div>FPS: <span id="fpsCounter">0</span></div>
        <div>Latency: <span id="latencyCounter">0</span>ms</div>
        <div>Updates/sec: <span id="updateRate">0</span></div>
        <div>Queue: <span id="queueSize">0</span></div>
        <div>Connection: <span class="connection-quality" id="connQuality"></span></div>
    </div>

    <div class="container">
        <header>
            <h1>·ª®ng d·ª•ng v√† c·∫£i ti·∫øn "C√¥ng ngh·ªá d·ªãch th·ªß ng·ªØ" - T·ªêI ∆ØU HI·ªÜU SU·∫§T</h1>
            <div>Gi√°m s√°t th·ªùi gian th·ª±c t·ª´ Firebase Realtime Database</div>
            <div class="firebase-status" id="firebaseStatus">
                ƒêang k·∫øt n·ªëi v·ªõi Firebase Realtime...
            </div>
        </header>

        <div class="dashboard">
            <!-- Card X√¢y d·ª±ng C√¢u -->
            <div class="card">
                <h3>X√¢y d·ª±ng C√¢u</h3>
                <div style="text-align: center; padding: 20px; margin-bottom: 20px;">
                    <div class="sensor-label">T·ª™ HI·ªÜN T·∫†I (M√£ h√≥a)</div>
                    <div class="current-word-display" id="displayBuffer">---</div>
                    <div class="sensor-label">T·ª™ HI·ªÜN T·∫†I (Ti·∫øng Vi·ªát)</div>
                    <div class="conversion-display" id="convertedCurrentWord">---</div>
                    
                    <div style="margin: 15px 0; color: #666;">
                        <div><strong>S·ª≠ d·ª•ng '_' ƒë·ªÉ th√™m t·ª´ v√†o c√¢u</strong></div>
                        <div><strong>S·ª≠ d·ª•ng 'COMMIT' ƒë·ªÉ ho√†n th√†nh c√¢u</strong></div>
                    </div>
                    
                    <div class="sensor-label">C√ÇU ƒê·∫¶Y ƒê·ª¶ (M√£ h√≥a)</div>
                    <div class="sentence-display" id="sentenceDisplay">---</div>
                    <div class="sensor-label">C√ÇU ƒê·∫¶Y ƒê·ª¶ (Ti·∫øng Vi·ªát)</div>
                    <div class="conversion-display" id="convertedSentenceDisplay">---</div>
                    
                    <!-- Chuy·ªÉn ƒë·ªïi TTS -->
                    <div class="tts-toggle">
                        <button class="tts-toggle-btn active" id="useGeminiTTS" onclick="toggleTTSMode(true)">üéØ Gi·ªçng AI Gemini</button>
                        <button class="tts-toggle-btn" id="useWebSpeech" onclick="toggleTTSMode(false)">üîä Web Speech</button>
                    </div>
                    
                    <!-- B·∫£ng ƒë·ªÅ xu·∫•t t·ª± ƒë·ªông -->
                    <div class="auto-suggestions-panel" id="autoSuggestionsPanel" style="display: none;">
                        <div class="auto-suggestions-title">
                            <span>üí° ƒê·ªÄ XU·∫§T D·ª∞A TR√äN C√ÇU C·ª¶A B·∫†N</span>
                        </div>
                        <div class="auto-suggestions-grid" id="autoSuggestionsGrid">
                            <!-- ƒê·ªÅ xu·∫•t t·ª± ƒë·ªông s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y -->
                        </div>
                    </div>
                    
                    <!-- ƒê·ªÅ xu·∫•t c·ª•m t·ª´ -->
                    <div class="phrase-suggestions">
                        <h4>üìù ƒê·ªÄ XU·∫§T C·ª§M T·ª™ TH√îNG D·ª§NG</h4>
                        <div class="phrase-pills" id="phrasePills">
                            <!-- C√°c n√∫t c·ª•m t·ª´ s·∫Ω ƒë∆∞·ª£c th√™m b·ªüi JavaScript -->
                        </div>
                        
                        <!-- ƒê·ªÅ xu·∫•t ƒë·ªông -->
                        <div class="dynamic-suggestions" id="dynamicSuggestions">
                            <!-- ƒê·ªÅ xu·∫•t ƒë·ªông s·∫Ω xu·∫•t hi·ªán ·ªü ƒë√¢y -->
                        </div>
                    </div>
                    
                    <!-- T√πy ch·ªçn gi·ªçng n√≥i -->
                    <div class="voice-options">
                        <div class="voice-btn male active" data-gender="male" data-lang="vi-VN" onclick="selectVoice(this)">
                            üë® Nam Ti·∫øng Vi·ªát
                        </div>
                        <div class="voice-btn female" data-gender="female" data-lang="vi-VN" onclick="selectVoice(this)">
                            üë© N·ªØ Ti·∫øng Vi·ªát
                        </div>
                        <div class="voice-btn male" data-gender="male" data-lang="en-GB" onclick="selectVoice(this)">
                            üë® Nam Ti·∫øng Anh
                        </div>
                        <div class="voice-btn female" data-gender="female" data-lang="en-GB" onclick="selectVoice(this)">
                            üë© N·ªØ Ti·∫øng Anh
                        </div>
                        <div class="voice-btn male" data-gender="male" data-lang="ja-JP" onclick="selectVoice(this)">
                            üë® Nam Ti·∫øng Nh·∫≠t
                        </div>
                        <div class="voice-btn female" data-gender="female" data-lang="ja-JP" onclick="selectVoice(this)">
                            üë© N·ªØ Ti·∫øng Nh·∫≠t
                        </div>
                    </div>
                    
                    <div class="language-voice-display" id="currentVoiceDisplay">
                        Hi·ªán t·∫°i: Nam Ti·∫øng Vi·ªát (Gemini AI)
                    </div>
                    
                    <div class="ai-speech-status" id="aiSpeechStatus" style="display: none;">
                        <span class="ai-loading">‚è≥</span> ƒêang t·∫£i gi·ªçng AI...
                    </div>
                    
                    <!-- ƒêi·ªÅu khi·ªÉn gi·ªçng n√≥i -->
                    <div class="speech-controls">
                        <button class="speech-btn" onclick="speakVietnameseSentence()" id="speakVnBtn">
                            üîä ƒê·ªçc Ti·∫øng Vi·ªát
                        </button>
                        <button class="speech-btn blue" onclick="speakTranslation()" id="speakTransBtn">
                            üîà ƒê·ªçc B·∫£n d·ªãch
                        </button>
                        <button class="speech-btn red" onclick="stopAllSpeech()" id="stopSpeechBtn">
                            ‚èπ D·ª´ng ƒë·ªçc
                        </button>
                    </div>
                    
                    <div class="audio-visualizer" id="audioVisualizer">
                        <!-- Thanh √¢m thanh s·∫Ω ƒë∆∞·ª£c th√™m ·ªü ƒë√¢y -->
                    </div>
                    
                    <div class="word-list" id="wordList">Ch∆∞a c√≥ t·ª´ n√†o</div>
                    <div class="word-count">S·ªë t·ª´ trong c√¢u: <span id="wordCount">0</span>/10</div>
                    
                    <div style="display: flex; justify-content: space-around; margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                        <div>
                            <div class="sensor-label">KHE 1</div>
                            <div class="sensor-value" id="slot1" style="font-size: 1.2rem;">---</div>
                        </div>
                        <div>
                            <div class="sensor-label">KHE 2</div>
                            <div class="sensor-value" id="slot2" style="font-size: 1.2rem;">---</div>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button onclick="clearCurrentWord()" class="red">X√≥a t·ª´ hi·ªán t·∫°i</button>
                        <button onclick="backspace()">X√≥a k√Ω t·ª±</button>
                        <button onclick="addWordToSentence()" class="green">Th√™m t·ª´ (_)</button>
                        <button onclick="commitSentence()" class="blue">Ho√†n th√†nh c√¢u</button>
                        <button onclick="resetSentence()" class="red">ƒê·∫∑t l·∫°i t·∫•t c·∫£</button>
                    </div>
                </div>
            </div>

            <!-- Card D·ªãch thu·∫≠t -->
            <div class="card">
                <h3>D·ªãch thu·∫≠t</h3>
                <div style="margin-bottom: 20px;">
                    <div class="sensor-label">C√ÇU ƒê·∫¶Y ƒê·ª¶ (Ti·∫øng Vi·ªát - ƒê·ªÉ d·ªãch)</div>
                    <div class="text-input-container">
                        <textarea id="translationInput" placeholder="Nh·∫≠p vƒÉn b·∫£n ti·∫øng Vi·ªát ·ªü ƒë√¢y..." 
                                  oninput="handleTranslationInput()"></textarea>
                        <div class="dynamic-suggestions" id="translationSuggestions">
                            <!-- ƒê·ªÅ xu·∫•t ƒë·ªông cho d·ªãch thu·∫≠t -->
                        </div>
                    </div>
                    
                    <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                        <div><strong>T√πy ch·ªçn d·ªãch thu·∫≠t:</strong></div>
                        <div style="display: flex; gap: 15px; margin-top: 10px; flex-wrap: wrap;">
                            <div>
                                <div class="sensor-label">Ng√¥n ng·ªØ ƒë√≠ch</div>
                                <select id="targetLanguage" class="language-select">
                                    <option value="en-GB">Ti·∫øng Anh</option>
                                    <option value="ja-JP">Ti·∫øng Nh·∫≠t</option>
                                    <option value="ko-KR">Ti·∫øng H√†n</option>
                                    <option value="zh-CN">Ti·∫øng Trung</option>
                                </select>
                            </div>
                            <div>
                                <div class="sensor-label">Ng√¥n ng·ªØ gi·ªçng n√≥i</div>
                                <select id="voiceLanguage" class="language-select">
                                    <option value="vi-VN">Ti·∫øng Vi·ªát</option>
                                    <option value="en-GB">Ti·∫øng Anh</option>
                                    <option value="ja-JP">Ti·∫øng Nh·∫≠t</option>
                                    <option value="ko-KR">Ti·∫øng H√†n</option>
                                    <option value="zh-CN">Ti·∫øng Trung</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="sensor-label">K·∫æT QU·∫¢ D·ªäCH</div>
                <div id="translationOutput" class="conversion-display" style="min-height: 80px; margin-bottom: 15px;">
                    ƒêang ch·ªù d·ªãch...
                </div>

                <div class="controls">
                    <button onclick="translateSentence()" class="blue">D·ªãch c√¢u</button>
                    <button onclick="clearTranslation()" class="red">X√≥a b·∫£n d·ªãch</button>
                </div>
            </div>

            <!-- Card Hi·ªÉn th·ªã C·∫£m bi·∫øn -->
            <div class="card">
                <h3>D·ªØ li·ªáu C·∫£m bi·∫øn t·ª´ Firebase</h3>
                <div class="sensor-grid">
                    <div class="sensor-item mpu">
                        <div class="sensor-label">ƒê·ªäNH H∆Ø·ªöNG MPU6050</div>
                        <div class="sensor-value" id="mpuOrientation">Kh√¥ng x√°c ƒë·ªãnh</div>
                        <div class="sensor-label">TR·∫†NG TH√ÅI L·∫ÆC</div>
                        <div class="sensor-value" id="mpuShakeState">Kh√¥ng</div>
                        <div class="sensor-label">ƒêANG L·∫ÆC?</div>
                        <div class="sensor-value" id="isShaking">KH√îNG</div>
                    </div>
                    <div class="sensor-item flex">
                        <div class="sensor-label">C·∫¢M BI·∫æN U·ªêN</div>
                        <div>
                            <div>
                                <span class="flex-box" id="flex0-box">0</span>
                                <span class="flex-box" id="flex1-box">0</span>
                                <span class="flex-box" id="flex2-box">0</span>
                                <span class="flex-box" id="flex3-box">0</span>
                            </div>
                            <div class="sensor-label" style="margin-top: 10px;">
                                Gi√° tr·ªã th√¥: <span id="rawValues">0, 0, 0, 0</span>
                            </div>
                            <div class="sensor-label">
                                Tr·∫°ng th√°i: <span id="flexFormat">0000</span> (a0,a1,a2,a3)
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="sensor-item" style="margin-top: 15px;">
                    <div class="sensor-label">TR·∫†NG TH√ÅI H·ªÜ TH·ªêNG</div>
                    <div>C·∫≠p nh·∫≠t l·∫ßn cu·ªëi: <span id="lastUpdateTime" class="last-update">Ch∆∞a bao gi·ªù</span></div>
                </div>
                
                <div class="controls" style="margin-top: 15px;">
                    <button onclick="refreshData()" class="blue">L√†m m·ªõi ngay</button>
                    <button onclick="toggleAutoRefresh()" id="autoRefreshBtn" class="green">Realtime: B·∫¨T</button>
                </div>
            </div>

            <!-- Card Hi·ªÉn th·ªã Nh·∫≠t k√Ω -->
            <div class="card">
                <h3>Nh·∫≠t k√Ω H·ªá th·ªëng</h3>
                <div style="max-height: 300px; overflow-y: auto; background: #f8f9fa; border-radius: 8px; padding: 10px;">
                    <div id="logContainer">
                        <div class="log-entry">H·ªá th·ªëng ƒë√£ kh·ªüi ƒë·ªông. ƒêang ch·ªù d·ªØ li·ªáu Firebase...</div>
                    </div>
                </div>
                <div class="controls" style="margin-top: 15px;">
                    <button onclick="clearLog()" class="red">X√≥a nh·∫≠t k√Ω</button>
                    <button onclick="togglePerformanceMonitor()" class="blue">Hi·ªáu su·∫•t</button>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div>
                <span class="indicator" id="connectionStatus"></span>
                <span id="statusText">ƒêang k·∫øt n·ªëi v·ªõi Firebase Realtime...</span>
            </div>
            <div>
                <span id="lastUpdate">C·∫≠p nh·∫≠t: --:--:--</span>
            </div>
        </div>
    </div>

    <script>
        // ===========================================
        // C·∫§U H√åNH V√Ä BI·∫æN TO√ÄN C·ª§C T·ªêI ∆ØU
        // ===========================================
        
        // C·∫•u h√¨nh Firebase Realtime Database
        const firebaseConfig = {
            apiKey: "AIzaSyDbPmge2DxS8-_Wgh6XH2LbUZ5nzq79Kkw",
            authDomain: "gangtay-f1efe.firebaseapp.com",
            databaseURL: "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "gangtay-f1efe",
            storageBucket: "gangtay-f1efe.firebasestorage.app",
            messagingSenderId: "144511241430",
            appId: "1:144511241430:web:218bd0e794b23707381a6e"
        };

        // Bi·∫øn t·ªëi ∆∞u hi·ªáu su·∫•t
        let updateTimeout = null;
        let lastSensorData = null;
        let isFetching = false;
        let frameCount = 0;
        let lastFrameTime = performance.now();
        let fps = 0;
        let updateCount = 0;
        let lastUpdateCountReset = Date.now();
        let domCache = {};
        let updateQueue = [];
        let isProcessingQueue = false;
        let performanceMonitorVisible = false;
        
        // Firebase instance
        let firebaseApp;
        let database;
        let dataRef;
        let realtimeConnected = false;
        let lastRealtimeUpdate = 0;
        
        // Bi·∫øn ·ª©ng d·ª•ng ch√≠nh
        let firebaseData = null;
        let lastUpdateTime = 0;
        let logEntries = [];
        const MAX_LOG_ENTRIES = 20;
        
        // Bi·∫øn x√¢y d·ª±ng c√¢u
        let slot1 = "";
        let slot2 = "";
        let displayBuffer = "";
        let convertedCurrentWord = "";
        let sentenceWords = [];
        let fullSentence = "";
        let convertedFullSentence = "";
        
        // Tr·∫°ng th√°i c·∫£m bi·∫øn u·ªën
        let flexStates = [0, 0, 0, 0];
        let lastFlexStates = [-1, -1, -1, -1];
        let stableCount = 0;
        let lastDetectedIndex = -1;
        let holdStartMs = 0;
        let holdFired = false;
        const DEBOUNCE_COUNT = 2; // Gi·∫£m t·ª´ 3 xu·ªëng 2
        const HOLD_MS_DEFAULT = 500; // Gi·∫£m t·ª´ 800 xu·ªëng 500
        const POST_HOLD_COOLDOWN = 300; // Gi·∫£m t·ª´ 600 xu·ªëng 300
        let lastActionMs = 0;
        
        // √Ånh x·∫° tr·∫°ng th√°i MPU
        const mpuStateMap = {
            "Up": 0,
            "Down": 1,
            "Left": 2,
            "Right": 3,
            "Forward": 4,
            "Backward": 5
        };

        // B·∫£ng t·ª´ ESP32 code (gi·ªØ nguy√™n)
        const tableA = [
            ["IAY","IC","ICH","IE","IEC","IEM","IEN","IENG","IEO"],
            ["IEP","IET","IEU","IM","IN","ING","INH","IO","IOI"],
            ["ENG","ENH","EO","EP","ET","EU","I","IA","IAC"],
            ["IAI","IAM","IAN","IANG","IANH","IAO","IAP","IAT","IAU"],
            ["AP","AT","AU","AY","E","EC","ECH","EM","EN"],
            ["A","AC","ACH","AI","AM","AN","ANG","ANH","AO"],
            ["IUN","IUONG","IUP","O","OA","OAC","OACH","OAI","OAM"],
            ["ION","IONG","IOT","IP","IT","IU","IUA","IUC","IUI"]
        ];

        const tableB = [
            ["UE","UECH","UEN","UENH","UEO","UET","UI","UM","UN"],
            ["UNG","UO","UOC","UOI","UOM","UON","UONG","UOP","OUT"],
            ["ONG","OOC","OONG","OP","OT","U","UA","UAC","UACH"],
            ["UAI","UAM","UAN","UANG","UANH","UAO","UAT","UAY","UC"],
            ["OAY","OC","OE","OEN","OEO","OET","OI","OM","ON"],
            ["COMMIT","_","nullptr","nullptr","OAN","OANG","OANH","OAP","OAT"],
            ["UYNH","UYP","UYT","UYU","Y","YEM","YEN","YET","YEU"],
            ["UOU","UP","UT","UU","UY","UYA","UYCH","UYEN","UYET"]
        ];

        const tableC = [
            [ ["B","C","D"],["ƒê","G","H"],["K","L","M"] ],
            [ ["N","P","Q"],["R","S","T"],["V","X","CH"] ],
            [ ["GH","KH","NG"],["NGH","NH","PH"],["TH","TR","_"] ]
        ];

        // B·∫£ng chuy·ªÉn ƒë·ªïi Ti·∫øng Vi·ªát - ƒê√É ƒê∆Ø·ª¢C C·∫¢I THI·ªÜN
        const vietnameseTable = [
            {key: "A", forms: ["a","√†","·∫£","√£","·∫°","√°","√¢","·∫ß","·∫©","·∫´","·∫≠","·∫•","ƒÉ","·∫±","·∫≥","·∫µ","·∫∑","·∫Ø"]},
            {key: "AI", forms: ["ai","√†i","·∫£i","√£i","·∫°i","√°i","√¢i","·∫ßi","·∫©i","·∫´i","·∫≠i","·∫•i","ƒÉi","·∫±i","·∫≥i","·∫µi","·∫∑i","·∫Øi"]},
            {key: "AN", forms: ["an","√†n","·∫£n","√£n","·∫°n","√°n","√¢n","·∫ßn","·∫©n","·∫´n","·∫≠n","·∫•n","ƒÉn","·∫±n","·∫≥n","·∫µn","·∫∑n","·∫Øn"]},
            {key: "ANG", forms: ["ang","√†ng","·∫£ng","√£ng","·∫°ng","√°ng","√¢ng","·∫ßng","·∫©ng","·∫´ng","·∫≠ng","·∫•ng","ƒÉng","·∫±ng","·∫≥ng","·∫µng","·∫∑ng","·∫Øng"]},
            {key: "ANH", forms: ["anh","√†nh","·∫£nh","√£nh","·∫°nh","√°nh","√¢nh","·∫ßnh","·∫©nh","·∫´nh","·∫≠nh","√°nh","ƒÉnh","·∫±nh","·∫≥nh","·∫µnh","·∫∑nh","·∫Ønh"]},
            {key: "AO", forms: ["ao","√†o","·∫£o","√£o","·∫°o","√°o","ao","√†o","·∫£o","√£o","·∫°o","√°o","ao","√†o","·∫£o","√£o","·∫°o","√°o"]},
            {key: "AU", forms: ["au","√†u","·∫£u","√£u","·∫°u","√°u","√¢u","·∫ßu","·∫©u","·∫´u","·∫≠u","·∫•u","ƒÉu","·∫±u","·∫≥u","·∫µu","·∫∑u","·∫Øu"]},
            {key: "AY", forms: ["ay","√†y","·∫£y","√£y","·∫°y","√°y","√¢y","·∫ßy","·∫©y","·∫´y","·∫≠y","·∫•y","ƒÉy","·∫±y","·∫≥y","·∫µy","·∫∑y","·∫Øy"]},
            {key: "E", forms: ["e","√®","·∫ª","·∫Ω","·∫π","√©","√™","·ªÅ","·ªÉ","·ªÖ","·ªá","·∫ø","e","√®","·∫ª","·∫Ω","·∫π","√©"]},
            {key: "EM", forms: ["em","√®m","·ªÉm","·∫Ωm","·∫πm","√©m","√™m","·ªÅm","·ªÉm","·ªÖm","·ªám","·∫øm","em","√®m","·ªÉm","·∫Ωm","·∫πm","√©m"]},
            {key: "EN", forms: ["en","√®n","·ªÉn","·ªÖn","·ªán","√©n","√™n","·ªÅn","·ªÉn","·ªÖn","·ªán","·∫øn","en","√®n","·ªÉn","·ªÖn","·ªán","√©n"]},
            {key: "ENG", forms: ["eng","√®ng","·∫ªng","·∫Ωng","·∫πng","√©ng","√™ng","·ªÅng","·ªÉng","·ªÖng","·ªáng","·∫øng","eng","√®ng","·∫ªng","·∫Ωng","·∫πng","√©ng"]},
            {key: "EO", forms: ["eo","√®o","·∫ªo","·∫Ωo","·∫πo","√©o","eo","√®o","·∫ªo","·∫Ωo","·∫πo","√©o","eo","√®o","·∫ªo","·∫Ωo","·∫πo","√©o"]},
            {key: "I", forms: ["i","√¨","·ªâ","ƒ©","·ªã","√≠","i","√¨","·ªâ","ƒ©","·ªã","√≠","i","√¨","·ªâ","ƒ©","·ªã","√≠"]},
            {key: "IA", forms: ["ia","√¨a","·ªâa","ƒ©a","·ªãa","√≠a","ia","√¨a","·ªâa","ƒ©a","·ªãa","√≠a","ia","√¨a","·ªâa","ƒ©a","·ªãa","√≠a"]},
            {key: "IE", forms: ["ie","i√®","i·∫ª","i·∫Ω","i·∫π","i√©","i√™","i·ªÅ","i·ªÉ","i·ªÖ","i·ªá","i·∫ø","ie","i√®","i·∫ª","i·∫Ω","i·∫π","i√©"]},
            {key: "IEM", forms: ["iem","i√®m","i·ªÉm","i·∫Ωm","i·∫πm","i√©m","i√™m","i·ªÅm","i·ªÉm","i·ªÖm","i·ªám","i·∫øm","iem","i√®m","i·ªÉm","i·∫Ωm","i·∫πm","i√©m"]},
            {key: "IEN", forms: ["ien","i√®n","i·ªÉn","i·ªÖn","i·ªán","i√©n","i√™n","i·ªÅn","i·ªÉn","i·ªÖn","i·ªán","i·∫øn","ien","i√®n","i·ªÉn","i·ªÖn","i·ªán","i√©n"]},
            {key: "IM", forms: ["im","√¨m","·ªâm","ƒ©m","·ªãm","√≠m","im","√¨m","·ªâm","ƒ©m","·ªãm","√≠m","im","√¨m","·ªâm","ƒ©m","·ªãm","√≠m"]},
            {key: "IN", forms: ["in","√¨n","·ªân","ƒ©n","·ªãn","√≠n","in","√¨n","·ªân","ƒ©n","·ªãn","√≠n","in","√¨n","·ªân","ƒ©n","·ªãn","√≠n"]},
            {key: "INH", forms: ["inh","√¨nh","·ªânh","ƒ©nh","·ªãnh","√≠nh","inh","√¨nh","·ªânh","ƒ©nh","·ªãnh","√≠nh","inh","√¨nh","·ªânh","ƒ©nh","·ªãnh","√≠nh"]},
            {key: "IU", forms: ["iu","√¨u","·ªâu","ƒ©u","·ªãu","√≠u","iu","√¨u","·ªâu","ƒ©u","·ªãu","√≠u","iu","√¨u","·ªâu","ƒ©u","·ªãu","√≠u"]},
            {key: "O", forms: ["o","√≤","·ªè","√µ","·ªç","√≥","√¥","·ªì","·ªï","·ªó","·ªô","·ªë","∆°","·ªù","·ªü","·ª°","·ª£","·ªõ"]},
            {key: "OA", forms: ["oa","√≤a","·ªèa","√µa","·ªça","√≥a","oa","√≤a","·ªèa","√µa","·ªça","√≥a","oa","√≤a","·ªèa","√µa","·ªça","√≥a"]},
            {key: "OI", forms: ["oi","√≤i","·ªèi","√µi","·ªçi","√≥i","√¥i","·ªìi","·ªïi","·ªói","·ªôi","·ªëi","∆°i","·ªùi","·ªüi","·ª°i","·ª£i","·ªõi"]},
            {key: "OM", forms: ["om","√≤m","·ªèm","√µm","·ªçm","√≥m","√¥m","·ªìm","·ªïm","·ªóm","·ªôm","·ªëm","∆°m","·ªùm","·ªüm","·ª°m","·ª£m","·ªõm"]},
            {key: "ON", forms: ["on","√≤n","·ªèn","√µn","·ªçn","√≥n","√¥n","·ªìn","·ªïn","·ªón","·ªôn","·ªën","∆°n","·ªùn","·ªün","·ª°n","·ª£n","·ªõn"]},
            {key: "ONG", forms: ["ong","√≤ng","·ªèng","√µng","·ªçng","√≥ng","√¥ng","·ªìng","·ªïng","·ªóng","·ªông","·ªëng","∆°ng","·ªùng","·ªüng","·ª°ng","·ª£ng","·ªõng"]},
            {key: "U", forms: ["u","√π","·ªß","≈©","·ª•","√∫","u","√π","·ªß","≈©","·ª•","√∫","∆∞","·ª´","·ª≠","·ªØ","·ª±","·ª©"]},
            {key: "UA", forms: ["ua","√πa","·ªßa","≈©a","·ª•a","√∫a","ua","√πa","·ªßa","≈©a","·ª•a","√∫a","∆∞a","·ª´a","·ª≠a","·ªØa","·ª±a","·ª©a"]},
            {key: "UI", forms: ["ui","√πi","·ªßi","≈©i","·ª•i","√∫i","ui","√πi","·ªßi","≈©i","·ª•i","√∫i","∆∞i","·ª´i","·ª≠i","·ªØi","·ª±i","·ª©i"]},
            {key: "UN", forms: ["un","√πn","·ªßn","≈©n","·ª•n","√∫n","un","√πn","·ªßn","≈©n","·ª•n","√∫n","∆∞n","·ª´n","·ª≠n","·ªØn","·ª±n","·ª©n"]},
            {key: "UNG", forms: ["ung","√πng","·ªßng","≈©ng","·ª•ng","√∫ng","ung","√πng","·ªßng","≈©ng","·ª•ng","√∫ng","∆∞ng","·ª´ng","·ª≠ng","·ªØng","·ª±ng","·ª©ng"]},
            {key: "UO", forms: ["uo","u√≤","u·ªè","u√µ","u·ªç","u√≥","u√¥","u·ªì","u·ªï","u·ªó","u·ªô","u·ªë","∆∞∆°","∆∞·ªù","∆∞·ªü","∆∞·ª°","∆∞·ª£","∆∞·ªõc"]},
            {key: "UY", forms: ["uy","√πy","·ªßy","≈©y","·ª•y","√∫y","uy","√πy","·ªßy","≈©y","·ª•y","√∫y","∆∞y","·ª´y","·ª≠y","·ªØy","·ª±y","·ª©y"]},
            {key: "Y", forms: ["y","·ª≥","·ª∑","·ªπ","·ªµ","√Ω","y","·ª≥","·ª∑","·ªπ","·ªµ","√Ω","y","·ª≥","·ª∑","·ªπ","·ªµ","√Ω"]}
        ];

        // ƒê·ªÅ xu·∫•t c·ª•m t·ª´
        const commonPhrases = [
            "Xin ch√†o, r·∫•t vui ƒë∆∞·ª£c g·∫∑p b·∫°n",
            "B·∫°n kh·ªèe kh√¥ng?",
            "C·∫£m ∆°n b·∫°n r·∫•t nhi·ªÅu",
            "L√†m ∆°n cho t√¥i h·ªèi ƒë∆∞·ªùng",
            "Ch√∫c m·ªôt ng√†y t·ªët l√†nh",
            "T√¥i y√™u ng√¥n ng·ªØ n√†y",
            "H·∫πn g·∫∑p l·∫°i sau",
            "T√¥i ƒë√≥i b·ª•ng",
            "Bao nhi√™u ti·ªÅn?",
            "T√¥i kh√¥ng hi·ªÉu"
        ];

        // Bi·∫øn TTS
        const GEMINI_API_KEY = "AIzaSyDdUj2SX83qODeZ1hhru0e9KN1fwDrtUP8";
        const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent";
        let isSpeaking = false;
        let currentSpeech = null;
        let audioVisualizerInterval = null;
        let audioCache = {};
        let useGeminiTTS = true;
        let currentVoice = { lang: 'vi-VN', gender: 'male' };
        
        // Translation cache
        let translationCache = {};
        let lastTranslationTime = 0;
        const TRANSLATION_COOLDOWN = 2000;

        // ===========================================
        // H√ÄM T·ªêI ∆ØU HI·ªÜU SU·∫§T
        // ===========================================

        // 1. H·ªá th·ªëng cache DOM
        function updateElement(id, content, className = '') {
            const element = document.getElementById(id);
            if (!element) return;
            
            const cacheKey = id;
            
            // Ki·ªÉm tra cache ƒë·ªÉ tr√°nh c·∫≠p nh·∫≠t kh√¥ng c·∫ßn thi·∫øt
            if (domCache[cacheKey] && 
                domCache[cacheKey].content === content && 
                domCache[cacheKey].className === className) {
                return;
            }
            
            // C·∫≠p nh·∫≠t text n·∫øu thay ƒë·ªïi
            if (element.textContent !== content) {
                element.textContent = content;
            }
            
            // C·∫≠p nh·∫≠t class n·∫øu thay ƒë·ªïi
            if (className && element.className !== className) {
                element.className = className;
            }
            
            // L∆∞u v√†o cache
            domCache[cacheKey] = { content, className };
        }

        // 2. H·ªá th·ªëng queue batch updates
        function queueUpdate(type, data) {
            updateQueue.push({ type, data, timestamp: performance.now() });
            updateCount++;
            
            if (!isProcessingQueue && updateQueue.length > 0) {
                processUpdateQueue();
            }
        }

        function processUpdateQueue() {
            if (updateQueue.length === 0) {
                isProcessingQueue = false;
                return;
            }
            
            isProcessingQueue = true;
            
            // S·ª≠ d·ª•ng requestAnimationFrame ƒë·ªÉ ƒë·ªìng b·ªô v·ªõi refresh rate
            requestAnimationFrame(() => {
                const now = performance.now();
                const batch = [];
                
                // L·∫•y t·ªëi ƒëa 10 updates t·ª´ queue
                while (updateQueue.length > 0 && batch.length < 10) {
                    batch.push(updateQueue.shift());
                }
                
                // X·ª≠ l√Ω batch
                batch.forEach(update => {
                    const latency = now - update.timestamp;
                    
                    switch(update.type) {
                        case 'MPU':
                            updateMPUDisplay(update.data);
                            break;
                        case 'FLEX':
                            updateFlexDisplay(update.data);
                            break;
                        case 'TIME':
                            updateTimeDisplay();
                            break;
                        case 'WORD':
                            updateWordConstruction(update.data);
                            break;
                        case 'SENSOR_UPDATE':
                            handleSensorUpdate(update.data);
                            break;
                    }
                    
                    // Update latency display
                    if (latency > 100) {
                        updateElement('latencyCounter', Math.round(latency));
                        updateConnectionQuality(latency);
                    }
                });
                
                // Update queue size display
                updateElement('queueSize', updateQueue.length);
                
                // Ti·∫øp t·ª•c x·ª≠ l√Ω n·∫øu c√≤n trong queue
                if (updateQueue.length > 0) {
                    setTimeout(processUpdateQueue, 0);
                } else {
                    isProcessingQueue = false;
                }
            });
        }

        // 3. Debounced update v·ªõi RAF
        function debouncedUpdate(data) {
            if (updateTimeout) {
                cancelAnimationFrame(updateTimeout);
            }
            
            updateTimeout = requestAnimationFrame(() => {
                performFastUpdate(data);
            });
        }

        function performFastUpdate(data) {
            if (!data) return;
            
            // So s√°nh ƒë·ªÉ tr√°nh c·∫≠p nh·∫≠t kh√¥ng c·∫ßn thi·∫øt
            const dataStr = JSON.stringify(data);
            if (lastSensorData === dataStr) return;
            lastSensorData = dataStr;
            
            firebaseData = data;
            lastUpdateTime = Date.now();
            
            // Queue c√°c updates
            queueUpdate('SENSOR_UPDATE', data);
            
            // C·∫≠p nh·∫≠t hi·ªáu su·∫•t
            updatePerformanceStats();
        }

        // 4. C·∫≠p nh·∫≠t hi·ªáu su·∫•t
        function updatePerformanceStats() {
            frameCount++;
            const now = performance.now();
            
            // C·∫≠p nh·∫≠t FPS m·ªói gi√¢y
            if (now >= lastFrameTime + 1000) {
                fps = Math.round((frameCount * 1000) / (now - lastFrameTime));
                frameCount = 0;
                lastFrameTime = now;
                
                const updatesPerSec = Math.round(updateCount / 1);
                updateCount = 0;
                
                updateElement('fpsCounter', fps);
                updateElement('updateRate', updatesPerSec);
            }
        }

        // 5. C√°c h√†m update c·ª• th·ªÉ
        function updateMPUDisplay(data) {
            updateElement('mpuOrientation', data.o || 'Kh√¥ng x√°c ƒë·ªãnh');
            updateElement('mpuShakeState', data.d || 'Kh√¥ng');
            
            const shaking = data.sf === "YES";
            updateElement('isShaking', shaking ? "C√ì" : "KH√îNG");
            
            // Animation shake hi·ªáu qu·∫£
            const shakeElement = document.getElementById('isShaking');
            if (shaking) {
                shakeElement.classList.add('shake-active');
            } else {
                shakeElement.classList.remove('shake-active');
            }
        }

        function updateFlexDisplay(data) {
            const flexValues = [data.f0 || 0, data.f1 || 0, data.f2 || 0, data.f3 || 0];
            let needsUpdate = false;
            
            // T√≠nh to√°n tr·∫°ng th√°i u·ªën (t·ªëi ∆∞u)
            for (let i = 0; i < 4; i++) {
                const newState = calculateFlexState(flexValues[i], i);
                if (flexStates[i] !== newState) {
                    flexStates[i] = newState;
                    needsUpdate = true;
                }
            }
            
            if (needsUpdate) {
                // C·∫≠p nh·∫≠t h·ªôp u·ªën
                for (let i = 0; i < 4; i++) {
                    const box = document.getElementById(`flex${i}-box`);
                    const boxCacheKey = `flex${i}-box`;
                    const boxClass = `flex-box active-${flexStates[i]}`;
                    
                    updateElement(`flex${i}-box`, flexStates[i]);
                    
                    if (domCache[boxCacheKey]?.className !== boxClass) {
                        box.className = boxClass;
                        domCache[boxCacheKey] = { 
                            content: flexStates[i], 
                            className: boxClass 
                        };
                    }
                }
                
                updateElement('rawValues', flexValues.join(', '));
                updateElement('flexFormat', flexStates.join(''));
            }
        }

        function updateTimeDisplay() {
            const now = Date.now();
            const timeStr = formatTime(now);
            const latency = now - lastUpdateTime;
            
            updateElement('lastUpdate', `C·∫≠p nh·∫≠t: ${timeStr}`);
            updateElement('lastUpdateTime', timeStr);
            
            // C·∫≠p nh·∫≠t ch·∫•t l∆∞·ª£ng k·∫øt n·ªëi
            updateConnectionQuality(latency);
        }

        function updateConnectionQuality(latency) {
            const qualityElement = document.getElementById('connQuality');
            let qualityClass = 'quality-bad';
            
            if (latency < 50) qualityClass = 'quality-excellent';
            else if (latency < 100) qualityClass = 'quality-good';
            else if (latency < 200) qualityClass = 'quality-fair';
            else if (latency < 500) qualityClass = 'quality-poor';
            
            qualityElement.className = `connection-quality ${qualityClass}`;
        }

        function handleSensorUpdate(data) {
            // X·ª≠ l√Ω ƒë·ªìng th·ªùi c√°c c·∫£m bi·∫øn
            queueUpdate('MPU', data);
            queueUpdate('FLEX', data);
            queueUpdate('TIME', null);
            queueUpdate('WORD', data);
        }

        // 6. H√†m t√≠nh to√°n flex state t·ªëi ∆∞u
        function calculateFlexState(rawValue, sensorIndex) {
            // T·ªëi ∆∞u: Pre-calculated thresholds
            const thresholds = [
                { straight: 100, bent: 300 },    // sensor 0
                { straight: 150, bent: 450 },    // sensor 1
                { straight: 150, bent: 350 },    // sensor 2
                { straight: 100, bent: 300 }     // sensor 3
            ];
            
            const t = thresholds[sensorIndex];
            
            // Fast condition check
            if (rawValue <= t.straight) return 0;
            if (rawValue <= t.bent) return 1;
            return 2;
        }

        // ===========================================
        // FIREBASE REALTIME DATABASE
        // ===========================================

        function initFirebaseRealtime() {
            try {
                firebaseApp = firebase.initializeApp(firebaseConfig);
                database = firebase.database();
                dataRef = database.ref('sensorData');
                
                log('SYSTEM', 'ƒê√£ kh·ªüi t·∫°o Firebase Realtime Database');
                
                // Thi·∫øt l·∫≠p listener v·ªõi timeout
                const connectionTimeout = setTimeout(() => {
                    log('SYSTEM', 'Firebase realtime timeout, switching to REST fallback');
                    initRestFallback();
                }, 5000);
                
                dataRef.on('value', (snapshot) => {
                    clearTimeout(connectionTimeout);
                    
                    const data = snapshot.val();
                    if (data) {
                        realtimeConnected = true;
                        lastRealtimeUpdate = Date.now();
                        debouncedUpdate(data);
                        updateConnectionStatus(true);
                        
                        // Update connection status
                        document.getElementById('autoRefreshBtn').textContent = 'Realtime: B·∫¨T';
                        document.getElementById('autoRefreshBtn').className = 'green';
                    }
                }, (error) => {
                    clearTimeout(connectionTimeout);
                    console.error('Firebase error:', error);
                    updateConnectionStatus(false);
                    realtimeConnected = false;
                    initRestFallback();
                });
                
                // Keep-alive ping
                setInterval(() => {
                    if (dataRef && realtimeConnected) {
                        dataRef.once('value').catch(() => {
                            realtimeConnected = false;
                            updateConnectionStatus(false);
                        });
                    }
                }, 30000);
                
            } catch (error) {
                console.error("Firebase initialization error:", error);
                initRestFallback();
            }
        }

        function initRestFallback() {
            const FIREBASE_URL = "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/sensorData.json";
            
            let pollInterval = 100;
            let retryCount = 0;
            
            async function fastPoll() {
                if (isFetching) return;
                
                try {
                    isFetching = true;
                    const startTime = performance.now();
                    
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 1000);
                    
                    const response = await fetch(`${FIREBASE_URL}?t=${Date.now()}`, {
                        signal: controller.signal,
                        cache: 'no-store',
                        headers: {
                            'Pragma': 'no-cache',
                            'Cache-Control': 'no-cache, no-store, must-revalidate'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const data = await response.json();
                    const latency = Math.round(performance.now() - startTime);
                    
                    // Adaptive polling
                    if (latency < 50) pollInterval = 50;
                    else if (latency < 100) pollInterval = 100;
                    else if (latency < 200) pollInterval = 200;
                    else pollInterval = 300;
                    
                    retryCount = 0;
                    updateConnectionStatus(true);
                    debouncedUpdate(data);
                    
                    isFetching = false;
                    
                    // L·∫≠p l·ªãch poll ti·∫øp theo
                    setTimeout(fastPoll, pollInterval);
                    
                } catch (error) {
                    isFetching = false;
                    retryCount++;
                    
                    const backoff = Math.min(1000 * Math.pow(2, retryCount), 10000);
                    
                    updateConnectionStatus(false);
                    log('SYSTEM', `REST fallback error (retry ${retryCount}): ${error.message}`);
                    
                    setTimeout(fastPoll, backoff);
                }
            }
            
            fastPoll();
            
            log('SYSTEM', 'ƒê√£ k√≠ch ho·∫°t REST fallback v·ªõi adaptive polling');
            document.getElementById('autoRefreshBtn').textContent = 'Polling: B·∫¨T';
            document.getElementById('autoRefreshBtn').className = 'blue';
        }

        // ===========================================
        // H√ÄM X√ÇY D·ª∞NG C√ÇU V√Ä X·ª¨ L√ù T·ª™ - ƒê√É S·ª¨A
        // ===========================================

        function updateWordConstruction(data) {
            const mpuState = getMPUState(data.o || "Kh√¥ng x√°c ƒë·ªãnh", data.d || "Kh√¥ng");
            const a0 = flexStates[0];
            const a1 = flexStates[1];
            const a2 = flexStates[2];
            const a3 = flexStates[3];
            
            // T·ªëi ∆∞u stable count detection
            if (mpuState === lastDetectedIndex && 
                a0 === lastFlexStates[0] && 
                a1 === lastFlexStates[1] && 
                a2 === lastFlexStates[2] && 
                a3 === lastFlexStates[3]) {
                stableCount++;
            } else {
                stableCount = 1;
                lastDetectedIndex = mpuState;
                lastFlexStates = [...flexStates];
                holdStartMs = performance.now();
                holdFired = false;
            }
            
            // Ki·ªÉm tra h√†nh ƒë·ªông v·ªõi hi·ªáu su·∫•t cao
            if (stableCount >= DEBOUNCE_COUNT) {
                const held = performance.now() - holdStartMs;
                if (!holdFired && (performance.now() - lastActionMs) > POST_HOLD_COOLDOWN && held >= HOLD_MS_DEFAULT) {
                    performActionSlotLogic(mpuState, a0, a1, a2, a3);
                    holdFired = true;
                    lastActionMs = performance.now();
                }
            }
        }

        function getMPUState(orientation, shakeState) {
            if (shakeState === "Shake Left") return 6;
            if (shakeState === "Shake Right") return 7;
            
            switch(orientation) {
                case "Up": return 0;
                case "Down": return 1;
                case "Left": return 2;
                case "Right": return 3;
                case "Forward": return 4;
                case "Backward": return 5;
                default: return -1;
            }
        }

        function getMappingForIndices(mpuState, a0, a1, a2, a3) {
            if (mpuState < 0 || mpuState > 7) return null;
            
            if (a3 === 2) {
                if (a0 < 3 && a1 < 3 && a2 < 3) {
                    return tableC[a0][a1][a2];
                }
                return null;
            }
            
            const a3bin = a3 === 1 ? 1 : 0;
            if (a1 < 0 || a1 >= 3 || a2 < 0 || a2 >= 3) return null;
            
            const flatIndex = a1 * 3 + a2;
            
            if (flatIndex >= 0 && flatIndex < 9) {
                return a3bin === 0 ? tableA[mpuState][flatIndex] : tableB[mpuState][flatIndex];
            }
            
            return null;
        }

        function flexModeCharFromA0(a0) {
            switch(a0) {
                case 0: return 's';
                case 1: return 'b';
                case 2: return 'p';
                default: return 'x';
            }
        }

        function performActionSlotLogic(mpu, a0, a1, a2, a3) {
            const mapping = getMappingForIndices(mpu, a0, a1, a2, a3);
            if (!mapping || mapping === "nullptr") return false;
            
            if (mapping === "_") {
                addWordToSentence();
                return true;
            }
            
            if (mapping === "COMMIT") {
                commitSentence();
                return true;
            }
            
            if (mapping === "<") {
                backspaceBuffer();
                updateDisplayBufferFromSlots();
                return true;
            }
            
            const isSlot1 = (a3 === 2);
            const held = performance.now() - holdStartMs;
            
            if (isSlot1 && stableCount >= DEBOUNCE_COUNT && held < HOLD_MS_DEFAULT) {
                const mode = flexModeCharFromA0(a0);
                slot2 = `${mapping}_${mode}`;
            } else if (isSlot1) {
                slot1 = `${mapping}_${mpu}`;
            } else {
                const mode = flexModeCharFromA0(a0);
                slot2 = `${mapping}_${mode}`;
            }
            
            updateDisplayBufferFromSlots();
            log('WORD', `H√†nh ƒë·ªông: ${displayBuffer}`);
            return true;
        }

        function updateDisplayBufferFromSlots() {
            const oldBuffer = displayBuffer;
            displayBuffer = '';
            
            if (slot1) {
                displayBuffer += slot1.toLowerCase();
            }
            
            if (slot2) {
                displayBuffer += slot2.toLowerCase();
            }
            
            if (oldBuffer !== displayBuffer) {
                updateConversions();
            }
            
            updateUI();
        }

        // T·ªëi ∆∞u chuy·ªÉn ƒë·ªïi Ti·∫øng Vi·ªát v·ªõi lookup table
        const vietnameseLookup = {};
        function initVietnameseLookup() {
            vietnameseTable.forEach(item => {
                vietnameseLookup[item.key] = item.forms;
            });
        }

        // H√ÄM CHUY·ªÇN ƒê·ªîI ƒê√É ƒê∆Ø·ª¢C S·ª¨A L·ªñI
        function convertVietnameseWord(encodedWord) {
            if (!encodedWord || encodedWord.length === 0) return "";
            
            // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
            if (encodedWord === "_") return " ";
            if (encodedWord === "COMMIT") return "(Ho√†n th√†nh)";
            
            // Ki·ªÉm tra ƒë·ªãnh d·∫°ng m√£ h√≥a
            const parts = encodedWord.split('_');
            if (parts.length < 3) return encodedWord; // Kh√¥ng ƒë·ªß ph·∫ßn
            
            const consonant = parts[0];
            const middle = parts[1];
            const vowelTypeStr = parts[2];
            
            if (!middle || middle.length < 2) return encodedWord;
            
            const toneChar = middle[0];
            if (toneChar < '1' || toneChar > '6') return encodedWord;
            
            const tone = parseInt(toneChar);
            const vowelKey = middle.substring(1).toUpperCase();
            
            let vowelType = 0;
            if (vowelTypeStr === "b") {
                vowelType = 1;
            } else if (vowelTypeStr === "p") {
                vowelType = 2;
            } else if (vowelTypeStr !== "s") {
                return encodedWord;
            }
            
            const tableIndex = (tone - 1) + (vowelType * 6);
            if (tableIndex < 0 || tableIndex >= 18) return encodedWord;
            
            const vowelForms = vietnameseLookup[vowelKey];
            if (!vowelForms) {
                console.log(`Kh√¥ng t√¨m th·∫•y nguy√™n √¢m: ${vowelKey}`);
                return encodedWord;
            }
            
            return consonant + vowelForms[tableIndex];
        }

        function convertVietnameseText(encodedText) {
            if (!encodedText || encodedText.length === 0) return "";
            
            const words = encodedText.split(' ');
            const results = [];
            
            for (let word of words) {
                results.push(convertVietnameseWord(word));
            }
            
            return results.join(' ');
        }

        function updateConversions() {
            // C·∫≠p nh·∫≠t chuy·ªÉn ƒë·ªïi t·ª´ hi·ªán t·∫°i
            if (displayBuffer.length > 0) {
                convertedCurrentWord = convertVietnameseWord(displayBuffer);
            } else {
                convertedCurrentWord = "";
            }
            
            // C·∫≠p nh·∫≠t chuy·ªÉn ƒë·ªïi to√†n b·ªô c√¢u
            if (fullSentence.length > 0) {
                convertedFullSentence = convertVietnameseText(fullSentence);
            } else {
                convertedFullSentence = "";
            }
            
            updateElement('convertedCurrentWord', convertedCurrentWord || '---');
            updateElement('convertedSentenceDisplay', convertedFullSentence || '---');
        }

        // ===========================================
        // H√ÄM X√ÇY D·ª∞NG C√ÇU
        // ===========================================

        function addWordToSentence() {
            if (!displayBuffer) return;
            
            if (sentenceWords.length < 10) {
                sentenceWords.push(displayBuffer);
                updateFullSentence();
                log('SENTENCE', `ƒê√£ th√™m t·ª´: '${displayBuffer}'`);
                
                // Hi·ªÉn th·ªã ƒë·ªÅ xu·∫•t t·ª± ƒë·ªông
                showAutoSuggestions();
                
                // X√≥a t·ª´ hi·ªán t·∫°i
                slot1 = '';
                slot2 = '';
                displayBuffer = '';
                convertedCurrentWord = '';
                
                updateUI();
            } else {
                log('SENTENCE', 'C√¢u ƒë√£ ƒë·∫ßy! ƒê·∫°t t·ªëi ƒëa 10 t·ª´.');
            }
        }

        function updateFullSentence() {
            fullSentence = sentenceWords.join(' ');
            convertedFullSentence = convertVietnameseText(fullSentence);
            
            updateElement('sentenceDisplay', fullSentence || '---');
            updateElement('convertedSentenceDisplay', convertedFullSentence || '---');
            updateElement('wordCount', sentenceWords.length);
            
            // C·∫≠p nh·∫≠t textarea d·ªãch thu·∫≠t
            document.getElementById('translationInput').value = convertedFullSentence || '';
        }

        function commitSentence() {
            if (sentenceWords.length === 0) {
                log('SENTENCE', 'Kh√¥ng c√≥ t·ª´ n√†o ƒë·ªÉ ho√†n th√†nh!');
                return;
            }
            
            if (displayBuffer) {
                addWordToSentence();
            }
            
            log('SENTENCE', '=== HO√ÄN TH√ÄNH C√ÇU ===');
            log('SENTENCE', `C√¢u ƒë·∫ßy ƒë·ªß: ${fullSentence}`);
            log('CONVERSION', `C√¢u ƒë√£ chuy·ªÉn ƒë·ªïi: ${convertedFullSentence}`);
            
            // ƒê·∫∑t l·∫°i c√¢u
            resetSentence();
        }

        function resetSentence() {
            sentenceWords = [];
            fullSentence = '';
            convertedFullSentence = '';
            slot1 = '';
            slot2 = '';
            displayBuffer = '';
            convertedCurrentWord = '';
            
            // ·∫®n ƒë·ªÅ xu·∫•t t·ª± ƒë·ªông
            document.getElementById('autoSuggestionsPanel').style.display = 'none';
            
            log('SENTENCE', 'C√¢u ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t l·∫°i');
            updateUI();
        }

        function clearCurrentWord() {
            slot1 = '';
            slot2 = '';
            displayBuffer = '';
            convertedCurrentWord = '';
            
            updateUI();
            log('WORD', 'T·ª´ hi·ªán t·∫°i ƒë√£ ƒë∆∞·ª£c x√≥a');
        }

        function backspaceBuffer() {
            if (displayBuffer.length > 0) {
                displayBuffer = displayBuffer.slice(0, -1);
                updateConversions();
            }
        }

        function backspace() {
            backspaceBuffer();
            updateUI();
        }

        // ===========================================
        // H√ÄM HI·ªÇN TH·ªä UI
        // ===========================================

        function updateUI() {
            // C·∫≠p nh·∫≠t c√°c ph·∫ßn t·ª≠ hi·ªÉn th·ªã
            updateElement('slot1', slot1 || '---');
            updateElement('slot2', slot2 || '---');
            updateElement('displayBuffer', displayBuffer || '---');
            updateElement('sentenceDisplay', fullSentence || '---');
            
            // C·∫≠p nh·∫≠t danh s√°ch t·ª´
            const wordListDiv = document.getElementById('wordList');
            if (sentenceWords.length > 0) {
                wordListDiv.innerHTML = sentenceWords.map(word => 
                    `<div class="word-item">${word}</div>`
                ).join('');
            } else {
                wordListDiv.innerHTML = 'Ch∆∞a c√≥ t·ª´ n√†o';
            }
            
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t gi·ªçng n√≥i
            const speakVnBtn = document.getElementById('speakVnBtn');
            const speakTransBtn = document.getElementById('speakTransBtn');
            const stopSpeechBtn = document.getElementById('stopSpeechBtn');
            
            speakVnBtn.disabled = !convertedFullSentence || isSpeaking;
            speakTransBtn.disabled = !document.getElementById('translationOutput').textContent || isSpeaking;
            stopSpeechBtn.disabled = !isSpeaking;
            
            if (isSpeaking) {
                speakVnBtn.classList.add('speaking');
            } else {
                speakVnBtn.classList.remove('speaking');
            }
            
            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã gi·ªçng n√≥i
            const langNames = {
                'vi-VN': 'Ti·∫øng Vi·ªát',
                'en-GB': 'Ti·∫øng Anh',
                'ja-JP': 'Ti·∫øng Nh·∫≠t',
                'ko-KR': 'Ti·∫øng H√†n',
                'zh-CN': 'Ti·∫øng Trung'
            };
            const genderNames = {
                'male': 'Nam',
                'female': 'N·ªØ'
            };
            const ttsMode = useGeminiTTS ? 'Gemini AI' : 'Web Speech';
            updateElement('currentVoiceDisplay', 
                `Hi·ªán t·∫°i: ${langNames[currentVoice.lang] || currentVoice.lang} ${genderNames[currentVoice.gender] || currentVoice.gender} (${ttsMode})`);
            
            // C·∫≠p nh·∫≠t n√∫t chuy·ªÉn ƒë·ªïi TTS
            document.getElementById('useGeminiTTS').classList.toggle('active', useGeminiTTS);
            document.getElementById('useWebSpeech').classList.toggle('active', !useGeminiTTS);
        }

        // ===========================================
        // H√ÄM LOG V√Ä TR·∫†NG TH√ÅI
        // ===========================================

        function log(source, message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = { timestamp, source, message };
            
            logEntries.unshift(logEntry);
            if (logEntries.length > MAX_LOG_ENTRIES) {
                logEntries.pop();
            }
            
            // C·∫≠p nh·∫≠t log display ngay l·∫≠p t·ª©c
            const logContainer = document.getElementById('logContainer');
            if (logContainer) {
                const newLog = `<div class="log-entry">
                    <span style="color: #666; font-size: 0.8rem;">[${timestamp}] ${source}:</span>
                    <span style="color: #333;"> ${message}</span>
                </div>`;
                
                // Gi·ªØ ch·ªâ 10 entries
                const currentHtml = logContainer.innerHTML;
                const logs = currentHtml.split('</div>').filter(l => l.trim());
                if (logs.length >= 10) {
                    logs.shift();
                }
                
                logContainer.innerHTML = [...logs, newLog].join('</div>') + '</div>';
                logContainer.scrollTop = logContainer.scrollHeight;
            }
        }

        function clearLog() {
            logEntries = [];
            const logContainer = document.getElementById('logContainer');
            if (logContainer) {
                logContainer.innerHTML = '<div class="log-entry">Nh·∫≠t k√Ω ƒë√£ ƒë∆∞·ª£c x√≥a</div>';
            }
        }

        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            
            if (connected) {
                indicator.className = 'indicator online';
                statusText.textContent = realtimeConnected ? 'ƒê√£ k·∫øt n·ªëi Firebase Realtime' : 'ƒê√£ k·∫øt n·ªëi Firebase REST';
                statusText.style.color = '#4CAF50';
            } else {
                indicator.className = 'indicator';
                statusText.textContent = 'M·∫•t k·∫øt n·ªëi - ƒêang th·ª≠ l·∫°i...';
                statusText.style.color = '#FF5722';
            }
        }

        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        // ===========================================
        // H√ÄM ƒê·ªÄ XU·∫§T V√Ä TTS
        // ===========================================

        function loadPhraseSuggestions() {
            const phrasePills = document.getElementById('phrasePills');
            phrasePills.innerHTML = '';
            
            commonPhrases.forEach(phrase => {
                const pill = document.createElement('button');
                pill.className = 'phrase-pill';
                pill.textContent = phrase.length > 30 ? phrase.substring(0, 27) + '...' : phrase;
                pill.onclick = () => {
                    document.getElementById('translationInput').value = phrase;
                    translateSentence();
                    log('PHRASE', `ƒê√£ ch·ªçn c·ª•m t·ª´: "${phrase}"`);
                };
                pill.title = phrase;
                phrasePills.appendChild(pill);
            });
        }

        function showAutoSuggestions() {
            if (sentenceWords.length === 0) {
                document.getElementById('autoSuggestionsPanel').style.display = 'none';
                return;
            }
            
            const currentSentence = convertedFullSentence.toLowerCase();
            const suggestionsDiv = document.getElementById('autoSuggestionsGrid');
            const panel = document.getElementById('autoSuggestionsPanel');
            
            const relevantPhrases = commonPhrases.filter(phrase => {
                const phraseLower = phrase.toLowerCase();
                return phraseLower.includes(currentSentence) && phraseLower !== currentSentence;
            });
            
            const displayPhrases = relevantPhrases.slice(0, 6);
            
            if (displayPhrases.length === 0) {
                panel.style.display = 'none';
                return;
            }
            
            suggestionsDiv.innerHTML = displayPhrases.map(phrase => `
                <div class="auto-suggestion-item">
                    <div class="auto-suggestion-text">${phrase}</div>
                    <div class="auto-suggestion-actions">
                        <button class="auto-suggestion-btn speak" onclick="speakSuggestion('${phrase}')">üîä ƒê·ªçc</button>
                        <button class="auto-suggestion-btn use" onclick="useSuggestion('${phrase}')">‚úì D√πng</button>
                        <button class="auto-suggestion-btn translate" onclick="translateSuggestion('${phrase}')">üåê D·ªãch</button>
                    </div>
                </div>
            `).join('');
            
            panel.style.display = 'block';
        }

        function speakSuggestion(text) {
            speakText(text, currentVoice.lang);
        }

        function useSuggestion(text) {
            const words = text.split(' ');
            sentenceWords = [];
            
            words.forEach(word => {
                if (sentenceWords.length < 10) {
                    sentenceWords.push(word);
                }
            });
            
            updateFullSentence();
            updateUI();
            
            document.getElementById('autoSuggestionsPanel').style.display = 'none';
            
            log('SUGGESTIONS', `ƒê√£ d√πng ƒë·ªÅ xu·∫•t: "${text}"`);
        }

        function translateSuggestion(text) {
            document.getElementById('translationInput').value = text;
            translateSentence();
        }

        function handleTranslationInput() {
            const input = document.getElementById('translationInput').value;
            const suggestionsDiv = document.getElementById('translationSuggestions');
            
            if (!input || input.trim().length === 0) {
                suggestionsDiv.innerHTML = '';
                suggestionsDiv.classList.remove('show');
                return;
            }
            
            const inputLower = input.toLowerCase();
            const filteredPhrases = commonPhrases.filter(phrase => 
                phrase.toLowerCase().includes(inputLower)
            );
            
            if (filteredPhrases.length > 0) {
                suggestionsDiv.innerHTML = filteredPhrases.map(phrase => `
                    <div class="suggestion-item" onclick="selectTranslationSuggestion('${phrase}')">
                        ${phrase}
                    </div>
                `).join('');
                suggestionsDiv.classList.add('show');
            } else {
                suggestionsDiv.innerHTML = '';
                suggestionsDiv.classList.remove('show');
            }
        }

        function selectTranslationSuggestion(phrase) {
            document.getElementById('translationInput').value = phrase;
            document.getElementById('translationSuggestions').innerHTML = '';
            document.getElementById('translationSuggestions').classList.remove('show');
            translateSentence();
        }

        // ===========================================
        // H√ÄM TTS V√Ä GI·ªåNG N√ìI
        // ===========================================

        function selectVoice(button) {
            const lang = button.getAttribute('data-lang');
            const gender = button.getAttribute('data-gender');
            
            currentVoice = { lang: lang, gender: gender };
            
            document.querySelectorAll('.voice-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            button.classList.add('active');
            
            updateUI();
            log('VOICE', `ƒê√£ ch·ªçn gi·ªçng: ${lang} ${gender}`);
        }

        function toggleTTSMode(useGemini) {
            useGeminiTTS = useGemini;
            updateUI();
            log('TTS', `ƒê√£ chuy·ªÉn sang ${useGemini ? 'Gemini AI' : 'Web Speech'} TTS`);
        }

        async function speakVietnameseSentence() {
            const text = convertedFullSentence || document.getElementById('convertedSentenceDisplay').textContent;
            if (!text || text === '---') {
                log('SPEECH', 'Kh√¥ng c√≥ vƒÉn b·∫£n ti·∫øng Vi·ªát ƒë·ªÉ ƒë·ªçc');
                return;
            }
            
            speakText(text, currentVoice.lang);
        }

        async function speakTranslation() {
            const text = document.getElementById('translationOutput').textContent;
            if (!text || text.includes('ƒêang ch·ªù d·ªãch') || text.includes('Vui l√≤ng nh·∫≠p')) {
                log('SPEECH', 'Kh√¥ng c√≥ vƒÉn b·∫£n d·ªãch ƒë·ªÉ ƒë·ªçc');
                return;
            }
            
            const lang = document.getElementById('voiceLanguage').value;
            speakText(text, lang);
        }

        async function speakText(text, langCode) {
            if (isSpeaking) {
                stopAllSpeech();
                return;
            }
            
            if (useGeminiTTS && GEMINI_API_KEY) {
                document.getElementById('aiSpeechStatus').style.display = 'flex';
                await speakWithGeminiTTS(text, langCode);
            } else {
                speakWithWebSpeech(text, langCode);
            }
        }

        // H√†m Gemini TTS
        async function speakWithGeminiTTS(text, langCode) {
            setIsSpeaking(true);
            startAudioVisualizer();
            
            const cacheKey = `${langCode}:${currentVoice.gender}:${text}`;
            
            try {
                if (audioCache[cacheKey]) {
                    playAudioFromCache(cacheKey, text);
                    return;
                }
                
                const voiceName = currentVoice.gender === 'male' ? 'Aoede' : 'Kore';
                const response = await fetch(
                    `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,
                    {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: text }] }],
                            generationConfig: {
                                responseModalities: ["AUDIO"],
                                speechConfig: {
                                    voiceConfig: { prebuiltVoiceConfig: { voiceName } },
                                },
                            },
                        }),
                    }
                );
                
                if (!response.ok) throw new Error(`API error: ${response.status}`);
                
                const data = await response.json();
                const inlineData = data.candidates?.[0]?.content?.parts?.[0]?.inlineData;
                
                if (!inlineData || !inlineData.data) {
                    throw new Error("No audio data");
                }
                
                // Chuy·ªÉn ƒë·ªïi PCM sang WAV
                const pcmToWav = (base64PCM, sampleRate = 24000) => {
                    try {
                        const binaryString = atob(base64PCM);
                        const len = binaryString.length;
                        const bytes = new Uint8Array(len);
                        for (let i = 0; i < len; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }

                        const wavHeader = new ArrayBuffer(44);
                        const view = new DataView(wavHeader);

                        const writeString = (view, offset, string) => {
                            for (let i = 0; i < string.length; i++) {
                                view.setUint8(offset + i, string.charCodeAt(i));
                            }
                        };

                        writeString(view, 0, "RIFF");
                        view.setUint32(4, 36 + len, true);
                        writeString(view, 8, "WAVE");
                        writeString(view, 12, "fmt ");
                        view.setUint32(16, 16, true);
                        view.setUint16(20, 1, true);
                        view.setUint16(22, 1, true);
                        view.setUint32(24, sampleRate, true);
                        view.setUint32(28, sampleRate * 2, true);
                        view.setUint16(32, 2, true);
                        view.setUint16(34, 16, true);
                        writeString(view, 36, "data");
                        view.setUint32(40, len, true);

                        return new Blob([wavHeader, bytes], { type: "audio/wav" });
                    } catch (error) {
                        console.error("L·ªói chuy·ªÉn ƒë·ªïi PCM sang WAV:", error);
                        return null;
                    }
                };
                
                const wavBlob = pcmToWav(inlineData.data, 24000);
                
                if (!wavBlob) throw new Error("Kh√¥ng th·ªÉ t·∫°o blob √¢m thanh");
                
                const audioUrl = URL.createObjectURL(wavBlob);
                audioCache[cacheKey] = audioUrl;
                
                document.getElementById('aiSpeechStatus').style.display = 'none';
                playAudio(audioUrl, text);
                
                log('SPEECH', `ƒêang ph√°t Gemini TTS: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`);
                
            } catch (error) {
                console.error('L·ªói Gemini TTS:', error);
                document.getElementById('aiSpeechStatus').style.display = 'none';
                log('SPEECH', `Gemini TTS th·∫•t b·∫°i: ${error.message}. Fallback v·ªÅ Web Speech.`);
                speakWithWebSpeech(text, langCode);
            }
        }

        function playAudioFromCache(cacheKey, text) {
            const audioUrl = audioCache[cacheKey];
            playAudio(audioUrl, text);
            log('SPEECH', `ƒêang ph√°t √¢m thanh t·ª´ b·ªô nh·ªõ ƒë·ªám`);
        }

        function playAudio(audioUrl, text) {
            const audio = new Audio(audioUrl);
            currentSpeech = audio;
            
            audio.onended = function() {
                setIsSpeaking(false);
                currentSpeech = null;
                stopAudioVisualizer();
                updateUI();
                log('SPEECH', 'ƒê√£ ƒë·ªçc xong');
            };
            
            audio.onerror = function(event) {
                console.error('L·ªói ph√°t √¢m thanh:', event);
                setIsSpeaking(false);
                currentSpeech = null;
                stopAudioVisualizer();
                updateUI();
                log('SPEECH', `L·ªói √¢m thanh: ${event.error}`);
            };
            
            audio.onplay = function() {
                setIsSpeaking(true);
                startAudioVisualizer();
                updateUI();
            };
            
            audio.play().catch(error => {
                console.error('Ph√°t √¢m thanh th·∫•t b·∫°i:', error);
                setIsSpeaking(false);
                currentSpeech = null;
                stopAudioVisualizer();
                updateUI();
            });
        }

        function speakWithWebSpeech(text, langCode) {
            if (isSpeaking) {
                stopAllSpeech();
                return;
            }
            
            if (!('speechSynthesis' in window)) {
                log('SPEECH', 'T·ªïng h·ª£p gi·ªçng n√≥i kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£');
                return;
            }
            
            window.speechSynthesis.cancel();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = langCode;
            utterance.rate = 0.9;
            utterance.pitch = currentVoice.gender === 'male' ? 0.8 : 1.2;
            utterance.volume = 1;
            
            const voices = speechSynthesis.getVoices();
            const targetVoice = voices.find(voice => 
                voice.lang === utterance.lang || 
                voice.lang.startsWith(utterance.lang.split('-')[0])
            );
            
            if (targetVoice) {
                utterance.voice = targetVoice;
            }
            
            utterance.onstart = function() {
                setIsSpeaking(true);
                updateUI();
                startAudioVisualizer();
                log('SPEECH', `ƒê√£ b·∫Øt ƒë·∫ßu Web Speech`);
            };
            
            utterance.onend = function() {
                setIsSpeaking(false);
                currentSpeech = null;
                stopAudioVisualizer();
                updateUI();
                log('SPEECH', 'ƒê√£ k·∫øt th√∫c Web Speech');
            };
            
            utterance.onerror = function(event) {
                setIsSpeaking(false);
                currentSpeech = null;
                stopAudioVisualizer();
                updateUI();
                log('SPEECH', `L·ªói Web Speech: ${event.error}`);
            };
            
            currentSpeech = utterance;
            window.speechSynthesis.speak(utterance);
        }

        function setIsSpeaking(speaking) {
            isSpeaking = speaking;
            updateUI();
        }

        function stopAllSpeech() {
            if (window.speechSynthesis) {
                window.speechSynthesis.cancel();
            }
            
            if (currentSpeech && currentSpeech.pause) {
                currentSpeech.pause();
                currentSpeech.currentTime = 0;
            }
            
            setIsSpeaking(false);
            currentSpeech = null;
            stopAudioVisualizer();
            updateUI();
            
            document.getElementById('aiSpeechStatus').style.display = 'none';
            
            log('SPEECH', 'ƒê√£ d·ª´ng ƒë·ªçc');
        }

        function startAudioVisualizer() {
            stopAudioVisualizer();
            
            const visualizer = document.getElementById('audioVisualizer');
            visualizer.innerHTML = '';
            
            for (let i = 0; i < 20; i++) {
                const bar = document.createElement('div');
                bar.className = 'audio-bar';
                bar.style.height = '5px';
                visualizer.appendChild(bar);
            }
            
            const bars = visualizer.querySelectorAll('.audio-bar');
            audioVisualizerInterval = setInterval(() => {
                bars.forEach(bar => {
                    const height = 5 + Math.random() * 35;
                    bar.style.height = `${height}px`;
                    bar.style.backgroundColor = `hsl(${120 + Math.random() * 60}, 70%, 50%)`;
                });
            }, 100);
        }

        function stopAudioVisualizer() {
            if (audioVisualizerInterval) {
                clearInterval(audioVisualizerInterval);
                audioVisualizerInterval = null;
            }
            
            const visualizer = document.getElementById('audioVisualizer');
            visualizer.innerHTML = '';
            
            for (let i = 0; i < 20; i++) {
                const bar = document.createElement('div');
                bar.className = 'audio-bar';
                bar.style.height = '5px';
                bar.style.backgroundColor = '#e0e0e0';
                visualizer.appendChild(bar);
            }
        }

        // ===========================================
        // H√ÄM D·ªäCH THU·∫¨T
        // ===========================================

        async function translateSentence() {
            const textarea = document.getElementById('translationInput');
            const text = textarea.value.trim();
            const targetLang = document.getElementById('targetLanguage').value;
            const outputDiv = document.getElementById('translationOutput');
            
            if (!text) {
                outputDiv.innerHTML = '<span style="color: #F44336;">Vui l√≤ng nh·∫≠p vƒÉn b·∫£n ƒë·ªÉ d·ªãch!</span>';
                outputDiv.className = 'conversion-display error';
                return;
            }
            
            const now = Date.now();
            if (now - lastTranslationTime < TRANSLATION_COOLDOWN) {
                outputDiv.innerHTML = '<span style="color: #FF9800;">Vui l√≤ng ƒë·ª£i tr∆∞·ªõc khi d·ªãch l·∫°i...</span>';
                outputDiv.className = 'conversion-display';
                return;
            }
            
            const cacheKey = text + '|' + targetLang;
            if (translationCache[cacheKey]) {
                outputDiv.innerHTML = translationCache[cacheKey];
                outputDiv.className = 'conversion-display success';
                lastTranslationTime = now;
                return;
            }
            
            outputDiv.innerHTML = '<span class="loading">ƒêang d·ªãch v·ªõi AI... ‚è≥</span>';
            outputDiv.className = 'conversion-display loading';
            
            try {
                const langMap = {
                    'en-GB': 'en',
                    'ja-JP': 'ja',
                    'ko-KR': 'ko',
                    'zh-CN': 'zh'
                };
                
                const langCode = langMap[targetLang] || 'en';
                const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=vi|${langCode}`);
                const data = await response.json();
                
                if (data.responseStatus === 200 && data.responseData) {
                    const translated = data.responseData.translatedText;
                    translationCache[cacheKey] = translated;
                    outputDiv.innerHTML = translated;
                    outputDiv.className = 'conversion-display success';
                    lastTranslationTime = Date.now();
                    log('TRANSLATION', `ƒê√£ d·ªãch sang ${targetLang}`);
                } else {
                    throw new Error('D·ªãch th·∫•t b·∫°i');
                }
            } catch (error) {
                console.error('L·ªói d·ªãch thu·∫≠t:', error);
                outputDiv.innerHTML = '<span style="color: #F44336;">D·ªãch v·ª• d·ªãch thu·∫≠t kh√¥ng kh·∫£ d·ª•ng. Vui l√≤ng th·ª≠ l·∫°i sau.</span>';
                outputDiv.className = 'conversion-display error';
            }
        }

        function clearTranslation() {
            document.getElementById('translationOutput').innerHTML = 'ƒêang ch·ªù d·ªãch...';
            document.getElementById('translationOutput').className = 'conversion-display';
            translationCache = {};
        }

        // ===========================================
        // H√ÄM ƒêI·ªÄU KHI·ªÇN
        // ===========================================

        function refreshData() {
            if (realtimeConnected && dataRef) {
                dataRef.once('value').then(snapshot => {
                    const data = snapshot.val();
                    if (data) {
                        debouncedUpdate(data);
                        log('SYSTEM', 'ƒê√£ l√†m m·ªõi d·ªØ li·ªáu th·ªß c√¥ng');
                    }
                });
            } else {
                // N·∫øu ƒëang d√πng REST, g·ªçi fetch tr·ª±c ti·∫øp
                const FIREBASE_URL = "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/sensorData.json";
                fetch(`${FIREBASE_URL}?t=${Date.now()}`)
                    .then(r => r.json())
                    .then(data => {
                        debouncedUpdate(data);
                        log('SYSTEM', 'ƒê√£ l√†m m·ªõi d·ªØ li·ªáu th·ªß c√¥ng (REST)');
                    });
            }
        }

        function toggleAutoRefresh() {
            // Trong phi√™n b·∫£n n√†y, ch√∫ng ta kh√¥ng t·∫Øt realtime
            // Nh∆∞ng c√≥ th·ªÉ t·∫Øt polling n·∫øu ƒëang d√πng
            if (!realtimeConnected) {
                location.reload(); // Reload ƒë·ªÉ th·ª≠ k·∫øt n·ªëi realtime l·∫°i
            }
        }

        function togglePerformanceMonitor() {
            performanceMonitorVisible = !performanceMonitorVisible;
            document.getElementById('perfMonitor').classList.toggle('visible', performanceMonitorVisible);
            log('SYSTEM', `Hi·ªáu su·∫•t monitor ${performanceMonitorVisible ? 'b·∫≠t' : 't·∫Øt'}`);
        }

        // ===========================================
        // KH·ªûI T·∫†O ·ª®NG D·ª§NG
        // ===========================================

        document.addEventListener('DOMContentLoaded', function() {
            log('SYSTEM', '·ª®ng d·ª•ng ƒë√£ kh·ªüi ƒë·ªông (ULTRA FAST MODE)');
            
            // Kh·ªüi t·∫°o lookup table cho chuy·ªÉn ƒë·ªïi Ti·∫øng Vi·ªát
            initVietnameseLookup();
            
            // Load phrase suggestions
            loadPhraseSuggestions();
            
            // Kh·ªüi t·∫°o Firebase Realtime
            initFirebaseRealtime();
            
            // Setup keyboard shortcut for performance monitor (Ctrl+Shift+P)
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && e.key === 'P') {
                    e.preventDefault();
                    togglePerformanceMonitor();
                }
            });
            
            // Auto-clear old logs
            setInterval(() => {
                const logContainer = document.getElementById('logContainer');
                if (logContainer) {
                    const logs = logContainer.innerHTML.split('</div>').filter(l => l.trim());
                    if (logs.length > 15) {
                        logContainer.innerHTML = logs.slice(-10).join('</div>') + '</div>';
                    }
                }
            }, 60000); // M·ªói ph√∫t d·ªçn d·∫πp
            
            log('SYSTEM', 'H·ªá th·ªëng t·ªëi ∆∞u hi·ªáu su·∫•t ƒë√£ s·∫µn s√†ng');
            
            // Initial UI update
            updateUI();
        });
    </script>
</body>
</html>
