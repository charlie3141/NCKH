<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gangtay — Auto Play (unlock + queue fix)</title>
<style>
  body{font-family:system-ui,Arial;padding:18px;max-width:900px;margin:auto}
  h1{font-size:1.3rem;margin-bottom:.2rem}
  .muted{color:#666;font-size:.9rem}
  label{display:block;margin-top:10px;font-weight:600}
  input[type="text"], input[type="url"]{width:100%;padding:8px;margin-top:6px;box-sizing:border-box}
  button{padding:10px 14px;margin:8px 6px;font-size:1rem}
  .row{display:flex;gap:8px;align-items:center;margin-top:8px}
  #status{margin-top:10px;color:#333}
  #log{white-space:pre-wrap;font-family:monospace;margin-top:10px;background:#f6f6f6;padding:8px;border-radius:6px;max-height:240px;overflow:auto}
  .controls{display:flex;gap:8px;align-items:center;margin-top:8px}
  small{color:#666}
</style>
</head>
<body>
  <h1>Gangtay — Auto Play (unlock + queue fix)</h1>
  <p class="muted">Tap <strong>Enable audio & Start</strong> once. If blocked, tap <strong>Manual Play</strong> to allow audio (plays a short beep). The page will poll Firebase and play /audio/0001.mp3 etc.</p>

  <label>1) T1.TXT (site root /T1.TXT or upload local)</label>
  <div class="row">
    <input type="file" id="fileInput" accept=".txt">
    <button id="reloadTxt">Try fetch /T1.TXT</button>
  </div>
  <div id="txtInfo" class="muted">Trying to fetch /T1.TXT ...</div>

  <label>2) Audio base path</label>
  <input id="audioBase" type="text" value="/audio/" />

  <label>3) Firebase message URL</label>
  <input id="firebaseUrl" type="url" value="https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json" />

  <div class="row">
    <button id="enableBtn">Enable audio & Start polling</button>
    <button id="stopBtn" disabled>Stop polling</button>
    <button id="previewBtn">Preview 0001</button>
  </div>

  <label>Volume (gain)</label>
  <div class="controls">
    <input id="gainSlider" type="range" min="0.2" max="4.0" step="0.05" value="1.2">
    <div id="gainVal">Gain x1.20</div>
  </div>

  <div id="status">Status: idle</div>
  <div id="log"></div>

<script>
/* Full page that:
 - unlocks audio via audible oscillator tone on user gesture
 - queues blocked plays and flushes after unlock
 - fallback: if media element not usable, fetch+decode audio and play buffer source
*/

// config
const FIREBASE_DEFAULT = "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json";
const POLL_INTERVAL_MS = 1000;

// ui
const fileInput = document.getElementById('fileInput');
const reloadTxtBtn = document.getElementById('reloadTxt');
const txtInfo = document.getElementById('txtInfo');
const audioBaseEl = document.getElementById('audioBase');
const firebaseUrlEl = document.getElementById('firebaseUrl');
const enableBtn = document.getElementById('enableBtn');
const stopBtn = document.getElementById('stopBtn');
const previewBtn = document.getElementById('previewBtn');
const gainSlider = document.getElementById('gainSlider');
const gainVal = document.getElementById('gainVal');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');

let lines = [];
let pollHandle = null;
let lastTs = null;
let audioCtx = null;
let masterGain = null;
let currentAudio = null;
let manualPlayBtn = null;
let pendingQueue = []; // array of {type:'index'|'text', value:...}

// helpers
function log(msg){ const t=new Date().toLocaleTimeString(); logEl.textContent=`[${t}] ${msg}\n`+logEl.textContent; }
function setStatus(s){ statusEl.textContent = 'Status: ' + s; log(s); }
function pad4(n){ return String(n).padStart(4,'0'); }

// T1.TXT load
async function fetchRemoteTxt(){
  setStatus('Fetching /T1.TXT ...');
  try{
    const r = await fetch('/T1.TXT', { cache: 'no-store' });
    if (!r.ok){ setStatus('/T1.TXT not found (HTTP ' + r.status + ')'); return false; }
    const txt = await r.text();
    parseTxt(txt);
    setStatus(`Loaded /T1.TXT (${lines.length} entries)`);
    return true;
  }catch(e){ setStatus('Fetch /T1.TXT failed: '+e.message); return false; }
}
function parseTxt(txt){ const raw=txt.split(/\r?\n/); lines = raw.map(l=>l.trim()).filter(l=>l.length>0); log('Parsed lines: '+lines.length); }

// local file input
fileInput.addEventListener('change', async (ev)=>{ const f=ev.target.files && ev.target.files[0]; if(!f) return; setStatus('Reading local file '+f.name); try{ const txt=await f.text(); parseTxt(txt); setStatus(`Loaded local ${f.name} (${lines.length} lines)`); }catch(e){ setStatus('Read failed: '+e.message); } });
reloadTxtBtn.addEventListener('click', fetchRemoteTxt);

// WebAudio & gain
function createAudioCtxIfNeeded(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = parseFloat(gainSlider.value || 1.0);
  masterGain.connect(audioCtx.destination);
  log('AudioContext created, gain=' + masterGain.gain.value.toFixed(2));
}
gainSlider.addEventListener('input', ()=>{ const v=parseFloat(gainSlider.value); gainVal.textContent = `Gain x${v.toFixed(2)}`; if(masterGain && audioCtx) masterGain.gain.setValueAtTime(v, audioCtx.currentTime); });

// unlock by playing a short tone (reliable on iOS/Android)
async function unlockWithTone() {
  try {
    createAudioCtxIfNeeded();
    // if already running
    if (audioCtx.state === 'running') return true;
    // use an oscillator for an audible short beep (user gesture must call this)
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    g.gain.value = 0.0001; // start very low
    osc.type = 'sine';
    osc.frequency.value = 880; // A5
    osc.connect(g);
    g.connect(masterGain);
    // ramp up quickly and down to avoid click
    const now = audioCtx.currentTime;
    g.gain.setValueAtTime(0.0001, now);
    g.gain.linearRampToValueAtTime(0.05, now + 0.01);
    osc.start(now);
    g.gain.linearRampToValueAtTime(0.0001, now + 0.22);
    osc.stop(now + 0.23);
    // resume context too
    try { await audioCtx.resume(); } catch(e){ /* ignore */ }
    // wait for stop
    await new Promise(r=>setTimeout(r, 300));
    log('unlockWithTone result: ' + audioCtx.state);
    return (audioCtx.state === 'running');
  } catch (e) {
    console.warn('unlockWithTone failed', e);
    return false;
  }
}

// create manual play button (if blocked)
function ensureManualPlayBtn(){
  if (manualPlayBtn) return manualPlayBtn;
  manualPlayBtn = document.createElement('button');
  manualPlayBtn.id = 'manualPlayBtn';
  manualPlayBtn.textContent = 'Manual Play (tap once)';
  manualPlayBtn.style.marginLeft = '8px';
  enableBtn.parentNode.insertBefore(manualPlayBtn, stopBtn);
  manualPlayBtn.addEventListener('click', async ()=>{
    setStatus('Manual Play tapped — unlocking with tone...');
    const ok = await unlockWithTone();
    if (ok) {
      setStatus('Unlocked (manual). Flushing queued plays...');
      await flushPending();
      manualPlayBtn.remove();
      manualPlayBtn = null;
    } else {
      setStatus('Still blocked — check site permissions.');
    }
  });
  return manualPlayBtn;
}

// play helpers
async function tryPlayElement(el){
  try {
    if (audioCtx && audioCtx.state === 'suspended') {
      try { await audioCtx.resume(); } catch(e){}
    }
    await el.play();
    return true;
  } catch (err) {
    console.warn('play rejected', err);
    return false;
  }
}

// try fetch+decode fallback (plays with AudioBufferSourceNode)
async function fetchAndPlayBuffer(url){
  try {
    createAudioCtxIfNeeded();
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) { throw new Error('Fetch failed status '+res.status); }
    const ab = await res.arrayBuffer();
    const audioBuf = await audioCtx.decodeAudioData(ab);
    const src = audioCtx.createBufferSource();
    src.buffer = audioBuf;
    src.connect(masterGain);
    // resume if needed
    if (audioCtx.state === 'suspended') try { await audioCtx.resume(); } catch(e){}
    src.start(0);
    // wait duration
    await new Promise(r => setTimeout(r, Math.max(500, audioBuf.duration*1000 + 100)));
    return true;
  } catch (e) {
    console.warn('fetchAndPlayBuffer failed', e);
    return false;
  }
}

// main play: try HTMLAudio element first, fallback to fetch+decode
async function playFileByIndex(idx){
  if (idx <= 0) { setStatus('Invalid index'); return; }
  const name = pad4(idx) + '.mp3';
  let base = audioBaseEl.value.trim() || '/audio/';
  if (!base.endsWith('/')) base += '/';
  const url = (base.startsWith('http') ? base : base) + name + '?ts=' + Date.now();
  setStatus('Play request: ' + name + ' → ' + url);
  try {
    // stop previous
    if (currentAudio) { try { currentAudio.pause(); currentAudio.src = ""; } catch(e){} currentAudio=null; }
    // try element
    const a = new Audio(url);
    a.crossOrigin = 'anonymous';
    currentAudio = a;
    const played = await tryPlayElement(a);
    if (played) {
      a.onended = ()=> setStatus('Finished ' + name);
      a.onerror = ()=> setStatus('Audio element error ' + name);
      return true;
    }
    // blocked: queue and show manual button
    setStatus('Play blocked by browser — queuing and showing Manual Play');
    pendingQueue.push({type:'index', value: idx});
    ensureManualPlayBtn();
    return false;
  } catch (err) {
    console.warn('play element exception', err);
    // fallback to fetch+decode attempt right away
    const ok = await fetchAndPlayBuffer(url);
    if (!ok) {
      setStatus('Play failed (both element and buffer). Queuing and showing Manual Play.');
      pendingQueue.push({type:'index', value: idx});
      ensureManualPlayBtn();
      return false;
    } else {
      setStatus('Played (fallback decode) ' + name);
      return true;
    }
  }
}

// find index by exact match (case-insensitive)
function findIndexForText(text){
  if (!text) return -1;
  const k = text.trim().toLowerCase();
  for (let i=0;i<lines.length;i++){
    if ((lines[i]||'').toLowerCase() === k) return i+1;
  }
  return -1;
}

// handle messages representing either {index:N,...} or {text:'...',...}
async function handleMessageObject(obj){
  if (!obj) return;
  if (typeof obj.index === 'number') {
    await playFileByIndex(obj.index);
    return;
  }
  const t = (typeof obj.text === 'string') ? obj.text : (typeof obj.message === 'string' ? obj.message : null);
  if (!t) return;
  const idx = findIndexForText(t);
  if (idx > 0) {
    await playFileByIndex(idx);
  } else {
    setStatus(`Text not found in T1.TXT: "${t}"`);
    log('Received text not found: ' + t);
    // optionally queue text for manual handling
    pendingQueue.push({type:'text', value: t});
    ensureManualPlayBtn();
  }
}

// flush pending queue (play sequentially)
async function flushPending(){
  while (pendingQueue.length > 0) {
    const item = pendingQueue.shift();
    if (item.type === 'index') {
      await playFileByIndex(item.value);
      // small gap between queued plays
      await new Promise(r=>setTimeout(r, 250));
    } else if (item.type === 'text') {
      const idx = findIndexForText(item.value);
      if (idx > 0) {
        await playFileByIndex(idx);
        await new Promise(r=>setTimeout(r, 250));
      } else {
        log('Queued text still not found: ' + item.value);
      }
    }
  }
}

// poll firebase once
async function pollOnce(){
  const url = firebaseUrlEl.value.trim() || FIREBASE_DEFAULT;
  try {
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) { setStatus('Firebase fetch failed: '+r.status); return; }
    const j = await r.json();
    const t = j && (j.ts || j.timestamp || JSON.stringify(j));
    if (!t) return;
    if (String(t) !== String(lastTs)) {
      lastTs = t;
      log('New firebase message: '+JSON.stringify(j));
      await handleMessageObject(j);
    }
  } catch (e) { console.warn('poll error', e); setStatus('Poll error: '+(e.message||e)); }
}

// control: enable/start
enableBtn.addEventListener('click', async ()=>{
  setStatus('Trying to enable (user gesture) — will attempt audible unlock...');
  const ok = await unlockWithTone();
  if (!ok) {
    setStatus('Audio still locked — showing Manual Play button and starting poll (playback blocked until manual unlock).');
    ensureManualPlayBtn();
    if (!pollHandle) { pollHandle = setInterval(pollOnce, POLL_INTERVAL_MS); setStatus('Polling started (blocked until unlock)'); enableBtn.disabled=true; stopBtn.disabled=false; }
    return;
  }
  // unlocked
  setStatus('Audio unlocked. Starting polling and flushing any pending plays.');
  if (!pollHandle) { pollHandle = setInterval(pollOnce, POLL_INTERVAL_MS); enableBtn.disabled=true; stopBtn.disabled=false; }
  // flush pending queue now unlocked
  await flushPending();
});

// stop
stopBtn.addEventListener('click', ()=>{ if (pollHandle) { clearInterval(pollHandle); pollHandle=null; setStatus('Polling stopped'); enableBtn.disabled=false; stopBtn.disabled=true; } });

// preview
previewBtn.addEventListener('click', ()=>{ createAudioCtxIfNeeded(); playFileByIndex(1); });

// init
(async function init(){
  firebaseUrlEl.value = firebaseUrlEl.value || FIREBASE_DEFAULT;
  const ok = await fetchRemoteTxt();
  if (!ok) txtInfo.textContent = '/T1.TXT not found on server — upload local file or add to site.';
  else txtInfo.textContent = `Loaded /T1.TXT (${lines.length} entries)`;
  setStatus('Ready. Click "Enable audio & Start polling" (one user gesture).');
})();
</script>
</body>
</html>
