<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gangtay — Debuggable Auto Play (full)</title>
<style>
  body{font-family:system-ui,Arial;padding:18px;max-width:980px;margin:auto}
  h1{font-size:1.2rem}
  .muted{color:#666;font-size:.9rem}
  label{display:block;margin-top:10px;font-weight:600}
  input[type="text"], input[type="url"]{width:100%;padding:8px;margin-top:6px;box-sizing:border-box}
  button{padding:10px 14px;margin:8px 6px;font-size:1rem}
  .row{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
  #status{margin-top:10px;color:#333}
  #log{white-space:pre-wrap;font-family:monospace;margin-top:10px;background:#f6f6f6;padding:10px;border-radius:6px;max-height:340px;overflow:auto}
  .bigManual{background:#ff4757;color:white;border:none;padding:12px 18px;font-weight:700;border-radius:6px}
  .controls{display:flex;gap:8px;align-items:center;margin-top:8px}
  small{color:#666}
</style>
</head>
<body>
  <h1>Gangtay — Auto Play + Debug</h1>
  <p class="muted">Tap <strong>Enable audio & Start polling</strong> once; if blocked, tap <strong>Manual Play</strong>. Use <strong>Debug fetch+decode</strong> to diagnose MP3 access / CORS / decode errors.</p>

  <label>1) T1.TXT (site root /T1.TXT or upload local)</label>
  <div class="row">
    <input type="file" id="fileInput" accept=".txt">
    <button id="reloadTxt">Try fetch /T1.TXT</button>
  </div>
  <div id="txtInfo" class="muted">Trying to fetch /T1.TXT ...</div>

  <label>2) Audio base path</label>
  <input id="audioBase" type="text" value="/audio/" />

  <label>3) Firebase message URL</label>
  <input id="firebaseUrl" type="url" value="https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json" />

  <div class="row">
    <button id="enableBtn">Enable audio & Start polling</button>
    <button id="stopBtn" disabled>Stop polling</button>
    <button id="previewBtn">Preview 0001</button>
    <button id="manualPlay" class="bigManual" style="display:none">Manual Play (tap once)</button>
  </div>

  <label>Volume (gain)</label>
  <div class="controls">
    <input id="gainSlider" type="range" min="0.2" max="4.0" step="0.05" value="1.2">
    <div id="gainVal">Gain x1.20</div>
  </div>

  <div style="margin-top:8px;">
    <label>Debug utilities</label>
    <div class="row">
      <!-- Change testFilename if you want to debug another file -->
      <input id="testFilename" type="text" value="0002.mp3" style="width:160px" />
      <button id="debugFetch">Debug: fetch+decode test (0002)</button>
      <button id="debugFetchCustom">Debug: fetch+decode custom</button>
      <button id="clearLog">Clear log</button>
    </div>
    <small>Debug test will fetch <code>/audio/&lt;filename&gt;</code> (with ?ts cache-bust) and attempt to decode+play it using AudioContext — results show in the log.</small>
  </div>

  <div id="status">Status: idle</div>
  <div id="log"></div>

<script>
/* Full debug page:
 - Polls Firebase for messages { index: N, ts: ... } or { text: "...", ts: ... }.
 - Performs robust unlock (tone + gesture), queues blocked plays, flushes after unlock.
 - Built-in Debug button will fetch and decode chosen mp3 and try to play it as AudioBuffer,
   logging HTTP status, bytes, decode duration, CORS errors, etc.
*/

// Config
const FIREBASE_DEFAULT = "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json";
const POLL_INTERVAL_MS = 1000;

// Elements
const fileInput = document.getElementById('fileInput');
const reloadTxtBtn = document.getElementById('reloadTxt');
const txtInfo = document.getElementById('txtInfo');
const audioBaseEl = document.getElementById('audioBase');
const firebaseUrlEl = document.getElementById('firebaseUrl');
const enableBtn = document.getElementById('enableBtn');
const stopBtn = document.getElementById('stopBtn');
const previewBtn = document.getElementById('previewBtn');
const manualBtn = document.getElementById('manualPlay');
const gainSlider = document.getElementById('gainSlider');
const gainVal = document.getElementById('gainVal');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
const debugFetchBtn = document.getElementById('debugFetch');
const debugFetchCustomBtn = document.getElementById('debugFetchCustom');
const testFilenameInput = document.getElementById('testFilename');
const clearLogBtn = document.getElementById('clearLog');

let lines = [];
let pollHandle = null;
let lastTs = null;
let audioCtx = null;
let masterGain = null;
let currentAudio = null;
let pendingQueue = [];
let unlocked = false;

// UTIL
function nowLabel(){ return new Date().toLocaleTimeString(); }
function log(msg){ logEl.textContent = `[${nowLabel()}] ${msg}\n` + logEl.textContent; }
function setStatus(s){ statusEl.textContent = 'Status: ' + s; log(s); }
function pad4(n){ return String(n).padStart(4,'0'); }

// T1.TXT handling
async function fetchRemoteTxt(){
  setStatus('Fetching /T1.TXT ...');
  try {
    const r = await fetch('/T1.TXT', { cache: 'no-store' });
    if (!r.ok) { setStatus('/T1.TXT not found (HTTP ' + r.status + ')'); return false; }
    const txt = await r.text();
    parseTxt(txt);
    setStatus(`Loaded /T1.TXT (${lines.length} entries)`);
    return true;
  } catch (e) {
    setStatus('Fetch /T1.TXT failed: ' + e.message);
    return false;
  }
}
function parseTxt(txt){
  const raw = txt.split(/\r?\n/);
  lines = raw.map(l => l.trim()).filter(l => l.length > 0);
  log('Parsed lines: '+lines.length);
}
fileInput.addEventListener('change', async(ev)=> {
  const f = ev.target.files && ev.target.files[0];
  if(!f) return;
  setStatus('Reading local file '+f.name);
  try {
    const t = await f.text();
    parseTxt(t);
    setStatus(`Loaded local ${f.name} (${lines.length} lines)`);
  } catch(e) {
    setStatus('Read failed: '+e.message);
  }
});
reloadTxtBtn.addEventListener('click', fetchRemoteTxt);

// WebAudio + gain
function createAudioCtxIfNeeded(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = parseFloat(gainSlider.value || 1.0);
  masterGain.connect(audioCtx.destination);
  log('AudioContext created, gain=' + masterGain.gain.toFixed(2));
}
gainSlider.addEventListener('input', ()=> {
  const v = parseFloat(gainSlider.value);
  gainVal.textContent = `Gain x${v.toFixed(2)}`;
  if (masterGain && audioCtx) masterGain.gain.setValueAtTime(v, audioCtx.currentTime);
});

// Unlock strategies
async function unlockWithTone(){
  try {
    createAudioCtxIfNeeded();
    if (audioCtx.state === 'running') { unlocked = true; return true; }
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = 880;
    g.gain.value = 0.0001;
    osc.connect(g); g.connect(masterGain);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.linearRampToValueAtTime(0.08, now + 0.01);
    osc.start(now);
    g.gain.linearRampToValueAtTime(0.0001, now + 0.18);
    osc.stop(now + 0.19);
    try { await audioCtx.resume(); } catch(e){}
    await new Promise(r=>setTimeout(r, 250));
    if (audioCtx.state === 'running') { unlocked = true; log('Unlocked (tone)'); return true; }
    log('unlockWithTone result: ' + audioCtx.state);
    return false;
  } catch(e){ console.warn('unlockWithTone err', e); return false; }
}
async function unlockWithHtmlAudio(){
  try{
    createAudioCtxIfNeeded();
    const a = new Audio();
    a.muted = true;
    try { await a.play(); } catch(e){}
    await new Promise(r=>setTimeout(r, 50));
    if (audioCtx && audioCtx.state === 'running') { unlocked = true; log('Unlocked (html audio)'); return true; }
    return false;
  } catch(e){ console.warn('unlockWithHtmlAudio err', e); return false; }
}
async function tryUnlockSequence(){
  if (unlocked) return true;
  if (await unlockWithTone()) return true;
  if (await unlockWithHtmlAudio()) return true;
  return false;
}

// Manual button UI
function showManual(){
  manualBtn.style.display = 'inline-block';
  manualBtn.focus();
}
function hideManual(){
  manualBtn.style.display = 'none';
}

// Create audio element and connect to WebAudio if possible
function makeAudioElement(url){
  createAudioCtxIfNeeded();
  const a = new Audio(url);
  a.crossOrigin = "anonymous";
  try {
    if (currentAudio && currentAudio._mediaSource) try { currentAudio._mediaSource.disconnect(); } catch(e){}
    const ms = audioCtx.createMediaElementSource(a);
    ms.connect(masterGain);
    a._mediaSource = ms;
  } catch(e) {
    console.warn('makeAudioElement connect failed', e);
    a.volume = Math.min(1.0, parseFloat(gainSlider.value || 1.0));
  }
  return a;
}
async function tryPlayElement(el){
  try {
    if (audioCtx && audioCtx.state === 'suspended') try { await audioCtx.resume(); } catch(e){}
    await el.play();
    return true;
  } catch(e) {
    console.warn('play rejected', e);
    return false;
  }
}

// fallback decode
async function fetchAndPlayBuffer(url){
  try {
    createAudioCtxIfNeeded();
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) throw new Error('fetch status '+r.status);
    const ab = await r.arrayBuffer();
    const buf = await audioCtx.decodeAudioData(ab);
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    src.connect(masterGain);
    if (audioCtx.state === 'suspended') try { await audioCtx.resume(); } catch(e){}
    src.start(0);
    await new Promise(r=>setTimeout(r, Math.max(300, buf.duration*1000 + 100)));
    return true;
  } catch(e){ console.warn('fetchAndPlayBuffer failed', e); return false; }
}

// main play
async function playFileByIndex(idx){
  if (idx <= 0) { setStatus('Invalid index'); return; }
  const name = pad4(idx) + '.mp3';
  let base = audioBaseEl.value.trim() || '/audio/';
  if (!base.endsWith('/')) base += '/';
  const url = (base.startsWith('http') ? base : base) + name + '?ts=' + Date.now();
  setStatus('Play request: ' + name + ' → ' + url);
  try {
    if (currentAudio) { try { currentAudio.pause(); currentAudio.src=""; } catch(e){} currentAudio = null; }
    const a = makeAudioElement(url);
    currentAudio = a;
    const ok = await tryPlayElement(a);
    if (ok) {
      a.onended = ()=> setStatus('Finished ' + name);
      a.onerror = ()=> setStatus('Audio element error ' + name);
      return true;
    }
    setStatus('Play blocked — queued & show Manual Play');
    pendingQueue.push({type:'index', value: idx});
    showManual();
    return false;
  } catch(e) {
    console.warn('play exception', e);
    const ok2 = await fetchAndPlayBuffer(url);
    if (!ok2) {
      setStatus('Play failed (both). Queued & show Manual Play');
      pendingQueue.push({type:'index', value: idx});
      showManual();
      return false;
    } else {
      setStatus('Played via buffer ' + name);
      return true;
    }
  }
}

// find index by text
function findIndexForText(text){
  if (!text) return -1;
  const k = text.trim().toLowerCase();
  for (let i=0;i<lines.length;i++){
    if ((lines[i]||'').toLowerCase() === k) return i+1;
  }
  return -1;
}

async function handleMessageObject(obj){
  if (!obj) return;
  if (typeof obj.index === 'number') { await playFileByIndex(obj.index); return; }
  const t = (typeof obj.text === 'string') ? obj.text : (typeof obj.message === 'string' ? obj.message : null);
  if (!t) return;
  const idx = findIndexForText(t);
  if (idx > 0) await playFileByIndex(idx);
  else {
    setStatus('Text not found in T1.TXT: "' + t + '"');
    log('Not found: ' + t);
    pendingQueue.push({type:'text', value: t});
    showManual();
  }
}

async function flushPending(){
  while (pendingQueue.length > 0) {
    const item = pendingQueue.shift();
    if (item.type === 'index') {
      await playFileByIndex(item.value);
      await new Promise(r=>setTimeout(r,250));
    } else {
      const idx = findIndexForText(item.value);
      if (idx > 0) { await playFileByIndex(idx); await new Promise(r=>setTimeout(r,250)); }
      else log('Queued text still not found: '+item.value);
    }
  }
}

// Polling
async function pollOnce(){
  const url = firebaseUrlEl.value.trim() || FIREBASE_DEFAULT;
  try {
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) { setStatus('Firebase fetch failed: '+r.status); return; }
    const j = await r.json();
    const t = j && (j.ts || j.timestamp || JSON.stringify(j));
    if (!t) return;
    if (String(t) !== String(lastTs)) {
      lastTs = t;
      log('New firebase message: ' + JSON.stringify(j));
      await handleMessageObject(j);
    }
  } catch(e){ console.warn('poll error', e); setStatus('Poll error: '+(e.message||e)); }
}

// Enable / event wiring
enableBtn.addEventListener('click', async ()=>{
  setStatus('Enable pressed — attempting audible unlock...');
  // listen for general page taps as unlock too
  document.addEventListener('touchstart', firstGesture, {passive:true});
  document.addEventListener('click', firstGesture);
  const ok = await tryUnlockSequence();
  if (!ok) {
    setStatus('Audio locked — please tap Manual Play or tap anywhere on page once');
    showManual();
    if (!pollHandle) { pollHandle = setInterval(pollOnce, POLL_INTERVAL_MS); setStatus('Polling started (playback blocked until unlock)'); enableBtn.disabled=true; stopBtn.disabled=false; }
    return;
  }
  setStatus('Unlocked — starting poll & flushing queue.');
  if (!pollHandle) { pollHandle = setInterval(pollOnce, POLL_INTERVAL_MS); enableBtn.disabled=true; stopBtn.disabled=false; }
  await flushPending();
});
stopBtn.addEventListener('click', ()=> { if (pollHandle) { clearInterval(pollHandle); pollHandle=null; setStatus('Polling stopped'); enableBtn.disabled=false; stopBtn.disabled=true; } });

// preview 0001
previewBtn.addEventListener('click', ()=> { createAudioCtxIfNeeded(); playFileByIndex(1); });

// manual button taps
manualBtn.addEventListener('click', async ()=> {
  setStatus('Manual Play tapped — attempting unlock...');
  const ok = await tryUnlockSequence();
  if (ok) { setStatus('Unlocked (manual). Flushing queued plays...'); hideManual(); await flushPending(); }
  else setStatus('Unlock failed — try tapping the page or check permissions.');
});

// first gesture listener
function firstGesture(e){
  document.removeEventListener('touchstart', firstGesture, {passive:true});
  document.removeEventListener('click', firstGesture);
  log('Detected page gesture — attempting unlock');
  tryUnlockSequence().then(ok=>{
    if (ok) { setStatus('Unlocked via gesture. Flushing queue...'); hideManual(); flushPending().catch(e=>console.warn(e)); }
    else { setStatus('Gesture did not unlock; press Manual Play'); showManual(); }
  });
}

// Debug fetch+decode test (uses AudioContext decodeAudioData and plays buffer)
async function debugFetchDecodeOnce(filename) {
  const base = audioBaseEl.value.trim() || '/audio/';
  const name = filename || testFilenameInput.value || '0002.mp3';
  let baseWithSlash = base;
  if (!baseWithSlash.endsWith('/')) baseWithSlash = baseWithSlash + '/';
  // if base is relative (starts with /) keep as-is; if absolute http(s) also keep
  const url = (baseWithSlash.startsWith('http') ? baseWithSlash : baseWithSlash) + name + '?ts=' + Date.now();
  log('Debug test fetch -> ' + url);
  try {
    const r = await fetch(url, { cache: 'no-store' });
    log('HTTP status: ' + r.status);
    if (!r.ok) { log('Fetch failed with status ' + r.status); return; }
    const ab = await r.arrayBuffer();
    log('Fetched bytes: ' + ab.byteLength);
    createAudioCtxIfNeeded();
    try { await audioCtx.resume(); } catch(e){ log('audioCtx.resume() failed: '+e); }
    let buf;
    try {
      buf = await audioCtx.decodeAudioData(ab);
      log('Decoded audio duration (s): ' + buf.duration.toFixed(3));
    } catch(decodeErr) {
      log('decodeAudioData failed: ' + (decodeErr && decodeErr.message ? decodeErr.message : decodeErr));
      console.warn('decode error', decodeErr);
      return;
    }
    // play buffer
    const src = audioCtx.createBufferSource();
    const g = audioCtx.createGain();
    g.gain.value = parseFloat(gainSlider.value || 1.0);
    src.buffer = buf;
    src.connect(g); g.connect(audioCtx.destination);
    try {
      src.start();
      log('Playback started via AudioBufferSourceNode (debug)');
    } catch(playErr) {
      log('Playback start failed: ' + (playErr && playErr.message ? playErr.message : playErr));
      console.warn('playErr', playErr);
    }
  } catch(err) {
    log('Fetch/Decode test error: ' + (err && err.message ? err.message : err));
    console.error(err);
  }
}

// debug button hooks
debugFetchBtn.addEventListener('click', ()=> debugFetchDecodeOnce('0002.mp3'));
debugFetchCustomBtn.addEventListener('click', ()=> {
  const fname = testFilenameInput.value.trim() || '0002.mp3';
  debugFetchDecodeOnce(fname);
});
clearLogBtn.addEventListener('click', ()=> logEl.textContent = '');

// init
(async function init() {
  firebaseUrlEl.value = firebaseUrlEl.value || FIREBASE_DEFAULT;
  const ok = await fetchRemoteTxt();
  if (!ok) txtInfo.textContent = '/T1.TXT not found on server — upload local file or add to site.';
  else txtInfo.textContent = `Loaded /T1.TXT (${lines.length} entries)`;
  setStatus('Ready. Click Enable or tap the page when queued plays appear.');
})();

</script>
</body>
</html>
