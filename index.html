<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gangtay — Replay control + stable auto play</title>
<style>
  body{font-family:system-ui,Arial;padding:18px;max-width:980px;margin:auto}
  h1{font-size:1.2rem}
  .muted{color:#666;font-size:.9rem}
  label{display:block;margin-top:10px;font-weight:600}
  input[type="text"], input[type="url"], input[type="number"]{width:100%;padding:8px;margin-top:6px;box-sizing:border-box}
  button{padding:10px 14px;margin:8px 6px;font-size:1rem}
  .row{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
  #status{margin-top:10px;color:#333}
  #log{white-space:pre-wrap;font-family:monospace;margin-top:10px;background:#f6f6f6;padding:10px;border-radius:6px;max-height:340px;overflow:auto}
  .bigManual{background:#ff4757;color:white;border:none;padding:12px 18px;font-weight:700;border-radius:6px}
  .controls{display:flex;gap:8px;align-items:center;margin-top:8px}
  .inline {display:inline-flex;gap:8px;align-items:center}
  small{color:#666}
  .setting {margin-right:12px;}
</style>
</head>
<body>
  <h1>Gangtay — Replay control + stable auto play</h1>
  <p class="muted">Controls let you decide whether identical messages should replay. Tap <strong>Enable audio & Start polling</strong> once; if blocked, tap <strong>Manual Play</strong>.</p>

  <label>1) T1.TXT (site root /T1.TXT or upload local)</label>
  <div class="row">
    <input type="file" id="fileInput" accept=".txt">
    <button id="reloadTxt">Try fetch /T1.TXT</button>
  </div>
  <div id="txtInfo" class="muted">Trying to fetch /T1.TXT ...</div>

  <label>2) Audio base path</label>
  <input id="audioBase" type="text" value="/audio/" />

  <label>3) Firebase message URL</label>
  <input id="firebaseUrl" type="url" value="https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json" />

  <div class="row">
    <button id="enableBtn">Enable audio & Start polling</button>
    <button id="stopBtn" disabled>Stop polling</button>
    <button id="previewBtn">Preview 0001</button>
    <button id="manualPlay" class="bigManual" style="display:none">Manual Play (tap once)</button>
  </div>

  <label>Playback behavior</label>
  <div class="row">
    <div class="setting inline"><input id="allowReplay" type="checkbox"><label for="allowReplay">Allow replay of same payload</label></div>
    <div class="setting inline"><label style="font-weight:600">Replay cooldown (s)</label>
      <input id="replayCooldown" type="number" min="0" value="10" style="width:120px" />
    </div>
    <div class="setting inline"><small>Set cooldown to 0 and uncheck "Allow replay" to prevent replays entirely; set cooldown to desired seconds to allow same payload after that interval.</small></div>
  </div>

  <label>Volume (gain)</label>
  <div class="controls">
    <input id="gainSlider" type="range" min="0.2" max="4.0" step="0.05" value="1.2">
    <div id="gainVal">Gain x1.20</div>
  </div>

  <div style="margin-top:8px;">
    <label>Debug utilities</label>
    <div class="row">
      <input id="testFilename" type="text" value="0002.mp3" style="width:160px" />
      <button id="debugFetch">Debug: fetch+decode test (0002)</button>
      <button id="debugFetchCustom">Debug: fetch+decode custom</button>
      <button id="clearLog">Clear log</button>
      <button id="clearQueue">Clear queue</button>
    </div>
    <small>Debug will fetch <code>/audio/&lt;filename&gt;</code> and try decode+play. Clear queue removes queued plays.</small>
  </div>

  <div id="status">Status: idle</div>
  <div id="log"></div>

<script>
/* Stable Auto Play with replay control
 - New settings: Allow replay checkbox and Replay cooldown (seconds)
 - Dedup logic honors those settings:
    * if allowReplay === true => always process new incoming payloads (regardless of content)
    * else: compare payload key to lastPlayTimes; if lastPlayTimes[key] is older than cooldown => allow play; otherwise ignore
 - Logging suppressed to avoid spam: first suppressed event logged, then heartbeat logs every 30s if repeats continue
 - Rest: robust unlocking, queue/flush, fetch+decode debug preserved
*/

const FIREBASE_DEFAULT = "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json";
const POLL_INTERVAL_MS = 1000;
const SUPPRESS_HEARTBEAT_MS = 30000; // when duplicate suppressed, log heartbeat at most every 30s

// UI
const fileInput = document.getElementById('fileInput');
const reloadTxtBtn = document.getElementById('reloadTxt');
const txtInfo = document.getElementById('txtInfo');
const audioBaseEl = document.getElementById('audioBase');
const firebaseUrlEl = document.getElementById('firebaseUrl');
const enableBtn = document.getElementById('enableBtn');
const stopBtn = document.getElementById('stopBtn');
const previewBtn = document.getElementById('previewBtn');
const manualBtn = document.getElementById('manualPlay');
const allowReplayBox = document.getElementById('allowReplay');
const replayCooldownInput = document.getElementById('replayCooldown');
const gainSlider = document.getElementById('gainSlider');
const gainVal = document.getElementById('gainVal');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
const debugFetchBtn = document.getElementById('debugFetch');
const debugFetchCustomBtn = document.getElementById('debugFetchCustom');
const testFilenameInput = document.getElementById('testFilename');
const clearLogBtn = document.getElementById('clearLog');
const clearQueueBtn = document.getElementById('clearQueue');

let lines = [];
let pollHandle = null;
let audioCtx = null;
let masterGain = null;
let currentAudio = null;
let pendingQueue = [];
let pendingSet = new Set();
let lastPlayTimes = {}; // key -> timestamp(ms) last actually played
let lastSuppressLog = {}; // key -> timestamp(ms) last suppression log time
let unlocked = false;

// utilities
function nowLabel(){ return new Date().toLocaleTimeString(); }
function log(msg){ logEl.textContent = `[${nowLabel()}] ${msg}\n` + logEl.textContent; }
function setStatus(s){ statusEl.textContent = 'Status: ' + s; log(s); }
function pad4(n){ return String(n).padStart(4,'0'); }

// T1.TXT
async function fetchRemoteTxt(){
  setStatus('Fetching /T1.TXT ...');
  try {
    const r = await fetch('/T1.TXT', { cache: 'no-store' });
    if (!r.ok) { setStatus('/T1.TXT not found (HTTP ' + r.status + ')'); return false; }
    const txt = await r.text();
    parseTxt(txt);
    setStatus(`Loaded /T1.TXT (${lines.length} entries)`);
    return true;
  } catch (e) {
    setStatus('Fetch /T1.TXT failed: ' + e.message);
    return false;
  }
}
function parseTxt(txt){
  const raw = txt.split(/\r?\n/);
  lines = raw.map(l=>l.trim()).filter(l=>l.length>0);
  log('Parsed lines: ' + lines.length);
}
fileInput.addEventListener('change', async(ev)=>{ const f=ev.target.files && ev.target.files[0]; if(!f) return; setStatus('Reading local ' + f.name); try{ const t = await f.text(); parseTxt(t); setStatus('Loaded local '+f.name+' ('+lines.length+' lines)'); }catch(e){ setStatus('Read failed: '+e.message); }});
reloadTxtBtn.addEventListener('click', fetchRemoteTxt);

// audio + gain
function createAudioCtxIfNeeded(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = parseFloat(gainSlider.value || 1.0);
  masterGain.connect(audioCtx.destination);
  log('AudioContext created, gain=' + masterGain.gain.toFixed(2));
}
gainSlider.addEventListener('input', ()=>{ const v = parseFloat(gainSlider.value); gainVal.textContent = `Gain x${v.toFixed(2)}`; if(masterGain && audioCtx) masterGain.gain.setValueAtTime(v, audioCtx.currentTime); });

// unlock helpers
async function unlockWithTone(){
  try {
    createAudioCtxIfNeeded();
    if (audioCtx.state === 'running') { unlocked = true; return true; }
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'sine'; osc.frequency.value = 880;
    g.gain.value = 0.0001;
    osc.connect(g); g.connect(masterGain);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.linearRampToValueAtTime(0.08, now + 0.01);
    osc.start(now);
    g.gain.linearRampToValueAtTime(0.0001, now + 0.18);
    osc.stop(now + 0.19);
    try { await audioCtx.resume(); } catch(e){}
    await new Promise(r => setTimeout(r, 250));
    if (audioCtx.state === 'running') { unlocked = true; log('Unlocked (tone)'); return true; }
    log('unlockWithTone: state=' + audioCtx.state);
    return false;
  } catch(e){ console.warn('unlockWithTone err', e); return false; }
}
async function unlockWithHtmlAudio(){
  try {
    createAudioCtxIfNeeded();
    const a = new Audio();
    a.muted = true;
    try { await a.play(); } catch(e){}
    await new Promise(r => setTimeout(r, 50));
    if (audioCtx && audioCtx.state === 'running') { unlocked = true; log('Unlocked (html audio)'); return true; }
    return false;
  } catch(e){ console.warn('unlockWithHtmlAudio err', e); return false; }
}
async function tryUnlockSequence(){
  if (unlocked) return true;
  if (await unlockWithTone()) return true;
  if (await unlockWithHtmlAudio()) return true;
  return false;
}

// create element/connect
function makeAudioElement(url){
  createAudioCtxIfNeeded();
  const a = new Audio(url);
  a.crossOrigin = 'anonymous';
  try {
    if (currentAudio && currentAudio._mediaSource) try { currentAudio._mediaSource.disconnect(); } catch(e){}
    const ms = audioCtx.createMediaElementSource(a);
    ms.connect(masterGain);
    a._mediaSource = ms;
  } catch(e) {
    console.warn('createMediaElementSource failed', e);
    a.volume = Math.min(1.0, parseFloat(gainSlider.value || 1.0));
  }
  return a;
}
async function tryPlayElement(el){
  try {
    if (audioCtx && audioCtx.state === 'suspended') try { await audioCtx.resume(); } catch(e){}
    await el.play();
    return true;
  } catch(e) {
    console.warn('play rejected', e);
    return false;
  }
}
async function fetchAndPlayBuffer(url){
  try {
    createAudioCtxIfNeeded();
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) throw new Error('fetch status ' + r.status);
    const ab = await r.arrayBuffer();
    const buf = await audioCtx.decodeAudioData(ab);
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    src.connect(masterGain);
    if (audioCtx.state === 'suspended') try { await audioCtx.resume(); } catch(e){}
    src.start(0);
    await new Promise(r => setTimeout(r, Math.max(300, buf.duration*1000 + 100)));
    return true;
  } catch(e) { console.warn('fetchAndPlayBuffer failed', e); return false; }
}

// payload key
function makePayloadKey(obj) {
  if (!obj) return null;
  if (typeof obj.index === 'number') return 'i:' + obj.index;
  const t = (typeof obj.text === 'string') ? obj.text : (typeof obj.message === 'string' ? obj.message : null);
  if (t) return 't:' + t.trim().toLowerCase();
  return null;
}

// decide whether to accept and play a payload now based on settings and lastPlayTimes
function shouldPlayPayload(key) {
  if (!key) return false;
  // allowReplay box overrides cooldown entirely
  if (allowReplayBox.checked) return true;
  const cooldownSec = Math.max(0, Number(replayCooldownInput.value) || 0);
  if (cooldownSec === 0) {
    // cooldown 0 means "do not replay same payload"
    const played = !!lastPlayTimes[key];
    if (played) return false;
    return true; // not played before
  } else {
    const last = lastPlayTimes[key] || 0;
    const now = Date.now();
    if (now - last >= cooldownSec * 1000) return true;
    // within cooldown -> suppressed
    return false;
  }
}

// log suppression: only log first suppression then at most every SUPPRESS_HEARTBEAT_MS
const SUPPRESS_HEARTBEAT_MS = 30000;
function logSuppressed(key) {
  const now = Date.now();
  const last = lastSuppressLog[key] || 0;
  if (!last) {
    log('Ignored duplicate payload content: ' + key);
    lastSuppressLog[key] = now;
    return;
  }
  if (now - last >= SUPPRESS_HEARTBEAT_MS) {
    log('Still receiving duplicate payload: ' + key + ' (suppressed)');
    lastSuppressLog[key] = now;
  }
}

// queue with dedupe
function queuePayload(key, type, value) {
  if (pendingSet.has(key)) {
    log('Payload already queued (skip): ' + key);
    return;
  }
  pendingQueue.push({key, type, value});
  pendingSet.add(key);
  log('Queued payload: ' + key);
  showManual();
}

// main play function
async function playFileByIndex(idx) {
  if (idx <= 0) { setStatus('Invalid index'); return false; }
  const name = pad4(idx) + '.mp3';
  let base = audioBaseEl.value.trim() || '/audio/';
  if (!base.endsWith('/')) base += '/';
  const url = (base.startsWith('http') ? base : base) + name + '?ts=' + Date.now();
  setStatus('Play request: ' + name + ' → ' + url);
  try {
    if (currentAudio) { try { currentAudio.pause(); currentAudio.src=""; } catch(e){} currentAudio=null; }
    const a = makeAudioElement(url);
    currentAudio = a;
    const ok = await tryPlayElement(a);
    if (ok) {
      a.onended = ()=> { setStatus('Finished ' + name); };
      a.onerror = ()=> { setStatus('Audio element error ' + name); };
      // record play time
      lastPlayTimes['i:' + idx] = Date.now();
      // clear any suppression marker for this key
      lastSuppressLog['i:' + idx] = 0;
      return true;
    }
    // blocked -> queue with dedupe
    const key = 'i:' + idx;
    queuePayload(key, 'index', idx);
    return false;
  } catch(e) {
    console.warn('play exception', e);
    const ok2 = await fetchAndPlayBuffer(url);
    if (!ok2) {
      const key = 'i:' + idx;
      queuePayload(key, 'index', idx);
      return false;
    } else {
      lastPlayTimes['i:' + idx] = Date.now();
      lastSuppressLog['i:' + idx] = 0;
      setStatus('Played via buffer ' + name);
      return true;
    }
  }
}

// find index by text
function findIndexForText(text){
  if (!text) return -1;
  const k = text.trim().toLowerCase();
  for (let i=0;i<lines.length;i++){
    if ((lines[i]||'').toLowerCase() === k) return i+1;
  }
  return -1;
}

// high-level handler
async function handleMessageObject(obj){
  if (!obj) return;
  const key = makePayloadKey(obj);
  if (!key) return;
  // check whether to play now or suppress based on settings
  const willPlay = shouldPlayPayload(key);
  if (!willPlay) {
    // suppressed: log but not spam
    logSuppressed(key);
    return;
  }
  // if it should play now and not already queued/playing, dispatch
  if (key.startsWith('i:')) {
    const idx = parseInt(key.slice(2),10);
    // attempt direct play; if blocked, queue
    const ok = await playFileByIndex(idx);
    if (ok) {
      // record time done in playFileByIndex
    } else {
      // playFileByIndex already queued on block
    }
    return;
  }
  // text case: lookup index
  const text = obj.text || obj.message || '';
  const idx = findIndexForText(text);
  if (idx > 0) {
    const ok = await playFileByIndex(idx);
    if (!ok) {
      // queued inside playFileByIndex
    }
  } else {
    // not found -> queue for manual handling (dedupe queue)
    const k = 't:' + text.trim().toLowerCase();
    if (!pendingSet.has(k)) {
      pendingQueue.push({key:k, type:'text', value:text});
      pendingSet.add(k);
      log('Text not found, queued for manual handling: ' + text);
      showManual();
    } else {
      log('Text already queued (skip): ' + text);
    }
  }
}

// flush queue sequentially
async function flushPending(){
  while (pendingQueue.length > 0) {
    const it = pendingQueue.shift();
    pendingSet.delete(it.key);
    if (it.type === 'index') {
      log('Flushing queued index ' + it.value);
      await playFileByIndex(it.value);
      await new Promise(r => setTimeout(r, 250));
    } else {
      log('Flushing queued text "' + it.value + '"');
      const idx = findIndexForText(it.value);
      if (idx > 0) {
        await playFileByIndex(idx);
        await new Promise(r => setTimeout(r, 250));
      } else {
        log('Queued text still not found: ' + it.value);
      }
    }
  }
}

// polling
async function pollOnce(){
  const url = firebaseUrlEl.value.trim() || FIREBASE_DEFAULT;
  try {
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) { setStatus('Firebase fetch failed: ' + r.status); return; }
    const j = await r.json();
    await handleMessageObject(j);
  } catch(e) {
    console.warn('poll error', e);
    setStatus('Poll error: ' + (e.message||e));
  }
}

// UI helpers
function showManual(){ manualBtn.style.display = 'inline-block'; manualBtn.focus(); }
function hideManual(){ manualBtn.style.display = 'none'; }
clearQueueBtn.addEventListener('click', ()=> { pendingQueue = []; pendingSet.clear(); log('Cleared queued items'); });

// enable/start
enableBtn.addEventListener('click', async ()=>{
  setStatus('Enable pressed — attempting audible unlock...');
  document.addEventListener('touchstart', firstGesture, {passive:true});
  document.addEventListener('click', firstGesture);
  const ok = await tryUnlockSequence();
  if (!ok) {
    setStatus('Audio locked — please tap Manual Play or tap page once. Polling will run but playback is blocked until unlock.');
    showManual();
    if (!pollHandle) { pollHandle = setInterval(pollOnce, POLL_INTERVAL_MS); setStatus('Polling started (playback blocked)'); enableBtn.disabled = true; stopBtn.disabled = false; }
    return;
  }
  setStatus('Unlocked — starting poll & flushing queue');
  if (!pollHandle) { pollHandle = setInterval(pollOnce, POLL_INTERVAL_MS); enableBtn.disabled=true; stopBtn.disabled=false; }
  await flushPending();
});
stopBtn.addEventListener('click', ()=> { if (pollHandle) { clearInterval(pollHandle); pollHandle=null; setStatus('Polling stopped'); enableBtn.disabled=false; stopBtn.disabled=true; } });
previewBtn.addEventListener('click', ()=> { createAudioCtxIfNeeded(); playFileByIndex(1); });

// manual unlock
manualBtn.addEventListener('click', async ()=> {
  setStatus('Manual Play tapped — attempting unlock...');
  const ok = await tryUnlockSequence();
  if (ok) { setStatus('Unlocked (manual). Flushing queue...'); hideManual(); await flushPending(); }
  else setStatus('Unlock failed — try tapping page or check site permissions.');
});
function firstGesture(e){
  document.removeEventListener('touchstart', firstGesture, {passive:true});
  document.removeEventListener('click', firstGesture);
  log('Detected page gesture — attempting unlock');
  tryUnlockSequence().then(ok=>{
    if (ok) { setStatus('Unlocked via gesture. Flushing queue...'); hideManual(); flushPending().catch(e=>console.warn(e)); }
    else { setStatus('Gesture did not unlock; press Manual Play'); showManual(); }
  });
}

// debug fetch+decode
async function debugFetchDecodeOnce(filename) {
  const base = audioBaseEl.value.trim() || '/audio/';
  const name = (filename || testFilenameInput.value || '0002.mp3').trim();
  let baseWithSlash = base;
  if (!baseWithSlash.endsWith('/')) baseWithSlash = baseWithSlash + '/';
  const url = (baseWithSlash.startsWith('http') ? baseWithSlash : baseWithSlash) + name + '?ts=' + Date.now();
  log('Debug fetch -> ' + url);
  try {
    const r = await fetch(url, { cache: 'no-store' });
    log('HTTP status: ' + r.status);
    if (!r.ok) { log('Fetch failed with status ' + r.status); return; }
    const ab = await r.arrayBuffer();
    log('Fetched bytes: ' + ab.byteLength);
    createAudioCtxIfNeeded();
    try { await audioCtx.resume(); } catch(e){ log('audioCtx.resume() failed: '+e); }
    let buf;
    try {
      buf = await audioCtx.decodeAudioData(ab);
      log('Decoded audio duration (s): ' + buf.duration.toFixed(3));
    } catch(decodeErr) {
      log('decodeAudioData failed: ' + (decodeErr && decodeErr.message ? decodeErr.message : decodeErr));
      console.warn('decode error', decodeErr);
      return;
    }
    const src = audioCtx.createBufferSource();
    const g = audioCtx.createGain();
    g.gain.value = parseFloat(gainSlider.value || 1.0);
    src.buffer = buf;
    src.connect(g); g.connect(audioCtx.destination);
    try { src.start(); log('Debug playback started via AudioBufferSourceNode'); } catch(playErr){ log('Debug playback start failed: ' + (playErr && playErr.message ? playErr.message : playErr)); console.warn(playErr); }
  } catch(err) { log('Debug fetch/ decode error: ' + (err && err.message ? err.message : err)); console.error(err); }
}

debugFetchBtn.addEventListener('click', ()=> debugFetchDecodeOnce('0002.mp3'));
debugFetchCustomBtn.addEventListener('click', ()=> { const fn = testFilenameInput.value.trim() || '0002.mp3'; debugFetchDecodeOnce(fn); });
clearLogBtn.addEventListener('click', ()=> logEl.textContent = '');

/* init */
(async function init(){
  firebaseUrlEl.value = firebaseUrlEl.value || FIREBASE_DEFAULT;
  const ok = await fetchRemoteTxt();
  if (!ok) txtInfo.textContent = '/T1.TXT not found on server — upload local file or add to site.';
  else txtInfo.textContent = `Loaded /T1.TXT (${lines.length} entries)`;
  setStatus('Ready. Click Enable or tap the page when queued plays appear.');
})();
</script>
</body>
</html>
