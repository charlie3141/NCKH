<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gangtay — Auto Play from Firebase (patched)</title>
<style>
  body{font-family:system-ui,Arial;padding:18px;max-width:900px;margin:auto}
  h1{font-size:1.3rem;margin-bottom:.2rem}
  .muted{color:#666;font-size:.9rem}
  label{display:block;margin-top:10px;font-weight:600}
  input[type="text"], input[type="url"]{width:100%;padding:8px;margin-top:6px;box-sizing:border-box}
  button{padding:10px 14px;margin:8px 6px;font-size:1rem}
  .row{display:flex;gap:8px;align-items:center;margin-top:8px}
  #status{margin-top:10px;color:#333}
  #log{white-space:pre-wrap;font-family:monospace;margin-top:10px;background:#f6f6f6;padding:8px;border-radius:6px;max-height:240px;overflow:auto}
  .controls{display:flex;gap:8px;align-items:center;margin-top:8px}
  small{color:#666}
</style>
</head>
<body>
  <h1>Gangtay — Auto Play từ Firebase (patched)</h1>
  <p class="muted">Nhấn <strong>Enable audio & Start</strong> 1 lần để cấp quyền phát âm thanh. Nếu trình duyệt chặn, sử dụng nút <strong>Manual Play</strong> để cho phép. Sau đó trang sẽ poll Firebase mỗi 1s và tự phát file tương ứng.</p>

  <label>1) T1.TXT (mỗi dòng 1 từ) — site root /T1.TXT hoặc upload local</label>
  <div class="row">
    <input type="file" id="fileInput" accept=".txt">
    <button id="reloadTxt">Try fetch /T1.TXT</button>
  </div>
  <div id="txtInfo" class="muted">Trying to fetch /T1.TXT ...</div>

  <label>2) Audio base path (relative or absolute)</label>
  <input id="audioBase" type="text" value="/audio/" />

  <label>3) Firebase message URL (will poll automatically after Enable)</label>
  <input id="firebaseUrl" type="url" value="https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json" />

  <div class="row">
    <button id="enableBtn">Enable audio & Start polling</button>
    <button id="stopBtn" disabled>Stop polling</button>
    <button id="previewBtn">Preview 0001</button>
  </div>

  <label>Volume (gain)</label>
  <div class="controls">
    <input id="gainSlider" type="range" min="0.2" max="4.0" step="0.05" value="1.2">
    <div id="gainVal">Gain x1.20</div>
  </div>

  <div id="status">Status: idle</div>
  <div id="log"></div>

<script>
/*
 Full patched page:
  - unlockAudio() attempts to resume/unlock WebAudio using a silent buffer (works for iOS/Chrome).
  - If unlocking fails, adds a Manual Play button to request permission via a user tap.
  - Polls Firebase every 1s after unlock and plays audio files /audio/0001.mp3 ... based on either received `index` or `text` (looked up in T1.TXT).
  - Uses WebAudio GainNode to control loudness (gain slider).
*/

// Configuration
const FIREBASE_DEFAULT = "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json";
const POLL_INTERVAL_MS = 1000;

// UI Elements
const fileInput = document.getElementById('fileInput');
const reloadTxtBtn = document.getElementById('reloadTxt');
const txtInfo = document.getElementById('txtInfo');
const audioBaseEl = document.getElementById('audioBase');
const firebaseUrlEl = document.getElementById('firebaseUrl');
const enableBtn = document.getElementById('enableBtn');
const stopBtn = document.getElementById('stopBtn');
const previewBtn = document.getElementById('previewBtn');
const gainSlider = document.getElementById('gainSlider');
const gainVal = document.getElementById('gainVal');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');

let lines = [];            // T1.TXT lines
let pollHandle = null;
let lastTs = null;
let audioCtx = null;
let masterGain = null;
let currentAudio = null;
let manualPlayBtn = null;

// util
function log(msg) {
  const t = new Date().toLocaleTimeString();
  logEl.textContent = `[${t}] ${msg}\n` + logEl.textContent;
}
function setStatus(s) { statusEl.textContent = 'Status: ' + s; log(s); }
function pad4(n){ return String(n).padStart(4,'0'); }

// T1.TXT loading
async function fetchRemoteTxt() {
  setStatus('Fetching /T1.TXT ...');
  try {
    const r = await fetch('/T1.TXT', { cache: 'no-store' });
    if (!r.ok) { setStatus('/T1.TXT not found on site (HTTP ' + r.status + ')'); return false; }
    const txt = await r.text();
    parseTxt(txt);
    setStatus(`Loaded /T1.TXT (${lines.length} entries)`);
    return true;
  } catch (err) {
    setStatus('Fetch /T1.TXT failed: ' + err.message);
    return false;
  }
}
function parseTxt(txt) {
  const raw = txt.split(/\r?\n/);
  lines = raw.map(l => l.trim()).filter(l => l.length>0);
  log('Parsed lines: ' + lines.length);
}

// local file input
fileInput.addEventListener('change', async (ev) => {
  const f = ev.target.files && ev.target.files[0];
  if (!f) return;
  setStatus('Reading local file ' + f.name);
  try {
    const txt = await f.text();
    parseTxt(txt);
    setStatus(`Loaded local ${f.name} (${lines.length} lines)`);
  } catch (err) {
    setStatus('Read file failed: ' + err.message);
  }
});
reloadTxtBtn.addEventListener('click', fetchRemoteTxt);

// WebAudio creation & gain control
function createAudioContextIfNeeded() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = parseFloat(gainSlider.value || 1.0);
  masterGain.connect(audioCtx.destination);
  log('AudioContext created. base gain=' + masterGain.gain.value.toFixed(2));
}
gainSlider.addEventListener('input', () => {
  const v = parseFloat(gainSlider.value);
  gainVal.textContent = `Gain x${v.toFixed(2)}`;
  if (masterGain && audioCtx) masterGain.gain.setValueAtTime(v, audioCtx.currentTime);
});

// unlock helper — creates a silent buffer and resumes context (user gesture required)
async function unlockAudio() {
  try {
    createAudioContextIfNeeded();
    if (audioCtx.state === 'running') return true;
    // create 1-sample silent buffer, play it
    const buf = audioCtx.createBuffer(1, 1, 22050);
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    src.connect(masterGain);
    src.start(0);
    // try resume too
    await audioCtx.resume();
    // small delay
    await new Promise(r => setTimeout(r, 20));
    log('unlockAudio result: ' + audioCtx.state);
    return (audioCtx.state === 'running');
  } catch (e) {
    console.warn('unlockAudio failed', e);
    return false;
  }
}

// fallback Manual Play flow: create a visible manual button that the user taps once
function ensureManualPlayButton() {
  if (manualPlayBtn) return manualPlayBtn;
  manualPlayBtn = document.createElement('button');
  manualPlayBtn.id = 'manualPlayBtn';
  manualPlayBtn.textContent = 'Manual Play (tap once)';
  manualPlayBtn.style.marginLeft = '8px';
  enableBtn.parentNode.insertBefore(manualPlayBtn, stopBtn);
  manualPlayBtn.addEventListener('click', async () => {
    log('Manual Play button tapped — attempting to unlock audio');
    // try playing a tiny muted element first (some browsers require HTMLAudio)
    try {
      const a = new Audio();
      // tiny silent data URI (very short). Some browsers may reject; mutate approach by setting muted true
      a.muted = true;
      // no src required for some browsers, but set one to be safe (some require a playable element)
      // If you prefer, set a small valid base64 mp3; but muted play often enough to unlock.
      try { await a.play(); } catch(e){ /* ignore */ }
    } catch(e) { /* ignore */ }
    const ok = await unlockAudio();
    if (ok) {
      setStatus('Audio unlocked (manual). Starting polling...');
      startPollingAfterUnlock();
      try { manualPlayBtn.remove(); } catch(e){}
    } else {
      setStatus('Audio still blocked. Check site permissions for sound.');
    }
  });
  return manualPlayBtn;
}

// create audio element and connect to WebAudio GainNode (if possible)
function makeAudioElement(url) {
  createAudioContextIfNeeded();
  const a = new Audio(url);
  a.crossOrigin = "anonymous"; // allow cross-origin if CORS enabled
  try {
    // disconnect previous media source if any
    if (currentAudio && currentAudio._mediaSource) {
      try { currentAudio._mediaSource.disconnect(); } catch(e) {}
      currentAudio._mediaSource = null;
    }
    const src = audioCtx.createMediaElementSource(a);
    src.connect(masterGain);
    a._mediaSource = src;
  } catch (err) {
    // fallback to element volume (may be limited to <=1.0)
    console.warn('MediaElementSource/connect failed:', err);
    a.volume = Math.min(1.0, parseFloat(gainSlider.value || 1.0));
  }
  return a;
}

// play file by numeric index (1-based)
async function playFileByIndex(idx) {
  if (idx <= 0) { setStatus('Invalid index'); return; }
  const name = pad4(idx) + '.mp3';
  let base = audioBaseEl.value.trim() || '/audio/';
  if (!base.endsWith('/')) base += '/';
  // support full http(s) base or relative
  const url = (base.startsWith('http') ? base : base) + name + '?ts=' + Date.now();
  setStatus('Playing ' + name + ' → ' + url);
  try {
    if (currentAudio) { try { currentAudio.pause(); currentAudio.src = ""; } catch(e){} currentAudio = null; }
    const a = makeAudioElement(url);
    currentAudio = a;
    // resume context if suspended
    if (audioCtx && audioCtx.state === 'suspended') {
      try { await audioCtx.resume(); } catch(e){}
    }
    const playOk = await tryPlayElement(a);
    if (!playOk) {
      setStatus('Play failed: blocked by browser. Show Manual Play button.');
      ensureManualPlayButton();
    } else {
      a.onended = () => { setStatus('Finished ' + name); currentAudio = null; };
      a.onerror = (e) => { setStatus('Playback error ' + name); console.error(e); currentAudio = null; };
    }
  } catch (err) {
    setStatus('Play failed: ' + (err && err.message ? err.message : err));
    console.error(err);
  }
}

// wrapper to try playing and detect rejection
async function tryPlayElement(el) {
  try {
    // ensure audio context resumed
    if (audioCtx && audioCtx.state === 'suspended') {
      try { await audioCtx.resume(); } catch(e){}
    }
    await el.play();
    return true;
  } catch (err) {
    console.warn('play rejected', err);
    return false;
  }
}

// find index from text (case-insensitive exact match)
function findIndexForText(text) {
  if (!text) return -1;
  const k = text.trim().toLowerCase();
  for (let i=0;i<lines.length;i++){
    if ((lines[i]||'').toLowerCase() === k) return i+1;
  }
  return -1;
}

// process firebase payload: supports { index: N, ts: ... } or { text: "...", ts: ... }
async function handleMessageObject(obj) {
  if (!obj) return;
  if (typeof obj.index === 'number') {
    await playFileByIndex(obj.index);
    return;
  }
  const text = (typeof obj.text === 'string') ? obj.text : (typeof obj.message === 'string' ? obj.message : null);
  if (!text) return;
  const idx = findIndexForText(text);
  if (idx > 0) {
    await playFileByIndex(idx);
  } else {
    setStatus(`Text not found in T1.TXT: "${text}"`);
    log('Received text not found: ' + text);
    // show manual play fallback
    ensureManualPlayButton();
  }
}

// single poll action
async function pollOnce() {
  const url = (firebaseUrlEl.value.trim() || FIREBASE_DEFAULT);
  try {
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) { setStatus('Firebase fetch failed: ' + r.status); return; }
    const j = await r.json();
    const t = j && (j.ts || j.timestamp || JSON.stringify(j));
    if (!t) return;
    if (String(t) !== String(lastTs)) {
      lastTs = t;
      log('New firebase message: ' + JSON.stringify(j));
      await handleMessageObject(j);
    }
  } catch (err) {
    console.warn('poll error', err);
    setStatus('Poll error: ' + err.message);
  }
}

// start polling after unlocking
function startPollingAfterUnlock() {
  if (!pollHandle) {
    // try load remote T1.TXT if not loaded
    if (!lines.length) fetchRemoteTxt().catch(e => console.warn(e));
    pollHandle = setInterval(pollOnce, POLL_INTERVAL_MS);
    setStatus('Polling started (every ' + (POLL_INTERVAL_MS/1000) + 's)');
    enableBtn.disabled = true;
    stopBtn.disabled = false;
  }
}

// Enable button handler (replaces old flow) - attempts unlock; if blocked, shows manual button
enableBtn.addEventListener('click', async () => {
  setStatus('Attempting to enable audio (user gesture)...');
  createAudioContextIfNeeded();
  const ok = await unlockAudio();
  if (!ok) {
    setStatus('Audio locked by browser. Showing Manual Play button.');
    ensureManualPlayButton();
    // still start polling so logs are visible, but do not auto-play until manual unlock
    if (!pollHandle) {
      pollHandle = setInterval(pollOnce, POLL_INTERVAL_MS);
      setStatus('Polling started (but playback may be blocked until unlocked).');
      enableBtn.disabled = true;
      stopBtn.disabled = false;
    }
    return;
  }
  // unlocked OK
  setStatus('Audio unlocked. Starting polling...');
  startPollingAfterUnlock();
});

// Stop polling
stopBtn.addEventListener('click', () => {
  if (pollHandle) { clearInterval(pollHandle); pollHandle = null; setStatus('Polling stopped'); enableBtn.disabled = false; stopBtn.disabled = true; }
});

// Preview 0001
previewBtn.addEventListener('click', () => {
  createAudioContextIfNeeded();
  playFileByIndex(1);
});

// initial attempt to fetch /T1.TXT
(async function init(){
  firebaseUrlEl.value = firebaseUrlEl.value || FIREBASE_DEFAULT;
  const ok = await fetchRemoteTxt();
  if (!ok) txtInfo.textContent = '/T1.TXT not found on server — upload local file or add to site.';
  else txtInfo.textContent = `Loaded /T1.TXT (${lines.length} entries)`;
  setStatus('Ready. Click "Enable audio & Start polling" to begin (one user gesture required).');
})();

</script>
</body>
</html>
