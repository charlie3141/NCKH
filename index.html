<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>·ª®ng d·ª•ng v√† c·∫£i ti·∫øn "C√¥ng ngh·ªá d·ªãch th·ªß ng·ªØ" v√†o ƒë·ªùi s·ªëng - Phi√™n b·∫£n t·ªëi ∆∞u v·ªõi Hi·ªáu chu·∫©n</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            padding: 20px;
            text-align: center;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .dashboard {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            border: 1px solid #eaeaea;
            will-change: transform, opacity;
            contain: content;
        }

        .card h3 {
            color: #4A00E0;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }

        /* === CARD HI·ªÜU CHU·∫®N === */
        .calibration-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
            border: 2px solid #e0e6ff;
        }

        .calibration-status {
            margin: 15px 0;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
        }

        .calibrating {
            background: #FFF3CD;
            border: 2px solid #FFC107;
            color: #856404;
            animation: pulse 1s infinite;
        }

        .calibrated {
            background: #D4EDDA;
            border: 2px solid #28A745;
            color: #155724;
        }

        .calibration-ready {
            background: #E3F2FD;
            border: 2px solid #2196F3;
            color: #0d47a1;
        }

        .calibration-error {
            background: #FFEBEE;
            border: 2px solid #F44336;
            color: #b71c1c;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        @keyframes countdown {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .calibration-display {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 15px 0;
        }

        .sensor-calibration {
            padding: 15px;
            background: white;
            border-radius: 10px;
            border: 1px solid #eaeaea;
            text-align: center;
        }

        .sensor-name {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 8px;
        }

        .sensor-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin: 5px 0;
        }

        .sensor-max {
            font-size: 1.2rem;
            color: #4CAF50;
            font-weight: bold;
        }

        .sensor-threshold {
            font-size: 1rem;
            color: #2196F3;
            margin-top: 5px;
        }

        .progress-container {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #45a049);
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .calibration-countdown {
            font-size: 2.5rem;
            font-weight: bold;
            color: #FF5722;
            margin: 10px 0;
            animation: countdown 1s infinite;
        }

        .calibration-instructions {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #2196F3;
        }

        .calibration-step {
            margin: 8px 0;
            padding-left: 20px;
            position: relative;
        }

        .calibration-step:before {
            content: "‚Ä¢";
            position: absolute;
            left: 0;
            color: #2196F3;
            font-weight: bold;
        }

        .flex-sensor-legend {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .legend-text {
            font-size: 0.9rem;
            color: #666;
        }

        .conversion-display {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2196F3;
            margin: 10px 0;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #E3F2FD;
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #2196F3;
            line-height: 1.4;
            contain: strict;
            transform: translateZ(0);
        }

        .sentence-display {
            font-size: 1.8rem;
            font-weight: bold;
            color: #4CAF50;
            margin: 10px 0;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #E8F5E9;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #4CAF50;
            line-height: 1.4;
            contain: strict;
            transform: translateZ(0);
        }

        .current-word-display {
            font-size: 2rem;
            font-weight: bold;
            color: #FF5722;
            margin: 10px 0;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #FFF8E1;
            border-radius: 10px;
            padding: 15px;
            border: 2px dashed #FFC107;
            contain: strict;
            transform: translateZ(0);
        }

        .word-list {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #eaeaea;
        }

        .word-item {
            display: inline-block;
            padding: 8px 15px;
            margin: 5px;
            background: #e3f2fd;
            border-radius: 20px;
            border: 1px solid #bbdefb;
        }

        .word-count {
            font-size: 0.9rem;
            color: #666;
            margin-top: 10px;
        }

        .sensor-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .sensor-item {
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid;
        }

        .sensor-item.mpu {
            border-left-color: #2196F3;
        }

        .sensor-item.flex {
            border-left-color: #4CAF50;
        }

        .sensor-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
            margin: 5px 0;
        }

        .sensor-label {
            font-size: 0.8rem;
            color: #444;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .flex-box {
            display: inline-block;
            width: 40px;
            height: 40px;
            line-height: 40px;
            text-align: center;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 2px;
            font-weight: bold;
            border: 2px solid transparent;
        }

        .flex-box.active-0 { background: #4CAF50; color: white; }
        .flex-box.active-1 { background: #FF9800; color: white; }
        .flex-box.active-2 { background: #F44336; color: white; }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        button.red {
            background: linear-gradient(to right, #FF416C, #FF4B2B);
        }

        button.green {
            background: linear-gradient(to right, #00b09b, #96c93d);
        }

        button.blue {
            background: linear-gradient(to right, #2196F3, #21CBF3);
        }

        button.orange {
            background: linear-gradient(to right, #FF9800, #FF5722);
        }

        button.purple {
            background: linear-gradient(to right, #9C27B0, #673AB7);
        }

        .status-bar {
            background: #f8f9fa;
            padding: 15px;
            border-top: 1px solid #eaeaea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        .indicator.online {
            background: #4CAF50;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        .shake-active {
            color: #FF5722 !important;
            font-weight: bold !important;
            animation: shake 0.5s infinite;
        }

        .language-select {
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid #ccc;
            background: white;
            font-size: 1rem;
        }

        .phrase-btn {
            padding: 8px 15px;
            background: linear-gradient(to right, #FF9800, #FF5722);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .phrase-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(255,87,34,0.3);
        }

        .loading {
            animation: pulse 1s infinite;
            color: #2196F3 !important;
        }

        .error {
            color: #F44336 !important;
            border-color: #F44336 !important;
            background: #FFEBEE !important;
        }

        .success {
            color: #4CAF50 !important;
            border-color: #4CAF50 !important;
            background: #E8F5E9 !important;
        }

        textarea {
            width: 100%;
            height: 120px;
            font-size: 1.5rem;
            padding: 15px;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            background: #E8F5E9;
            color: #333;
            resize: vertical;
        }

        select {
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid #ccc;
            min-width: 150px;
        }

        .firebase-status {
            font-size: 0.9rem;
            color: #444;
            margin-top: 5px;
        }

        .last-update {
            font-size: 0.8rem;
            color: #777;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }

        .phrase-suggestions {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #eaeaea;
        }

        .phrase-suggestions h4 {
            margin-bottom: 10px;
            color: #4A00E0;
            font-size: 1rem;
        }

        .phrase-pills {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .phrase-pill {
            padding: 6px 12px;
            background: linear-gradient(to right, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .phrase-pill:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(76,175,80,0.3);
        }

        .phrase-pill.blue {
            background: linear-gradient(to right, #2196F3, #1976D2);
        }

        .speech-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        .speech-btn {
            padding: 10px 20px;
            background: linear-gradient(to right, #9C27B0, #673AB7);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .speech-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(156,39,176,0.3);
        }

        .speech-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .speech-btn.speaking {
            background: linear-gradient(to right, #FF5722, #E64A19);
            animation: pulse 1s infinite;
        }

        .audio-visualizer {
            margin-top: 10px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
        }

        .audio-bar {
            width: 4px;
            background: #4CAF50;
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        .dynamic-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .dynamic-suggestions.show {
            display: block;
        }

        .suggestion-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background 0.2s;
        }

        .suggestion-item:hover {
            background: #f0f7ff;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .text-input-container {
            position: relative;
        }

        .auto-suggestions-panel {
            margin-top: 15px;
            padding: 15px;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
            border-radius: 10px;
            border: 2px solid #e0e6ff;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .auto-suggestions-title {
            font-size: 0.9rem;
            font-weight: bold;
            color: #4A00E0;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .auto-suggestions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
        }

        .auto-suggestion-item {
            padding: 12px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .auto-suggestion-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-color: #4A00E0;
        }

        .auto-suggestion-text {
            font-size: 0.9rem;
            margin-bottom: 8px;
        }

        .auto-suggestion-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .auto-suggestion-btn {
            padding: 4px 8px;
            font-size: 0.75rem;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            flex: 1;
            text-align: center;
        }

        .auto-suggestion-btn.speak {
            background: linear-gradient(to right, #9C27B0, #673AB7);
            color: white;
        }

        .auto-suggestion-btn.use {
            background: linear-gradient(to right, #4CAF50, #45a049);
            color: white;
        }

        .auto-suggestion-btn.translate {
            background: linear-gradient(to right, #2196F3, #1976D2);
            color: white;
        }

        .voice-options {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .voice-btn {
            padding: 6px 12px;
            background: linear-gradient(to right, #FF9800, #FF5722);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s;
        }

        .voice-btn.active {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            box-shadow: 0 2px 8px rgba(74,0,224,0.3);
        }

        .voice-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .voice-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .language-voice-display {
            font-size: 0.8rem;
            color: #444;
            text-align: center;
            margin-top: 5px;
        }

        .ai-speech-status {
            margin-top: 5px;
            font-size: 0.8rem;
            color: #4CAF50;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .ai-loading {
            animation: pulse 1s infinite;
        }

        .tts-toggle {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .tts-toggle-btn {
            padding: 6px 12px;
            background: #f0f0f0;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .tts-toggle-btn.active {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            border-color: #4A00E0;
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        .performance-info {
            font-size: 0.7rem;
            color: #666;
            text-align: center;
            margin-top: 5px;
        }

        .fast-mode {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #4CAF50;
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            z-index: 1000;
        }

        .phrase-list-container {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eaeaea;
            border-radius: 10px;
            background: white;
        }

        .phrase-list-item {
            padding: 12px 15px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .phrase-list-item:hover {
            background: #f0f7ff;
            border-left: 3px solid #4A00E0;
        }

        .phrase-list-item:last-child {
            border-bottom: none;
        }

        .accent-selector {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .accent-btn {
            padding: 8px 15px;
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s;
        }

        .accent-btn.active {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            border-color: #4A00E0;
        }

        .accent-btn.north {
            background: #E3F2FD;
            border-color: #2196F3;
        }

        .accent-btn.central {
            background: #E8F5E9;
            border-color: #4CAF50;
        }

        .accent-btn.south {
            background: #FFF3E0;
            border-color: #FF9800;
        }

        .voice-gender-selector {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            justify-content: center;
        }

        .voice-gender-btn {
            padding: 8px 20px;
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .voice-gender-btn.active {
            background: linear-gradient(to right, #FF9800, #FF5722);
            color: white;
            border-color: #FF9800;
        }

        .tts-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 10px 0;
            padding: 10px;
            background: #FFF3CD;
            border-radius: 8px;
            border: 1px solid #FFC107;
        }

        .tts-loading span {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #FFEBEE;
            border: 1px solid #F44336;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            color: #b71c1c;
            text-align: center;
            animation: pulse 1s infinite;
        }

        .suggestion-header {
            background: #f8f9fa;
            padding: 4px 8px;
            font-size: 0.7rem;
            color: #666;
            border-radius: 4px;
            margin-top: 4px;
            display: inline-block;
        }

        /* ===== T√çNH NƒÇNG M·ªöI ===== */
        .swap-languages-btn {
            padding: 8px 12px;
            background: linear-gradient(to right, #9C27B0, #673AB7);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .swap-languages-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(156,39,176,0.3);
        }

        .translation-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .translation-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-left: auto;
        }

        .auto-translate-toggle {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
            color: #666;
        }

        .auto-translate-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .voice-gender-buttons {
            display: flex;
            background: #f8f9fa;
            padding: 4px;
            border-radius: 20px;
            gap: 2px;
        }

        .voice-gender-button {
            padding: 8px 16px;
            border: none;
            border-radius: 16px;
            background: transparent;
            color: #666;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            transition: all 0.2s;
        }

        .voice-gender-button.active {
            background: white;
            color: #4A00E0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .translation-area {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e0e6ff;
        }

        .text-input-wrapper {
            position: relative;
        }

        .suggestions-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .suggestions-dropdown.show {
            display: block;
            animation: slideIn 0.2s ease;
        }

        .suggestion-dropdown-item {
            padding: 12px 16px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.2s;
        }

        .suggestion-dropdown-item:hover {
            background: #f5f7ff;
        }

        .suggestion-dropdown-item:last-child {
            border-bottom: none;
        }

        .language-badge {
            display: inline-block;
            padding: 4px 8px;
            background: #E3F2FD;
            color: #1976D2;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-left: 8px;
        }

        .speech-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .speech-status.connecting {
            background: #FFF3CD;
            color: #856404;
        }

        .speech-status.speaking {
            background: #D4EDDA;
            color: #155724;
        }

        .speech-status.error {
            background: #FFEBEE;
            color: #b71c1c;
        }

        .speech-status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ddd;
        }

        .speech-status-indicator.connecting {
            background: #FFC107;
            animation: pulse 1s infinite;
        }

        .speech-status-indicator.speaking {
            background: #28A745;
            animation: pulse 0.5s infinite;
        }

        .speech-status-indicator.error {
            background: #F44336;
        }
    </style>
</head>
<body>
    <div class="fast-mode" id="fastModeIndicator" style="display: none;">üöÄ Ch·∫ø ƒë·ªô t·ªëc ƒë·ªô cao: B·∫¨T</div>
    <div class="container">
        <header>
            <h1>·ª®ng d·ª•ng v√† c·∫£i ti·∫øn "C√¥ng ngh·ªá d·ªãch th·ªß ng·ªØ" v√†o ƒë·ªùi s·ªëng - Phi√™n b·∫£n t·ªëi ∆∞u v·ªõi Hi·ªáu chu·∫©n</h1>
            <div>Gi√°m s√°t th·ªùi gian th·ª±c t·ª´ C∆° s·ªü d·ªØ li·ªáu Firebase</div>
            <div class="firebase-status" id="firebaseStatus">
                ƒêang k·∫øt n·ªëi v·ªõi Firebase...
            </div>
            <div class="performance-info" id="performanceInfo">
                ƒê·ªô tr·ªÖ: <span id="latency">--</span>ms | FPS: <span id="fps">--</span> | T·∫ßn su·∫•t c·∫≠p nh·∫≠t: <span id="pollingRate">--</span>ms
            </div>
        </header>

        <div class="dashboard">
            <!-- Card X√¢y d·ª±ng C√¢u -->
            <div class="card">
                <h3>X√¢y d·ª±ng C√¢u</h3>
                <div style="text-align: center; padding: 20px; margin-bottom: 20px;">
                    <div class="sensor-label">T·ª™ HI·ªÜN T·∫†I (Ti·∫øng Vi·ªát)</div>
                    <div class="current-word-display" id="displayBuffer">---</div>
                    <div class="sensor-label">T·ª™ HI·ªÜN T·∫†I (M√£ h√≥a)</div>
                    <div class="conversion-display" id="convertedCurrentWord">---</div>
                    
                    <div style="margin: 15px 0; color: #444;">
                        <div><strong>S·ª≠ d·ª•ng '_' ƒë·ªÉ th√™m t·ª´ v√†o c√¢u</strong></div>
                        <div><strong>S·ª≠ d·ª•ng 'COMMIT' ƒë·ªÉ ho√†n th√†nh c√¢u</strong></div>
                    </div>
                    
                    <div class="sensor-label">C√ÇU ƒê·∫¶Y ƒê·ª¶ (M√£ h√≥a)</div>
                    <div class="sentence-display" id="sentenceDisplay">---</div>
                    <div class="sensor-label">C√ÇU ƒê·∫¶Y ƒê·ª¶ (Ti·∫øng Vi·ªát)</div>
                    <div class="conversion-display" id="convertedSentenceDisplay">---</div>
                    
                    <!-- Ph·∫ßn ƒë·ªÅ xu·∫•t c·ª•m t·ª´ -->
                    <div class="phrase-suggestions">
                        <h4>üìù ƒê·ªÄ XU·∫§T C·ª§M T·ª™ TH√îNG D·ª§NG</h4>
                        <div class="phrase-pills" id="phrasePills">
                            <!-- C√°c n√∫t c·ª•m t·ª´ s·∫Ω ƒë∆∞·ª£c th√™m b·ªüi JavaScript -->
                        </div>
                        
                        <!-- ƒê·ªÅ xu·∫•t ƒë·ªông -->
                        <div class="dynamic-suggestions" id="dynamicSuggestions">
                            <!-- ƒê·ªÅ xu·∫•t ƒë·ªông s·∫Ω xu·∫•t hi·ªán ·ªü ƒë√¢y -->
                        </div>
                    </div>
                    
                    <!-- Chuy·ªÉn ƒë·ªïi TTS -->
                    <div class="tts-toggle">
                        <button class="tts-toggle-btn active" id="useGeminiTTS" onclick="toggleTTSMode(true)">üéØ Gi·ªçng AI Gemini</button>
                        <button class="tts-toggle-btn" id="useWebSpeech" onclick="toggleTTSMode(false)">üîä Web Speech</button>
                    </div>
                    
                    <!-- B·∫£ng ƒë·ªÅ xu·∫•t t·ª± ƒë·ªông -->
                    <div class="auto-suggestions-panel" id="autoSuggestionsPanel" style="display: none;">
                        <div class="auto-suggestions-title">
                            <span>üí° ƒê·ªÄ XU·∫§T D·ª∞A TR√äN C√ÇU C·ª¶A B·∫†N</span>
                        </div>
                        <div class="auto-suggestions-grid" id="autoSuggestionsGrid">
                            <!-- ƒê·ªÅ xu·∫•t t·ª± ƒë·ªông s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y -->
                        </div>
                    </div>
                    
                    <!-- T√πy ch·ªçn gi·ªçng n√≥i -->
                    <div class="voice-options">
                        <div class="voice-gender-buttons">
                            <button class="voice-gender-button active" onclick="setVoiceGender('female')">üë© N·ªØ</button>
                            <button class="voice-gender-button" onclick="setVoiceGender('male')">üë® Nam</button>
                        </div>
                    </div>
                    
                    <div class="language-voice-display" id="currentVoiceDisplay">
                        Hi·ªán t·∫°i: N·ªØ Ti·∫øng Vi·ªát (Gemini AI)
                    </div>
                    
                    <div class="speech-status" id="speechStatus" style="display: none;">
                        <div class="speech-status-indicator"></div>
                        <span id="speechStatusText">ƒêang chu·∫©n b·ªã gi·ªçng n√≥i...</span>
                    </div>
                    
                    <!-- ƒêi·ªÅu khi·ªÉn gi·ªçng n√≥i -->
                    <div class="speech-controls">
                        <button class="speech-btn" onclick="speakVietnameseSentence()" id="speakVnBtn">
                            üîä ƒê·ªçc Ti·∫øng Vi·ªát
                        </button>
                        <button class="speech-btn blue" onclick="speakTranslation()" id="speakTransBtn">
                            üîà ƒê·ªçc B·∫£n d·ªãch
                        </button>
                        <button class="speech-btn red" onclick="stopAllSpeech()" id="stopSpeechBtn">
                            ‚èπ D·ª´ng ƒë·ªçc
                        </button>
                    </div>
                    
                    <div class="audio-visualizer" id="audioVisualizer">
                        <!-- Thanh √¢m thanh s·∫Ω ƒë∆∞·ª£c th√™m ·ªü ƒë√¢y -->
                    </div>
                    
                    <div class="word-list" id="wordList">Ch∆∞a c√≥ t·ª´ n√†o</div>
                    <div class="word-count">S·ªë t·ª´ trong c√¢u: <span id="wordCount">0</span>/10</div>
                    
                    <div style="display: flex; justify-content: space-around; margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                        <div>
                            <div class="sensor-label">KHE 1</div>
                            <div class="sensor-value" id="slot1" style="font-size: 1.2rem;">---</div>
                        </div>
                        <div>
                            <div class="sensor-label">KHE 2</div>
                            <div class="sensor-value" id="slot2" style="font-size: 1.2rem;">---</div>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button onclick="clearCurrentWord()" class="red">X√≥a t·ª´ hi·ªán t·∫°i</button>
                        <button onclick="backspace()">X√≥a k√Ω t·ª±</button>
                        <button onclick="addWordToSentence()" class="green">Th√™m t·ª´ (_)</button>
                        <button onclick="commitSentence()" class="blue">Ho√†n th√†nh c√¢u</button>
                        <button onclick="resetSentence()" class="red">ƒê·∫∑t l·∫°i t·∫•t c·∫£</button>
                    </div>
                </div>
            </div>

            <!-- Card Hi·ªáu chu·∫©n -->
            <div class="card calibration-card">
                <h3>üéØ Hi·ªáu chu·∫©n C·∫£m bi·∫øn U·ªën</h3>
                
                <div class="calibration-instructions">
                    <h4>üìã H∆∞·ªõng d·∫´n Hi·ªáu chu·∫©n:</h4>
                    <div class="calibration-step">ƒê·∫∑t tay th·∫≥ng v√† th∆∞ gi√£n</div>
                    <div class="calibration-step">Nh·∫•n "B·∫Øt ƒë·∫ßu Hi·ªáu chu·∫©n"</div>
                    <div class="calibration-step">L·∫ßn l∆∞·ª£t u·ªën t·ª´ng ng√≥n tay h·∫øt m·ª©c c√≥ th·ªÉ (10 gi√¢y)</div>
                    <div class="calibration-step">H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông l∆∞u gi√° tr·ªã ng∆∞·ª°ng u·ªën</div>
                    <div class="calibration-step">Sau khi ho√†n th√†nh, h·ªá th·ªëng s·∫Ω s·ª≠ d·ª•ng gi√° tr·ªã ƒë√£ hi·ªáu chu·∫©n</div>
                </div>
                
                <div class="calibration-status" id="calibrationStatus">
                    <div class="calibration-ready">S·∫µn s√†ng ƒë·ªÉ Hi·ªáu chu·∫©n</div>
                </div>
                
                <!-- Hi·ªÉn th·ªã qu√° tr√¨nh hi·ªáu chu·∫©n -->
                <div id="calibrationProgress" style="display: none;">
                    <div class="calibration-countdown" id="calibrationCountdown">10</div>
                    <div style="text-align: center; margin: 10px 0; font-weight: bold; color: #4A00E0;">
                        <span id="calibrationMessage">ƒêang hi·ªáu chu·∫©n... Vui l√≤ng u·ªën ng√≥n tay h·∫øt m·ª©c!</span>
                    </div>
                    
                    <div class="calibration-display" id="calibrationDisplay">
                        <!-- C√°c c·∫£m bi·∫øn s·∫Ω ƒë∆∞·ª£c th√™m b·∫±ng JavaScript -->
                    </div>
                    
                    <div class="progress-container">
                        <div class="progress-bar" id="calibrationProgressBar" style="width: 0%"></div>
                    </div>
                </div>
                
                <!-- Hi·ªÉn th·ªã ng∆∞·ª°ng hi·ªán t·∫°i -->
                <div class="sensor-calibration" style="margin-top: 20px;">
                    <div class="sensor-label">NG∆Ø·ª†NG HI·ªÜN T·∫†I</div>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 10px;">
                        <div>
                            <div class="sensor-name">C·∫£m bi·∫øn 0</div>
                            <div class="sensor-threshold" id="currentThreshold0">300</div>
                        </div>
                        <div>
                            <div class="sensor-name">C·∫£m bi·∫øn 1</div>
                            <div class="sensor-threshold" id="currentThreshold1">450</div>
                        </div>
                        <div>
                            <div class="sensor-name">C·∫£m bi·∫øn 2</div>
                            <div class="sensor-threshold" id="currentThreshold2">350</div>
                        </div>
                        <div>
                            <div class="sensor-name">C·∫£m bi·∫øn 3</div>
                            <div class="sensor-threshold" id="currentThreshold3">300</div>
                        </div>
                    </div>
                </div>
                
                <div class="flex-sensor-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4CAF50;"></div>
                        <div class="legend-text">Th·∫≥ng (0)</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF9800;"></div>
                        <div class="legend-text">H∆°i u·ªën (1)</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #F44336;"></div>
                        <div class="legend-text">U·ªën h·∫øt (2)</div>
                    </div>
                </div>
                
                <div class="controls">
                    <button onclick="startCalibration()" class="orange" id="calibrateBtn">üéØ B·∫Øt ƒë·∫ßu Hi·ªáu chu·∫©n</button>
                    <button onclick="stopCalibration()" class="red" id="stopCalibrateBtn" style="display: none;">‚èπ D·ª´ng Hi·ªáu chu·∫©n</button>
                    <button onclick="resetCalibration()" class="purple">üîÑ Reset v·ªÅ M·∫∑c ƒë·ªãnh</button>
                    <button onclick="loadCalibration()" class="blue">üíæ T·∫£i Hi·ªáu chu·∫©n</button>
                </div>
                
                <div class="calibration-info" style="margin-top: 15px; font-size: 0.8rem; color: #444; text-align: center;">
                    <div>Ng∆∞·ª°ng th·∫≥ng c·ªë ƒë·ªãnh: C·∫£m bi·∫øn 0-2: 75, C·∫£m bi·∫øn 3: 75</div>
                    <div>Ng∆∞·ª°ng u·ªën s·∫Ω ƒë∆∞·ª£c hi·ªáu chu·∫©n t·ª± ƒë·ªông</div>
                </div>
            </div>

            <!-- Card D·ªãch thu·∫≠t -->
            <div class="card">
                <h3>D·ªãch thu·∫≠t</h3>
                <div class="translation-area">
                    <div class="translation-header">
                        <div>
                            <div class="sensor-label">Ng√¥n ng·ªØ ngu·ªìn</div>
                            <select id="sourceLanguage" class="language-select">
                                <option value="vi-VN">Ti·∫øng Vi·ªát</option>
                                <option value="en-GB">Ti·∫øng Anh</option>
                                <option value="ja-JP">Ti·∫øng Nh·∫≠t</option>
                                <option value="ko-KR">Ti·∫øng H√†n</option>
                                <option value="zh-CN">Ti·∫øng Trung</option>
                            </select>
                        </div>
                        
                        <button class="swap-languages-btn" onclick="swapLanguages()" title="ƒê·ªïi chi·ªÅu d·ªãch">
                            ‚áÑ
                        </button>
                        
                        <div>
                            <div class="sensor-label">Ng√¥n ng·ªØ ƒë√≠ch</div>
                            <select id="targetLanguage" class="language-select">
                                <option value="en-GB">Ti·∫øng Anh</option>
                                <option value="ja-JP">Ti·∫øng Nh·∫≠t</option>
                                <option value="ko-KR">Ti·∫øng H√†n</option>
                                <option value="zh-CN">Ti·∫øng Trung</option>
                                <option value="vi-VN">Ti·∫øng Vi·ªát</option>
                            </select>
                        </div>
                        
                        <div class="translation-controls">
                            <div class="auto-translate-toggle">
                                <input type="checkbox" id="autoTranslate" class="auto-translate-checkbox" checked>
                                <label for="autoTranslate">T·ª± ƒë·ªông d·ªãch</label>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <div class="sensor-label">C√ÇU ƒê·∫¶Y ƒê·ª¶ (ƒê·ªÉ d·ªãch)</div>
                        <div class="text-input-wrapper">
                            <textarea id="translationInput" placeholder="Nh·∫≠p vƒÉn b·∫£n ·ªü ƒë√¢y..." 
                                      oninput="handleTranslationInput()"></textarea>
                            <div class="suggestions-dropdown" id="translationSuggestions">
                                <!-- ƒê·ªÅ xu·∫•t ƒë·ªông cho d·ªãch thu·∫≠t -->
                            </div>
                        </div>
                    </div>

                    <div class="sensor-label">K·∫æT QU·∫¢ D·ªäCH</div>
                    <div id="translationOutput" class="conversion-display" style="min-height: 80px; margin-bottom: 15px;">
                        ƒêang ch·ªù d·ªãch...
                    </div>

                    <div class="controls">
                        <button onclick="translateSentence()" class="blue">D·ªãch c√¢u</button>
                        <button onclick="clearTranslation()" class="red">X√≥a b·∫£n d·ªãch</button>
                    </div>
                </div>
            </div>

            <!-- Card Hi·ªÉn th·ªã C·∫£m bi·∫øn -->
            <div class="card">
                <h3>D·ªØ li·ªáu C·∫£m bi·∫øn t·ª´ Firebase</h3>
                <div class="sensor-grid">
                    <div class="sensor-item mpu">
                        <div class="sensor-label">ƒê·ªäNH H∆Ø·ªöNG MPU6050</div>
                        <div class="sensor-value" id="mpuOrientation">Kh√¥ng x√°c ƒë·ªãnh</div>
                        <div class="sensor-label">TR·∫†NG TH√ÅI L·∫ÆC</div>
                        <div class="sensor-value" id="mpuShakeState">Kh√¥ng</div>
                        <div class="sensor-label">ƒêANG L·∫ÆC?</div>
                        <div class="sensor-value" id="isShaking">KH√îNG</div>
                    </div>
                    <div class="sensor-item flex">
                        <div class="sensor-label">C·∫¢M BI·∫æN U·ªêN</div>
                        <div>
                            <div>
                                <span class="flex-box" id="flex0-box">0</span>
                                <span class="flex-box" id="flex1-box">0</span>
                                <span class="flex-box" id="flex2-box">0</span>
                                <span class="flex-box" id="flex3-box">0</span>
                            </div>
                            <div class="sensor-label" style="margin-top: 10px;">
                                Gi√° tr·ªã th√¥: <span id="rawValues">0, 0, 0, 0</span>
                            </div>
                            <div class="sensor-label">
                                Tr·∫°ng th√°i: <span id="flexFormat">0000</span> (a0,a1,a2,a3)
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="sensor-item" style="margin-top: 15px;">
                    <div class="sensor-label">TR·∫†NG TH√ÅI H·ªÜ TH·ªêNG</div>
                    <div>C·∫≠p nh·∫≠t l·∫ßn cu·ªëi: <span id="lastUpdateTime" class="last-update">Ch∆∞a bao gi·ªù</span></div>
                    <div>Th·ªùi gian x·ª≠ l√Ω: <span id="processingTime" class="last-update">0ms</span></div>
                </div>
                
                <div class="controls" style="margin-top: 15px;">
                    <button onclick="refreshData()" class="blue">L√†m m·ªõi ngay</button>
                    <button onclick="toggleAutoRefresh()" id="autoRefreshBtn" class="green">T·ª± ƒë·ªông: B·∫¨T (300ms)</button>
                    <button onclick="toggleTurboMode()" id="turboBtn" class="green">üöÄ Ch·∫ø ƒë·ªô Turbo</button>
                </div>
            </div>

            <!-- Card Hi·ªÉn th·ªã Nh·∫≠t k√Ω -->
            <div class="card">
                <h3>Nh·∫≠t k√Ω H·ªá th·ªëng</h3>
                <div style="max-height: 300px; overflow-y: auto; background: #f8f9fa; border-radius: 8px; padding: 10px;">
                    <div id="logContainer">
                        <div class="log-entry">H·ªá th·ªëng ƒë√£ kh·ªüi ƒë·ªông. ƒêang ch·ªù d·ªØ li·ªáu Firebase...</div>
                    </div>
                </div>
                <div class="controls" style="margin-top: 15px;">
                    <button onclick="clearLog()" class="red">X√≥a nh·∫≠t k√Ω</button>
                    <button onclick="exportLog()" class="blue">Xu·∫•t nh·∫≠t k√Ω</button>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div>
                <span class="indicator" id="connectionStatus"></span>
                <span id="statusText">ƒêang k·∫øt n·ªëi v·ªõi Firebase...</span>
            </div>
            <div>
                <span id="lastUpdate">C·∫≠p nh·∫≠t Firebase l·∫ßn cu·ªëi: --:--:--</span>
            </div>
        </div>
    </div>

    <script>
        // === C·∫§U H√åNH T·ªêC ƒê·ªò CAO ===
        const FIREBASE_URL = "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/sensorData.json";
        const GEMINI_API_KEY = "AIzaSyDdUj2SX83qODeZ1hhru0e9KN1fwDrtUP8";
        const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent";
        const GEMINI_TRANSLATE_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent";
        
        // === BI·∫æN HI·ªÜU CHU·∫®N ===
        let bentThresholds = [300, 450, 350, 300]; // Gi√° tr·ªã m·∫∑c ƒë·ªãnh cho ng∆∞·ª°ng u·ªën
        const STRAIGHT_THRESHOLDS = [75, 75, 75, 75]; // Gi√° tr·ªã c·ªë ƒë·ªãnh cho ng∆∞·ª°ng th·∫≥ng
        
        let isCalibrating = false;
        let calibrationTimeout = null;
        let calibrationInterval = null;
        let calibrationCountdown = 10;
        let calibrationStartTime = 0;
        let calibrationMaxValues = [0, 0, 0, 0];
        let calibrationCurrentSensor = 0;
        let calibrationStep = "waiting"; // waiting, calibrating, done
        
        // === BI·∫æN T·ªêI ∆ØU H√ìA ===
        let firebaseData = null;
        let lastUpdateTime = 0;
        let autoRefresh = true;
        let autoRefreshInterval;
        let logEntries = [];
        const MAX_LOG_ENTRIES = 20;
        let isFetching = false;
        let lastFirebaseData = null;
        let uiUpdateScheduled = false;
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let currentFPS = 60;
        let pollingInterval = 300;
        let turboMode = false;
        let currentFetchController = null;
        
        // Bi·∫øn x√¢y d·ª±ng c√¢u
        let slot1 = "";
        let slot2 = "";
        let displayBuffer = "";
        let convertedCurrentWord = "";
        let sentenceWords = [];
        let fullSentence = "";
        let convertedFullSentence = "";
        
        // Tr·∫°ng th√°i c·∫£m bi·∫øn u·ªën
        let flexStates = [0, 0, 0, 0];
        let lastFlexStates = [-1, -1, -1, -1];
        let stableCount = 0;
        let lastDetectedIndex = -1;
        let holdStartMs = 0;
        let holdFired = false;
        const DEBOUNCE_COUNT = 3;
        const HOLD_MS_DEFAULT = 1000; // ƒê√É ƒê·ªîI: T·ª´ 800ms l√™n 1000ms (1 gi√¢y)
        const POST_HOLD_COOLDOWN = 800; // ƒê√É ƒê·ªîI: T·ª´ 600ms l√™n 800ms
        let lastActionMs = 0;
        let lastStateString = '';
        
        // CACHE cho t·ªëi ∆∞u h√≥a
        const mappingCache = new Map();
        const vietnameseCache = new Map();
        let translationCache = {};
        let audioCache = {};
        
        // === B·∫¢NG D·ªÆ LI·ªÜU (gi·ªØ nguy√™n t·ª´ file g·ªëc) ===
        const tableA = [
            ["IAY","IC","ICH","IE","IEC","IEM","IEN","IENG","IEO"],
            ["IEP","IET","IEU","IM","IN","ING","INH","IO","IOI"],
            ["ENG","ENH","EO","EP","ET","EU","I","IA","IAC"],
            ["IAI","IAM","IAN","IANG","IANH","IAO","IAP","IAT","IAU"],
            ["AP","AT","AU","AY","E","EC","ECH","EM","EN"],
            ["A","AC","ACH","AI","AM","AN","ANG","ANH","AO"],
            ["IUN","IUONG","IUP","O","OA","OAC","OACH","OAI","OAM"],
            ["ION","IONG","IOT","IP","IT","IU","IUA","IUC","IUI"]
        ];

        const tableB = [
            ["UE","UECH","UEN","UENH","UEO","UET","UI","UM","UN"],
            ["UNG","UO","UOC","UOI","UOM","UON","UONG","UOP","OUT"],
            ["ONG","OOC","OONG","OP","OT","U","UA","UAC","UACH"],
            ["UAI","UAM","UAN","UANG","UANH","UAO","UAT","UAY","UC"],
            ["OAY","OC","OE","OEN","OEO","OET","OI","OM","ON"],
            ["COMMIT","_","nullptr","nullptr","OAN","OANG","OANH","OAP","OAT"],
            ["UYNH","UYP","UYT","UYU","Y","YEM","YEN","YET","YEU"],
            ["UOU","UP","UT","UU","UY","UYA","UYCH","UYEN","UYET"]
        ];

        const tableC = [
            [ ["B","C","D"],["ƒê","G","H"],["K","L","M"] ],
            [ ["N","P","Q"],["R","S","T"],["V","X","CH"] ],
            [ ["GH","KH","NG"],["NGH","NH","PH"],["TH","TR","_"] ]
        ];

        // B·∫£ng chuy·ªÉn ƒë·ªïi Ti·∫øng Vi·ªát (b·∫£ng ƒë·∫ßy ƒë·ªß t·ª´ ESP32 code)
        const vietnameseTable = [
            {key: "IAY", forms: ["i√°y", "i√†y", "i·∫£y", "i√£y", "i·∫°y", "iay", "i·∫•y", "i·∫ßy", "i·∫©y", "i·∫´y", "i·∫≠y", "i√¢y", "i·∫Øy", "i·∫±y", "i·∫≥y", "i·∫µy", "i·∫∑y", "iƒÉy"]},
            {key: "IC", forms: ["√≠c", "√¨c", "·ªâc", "ƒ©c", "·ªãc", "ic", "√≠c", "√¨c", "·ªâc", "ƒ©c", "·ªãc", "ic", "√≠c", "√¨c", "·ªâc", "ƒ©c", "·ªãc", "ic"]},
            {key: "ICH", forms: ["√≠ch", "√¨ch", "·ªâch", "ƒ©ch", "·ªãch", "ich", "√≠ch", "√¨ch", "·ªâch", "ƒ©ch", "·ªãch", "ich", "√≠ch", "√¨ch", "·ªâch", "ƒ©ch", "·ªãch", "ich"]},
            {key: "IE", forms: ["i√©", "i√®", "i·∫ª", "i·∫Ω", "i·∫π", "ie", "i·∫ø", "i·ªÅ", "i·ªÉ", "i·ªÖ", "i·ªá", "i√™", "i√©", "i√®", "i·∫ª", "i·∫Ω", "i·∫π", "ie"]},
            // ... (gi·ªØ nguy√™n b·∫£ng d·ªØ li·ªáu ƒë·∫ßy ƒë·ªß)
        ];

        // √Ånh x·∫° tr·∫°ng th√°i MPU
        const mpuStateMap = {
            "Up": 0,
            "Down": 1,
            "Left": 2,
            "Right": 3,
            "Forward": 4,
            "Backward": 5
        };

        // === TH∆Ø VI·ªÜN D·ªäCH THU·∫¨T & GI·ªåNG N√ìI M·ªöI ===
        
        // Th∆∞ vi·ªán c·ª•m t·ª´ ƒëa ng√¥n ng·ªØ
        const phraseLibrary = {
            "vi-VN": [
                "Xin ch√†o, r·∫•t vui ƒë∆∞·ª£c g·∫∑p b·∫°n.",
                "Ch√†o bu·ªïi s√°ng.",
                "B·∫°n t√™n l√† g√¨?",
                "T√¥i c√≥ th·ªÉ gi√∫p g√¨ kh√¥ng?",
                "Vui l√≤ng ki·ªÉm tra l·∫°i b√°o c√°o.",
                "H·∫°n ch√≥t l√† th·ª© S√°u.",
                "T√¥i ho√†n to√†n ƒë·ªìng √Ω.",
                "L√†m ∆°n cho t√¥i xem th·ª±c ƒë∆°n.",
                "L√†m ∆°n cho t√¥i xin h√≥a ƒë∆°n.",
                "M√≥n n√†y c√≥ cay kh√¥ng?",
                "ƒê∆∞·ªùng ƒë·∫øn b·∫£o t√†ng ƒëi th·∫ø n√†o?",
                "Ga t√†u c√°ch ƒë√¢y bao xa?",
                "C√°i n√†y gi√° bao nhi√™u?",
                "T√¥i c·∫ßn g·∫∑p b√°c sƒ©.",
                "L√†m ∆°n g·ªçi xe c·∫•p c·ª©u.",
                "B·∫°n c√≥ th·ªÉ h∆∞·ªõng d·∫´n t√¥i kh√¥ng?",
            ],
            "en-GB": [
                "Hello, nice to meet you.",
                "Good morning.",
                "What is your name?",
                "May I help you?",
                "Please double-check the report.",
                "The deadline is Friday.",
                "I completely agree.",
                "Please let me see the menu.",
                "Could I have the bill, please?",
                "Is this dish spicy?",
                "How do I get to the museum?",
                "How far is the train station?",
                "How much does this cost?",
                "I need to see a doctor.",
                "Please call an ambulance.",
                "Could you guide me?",
            ],
            "ja-JP": [
                "„Åì„Çì„Å´„Å°„ÅØ„ÄÅ„Åä‰ºö„ÅÑ„Åß„Åç„Å¶Â¨â„Åó„ÅÑ„Åß„Åô„ÄÇ",
                "„Åä„ÅØ„Çà„ÅÜ„Åî„Åñ„ÅÑ„Åæ„Åô„ÄÇ",
                "„ÅäÂêçÂâç„ÅØ‰Ωï„Åß„Åô„ÅãÔºü",
                "‰Ωï„Åã„ÅäÊâã‰ºù„ÅÑ„Åß„Åç„Åæ„Åô„ÅãÔºü",
                "„É¨„Éù„Éº„Éà„ÇíÂÜçÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                "Á∑†„ÇÅÂàá„Çä„ÅØÈáëÊõúÊó•„Åß„Åô„ÄÇ",
                "ÂÆåÂÖ®„Å´ÂêåÊÑè„Åó„Åæ„Åô„ÄÇ",
                "„É°„Éã„É•„Éº„ÇíË¶ã„Åõ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                "„Åä‰ºöË®à„Çí„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô„ÄÇ",
                "„Åì„ÅÆÊñôÁêÜ„ÅØËæõ„ÅÑ„Åß„Åô„ÅãÔºü",
                "ÂçöÁâ©È§®„Å´„ÅØ„Å©„ÅÜË°å„Åë„Å∞„ÅÑ„ÅÑ„Åß„Åô„ÅãÔºü",
                "ÈßÖ„Åæ„Åß„ÅØ„Å©„Çå„Åè„Çâ„ÅÑ„Åß„Åô„ÅãÔºü",
                "„Åì„Çå„ÅØ„ÅÑ„Åè„Çâ„Åß„Åô„ÅãÔºü",
                "ÂåªËÄÖ„Å´Ë®∫„Å¶„ÇÇ„Çâ„ÅÜÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ",
                "ÊïëÊÄ•Ëªä„ÇíÂëº„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ",
                "Ê°àÂÜÖ„Åó„Å¶„ÇÇ„Çâ„Åà„Åæ„Åô„ÅãÔºü",
            ],
            "ko-KR": [
                "ÏïàÎÖïÌïòÏÑ∏Ïöî, ÎßåÎÇòÏÑú Î∞òÍ∞ëÏäµÎãàÎã§.",
                "Ï¢ãÏùÄ ÏïÑÏπ®ÏûÖÎãàÎã§.",
                "Ïù¥Î¶ÑÏù¥ Î¨¥ÏóáÏù∏Í∞ÄÏöî?",
                "ÎèÑÏôÄÎìúÎ¶¥ÍπåÏöî?",
                "Î≥¥Í≥†ÏÑúÎ•º Îã§Ïãú ÌôïÏù∏Ìï¥ Ï£ºÏÑ∏Ïöî.",
                "ÎßàÍ∞êÏùºÏùÄ Í∏àÏöîÏùºÏûÖÎãàÎã§.",
                "Ï†ÑÏ†ÅÏúºÎ°ú ÎèôÏùòÌï©ÎãàÎã§.",
                "„É°„Éã„É•Î•º Î≥¥Ïó¨Ï£ºÏÑ∏Ïöî.",
                "Í≥ÑÏÇ∞ÏÑú Î∂ÄÌÉÅÎìúÎ¶ΩÎãàÎã§.",
                "Ïù¥ ÏöîÎ¶¨Îäî Îß§Ïö¥Í∞ÄÏöî?",
                "Î∞ïÎ¨ºÍ¥ÄÏóêÎäî Ïñ¥ÎñªÍ≤å Í∞ÄÎÇòÏöî?",
                "Í∏∞Ï∞®Ïó≠ÍπåÏßÄ ÏñºÎßàÎÇò Î©ÄÎÇòÏöî?",
                "Ïù¥Í≤ÉÏùÄ ÏñºÎßàÏù∏Í∞ÄÏöî?",
                "ÏùòÏÇ¨Î•º ÎßåÎÇòÏïº Ìï©ÎãàÎã§.",
                "Íµ¨Í∏âÏ∞®Î•º Î∂àÎü¨ Ï£ºÏÑ∏Ïöî.",
                "ÏïàÎÇ¥Ìï¥ Ï£ºÏãúÍ≤†Ïñ¥Ïöî?",
            ],
            "zh-CN": [
                "‰Ω†Â•ΩÔºåÂæàÈ´òÂÖ¥ËßÅÂà∞‰Ω†„ÄÇ",
                "Êó©‰∏äÂ•Ω„ÄÇ",
                "‰Ω†Âè´‰ªÄ‰πàÂêçÂ≠óÔºü",
                "ÊàëÂèØ‰ª•Â∏ÆÂøôÂêóÔºü",
                "ËØ∑ÂÜçÊ¨°Ê£ÄÊü•Êä•Âëä„ÄÇ",
                "Êà™Ê≠¢Êó•ÊúüÊòØÊòüÊúü‰∫î„ÄÇ",
                "ÊàëÂÆåÂÖ®ÂêåÊÑè„ÄÇ",
                "ËØ∑ËÆ©ÊàëÁúãÁúãËèúÂçï„ÄÇ",
                "ËØ∑ÁªôÊàëË¥¶Âçï„ÄÇ",
                "ËøôÈÅìËèúËæ£ÂêóÔºü",
                "ÂéªÂçöÁâ©È¶ÜÊÄé‰πàËµ∞Ôºü",
                "ÁÅ´ËΩ¶Á´ôÊúâÂ§öËøúÔºü",
                "Ëøô‰∏™Â§öÂ∞ëÈí±Ôºü",
                "ÊàëÈúÄË¶ÅÁúãÂåªÁîü„ÄÇ",
                "ËØ∑Âè´ÊïëÊä§ËΩ¶„ÄÇ",
                "‰Ω†ËÉΩÊåáÂØºÊàëÂêóÔºü",
            ]
        };

        // √Ånh x·∫° ng√¥n ng·ªØ
        const languageNames = {
            "vi-VN": { name: "Ti·∫øng Vi·ªát", code: "Vietnamese" },
            "en-GB": { name: "Ti·∫øng Anh", code: "English" },
            "ja-JP": { name: "Ti·∫øng Nh·∫≠t", code: "Japanese" },
            "ko-KR": { name: "Ti·∫øng H√†n", code: "Korean" },
            "zh-CN": { name: "Ti·∫øng Trung", code: "Chinese (Simplified)" }
        };

        // C·∫•u h√¨nh gi·ªçng n√≥i Gemini
        const voiceConfigs = {
            female: { 
                "vi-VN": "Aoede", 
                "en-GB": "Kore", 
                "ja-JP": "Leda", 
                "ko-KR": "Kore", 
                "zh-CN": "Aoede" 
            },
            male: { 
                "vi-VN": "Charon", 
                "en-GB": "Puck", 
                "ja-JP": "Fenrir", 
                "ko-KR": "Puck", 
                "zh-CN": "Zubenelgenubi" 
            }
        };

        // Bi·∫øn gi·ªçng n√≥i v√† TTS
        let isSpeaking = false;
        let isConnecting = false;
        let currentSpeech = null;
        let audioVisualizerInterval = null;
        let useGeminiTTS = true;
        let currentVoiceGender = "female";
        let currentVoice = {
            lang: 'vi-VN',
            gender: 'female'
        };

        // === H√ÄM HI·ªÜU CHU·∫®N ===
        function startCalibration() {
            if (isCalibrating) return;
            
            isCalibrating = true;
            calibrationCountdown = 10;
            calibrationStartTime = Date.now();
            calibrationMaxValues = [0, 0, 0, 0];
            calibrationCurrentSensor = 0;
            calibrationStep = "calibrating";
            
            // Hi·ªÉn th·ªã giao di·ªán hi·ªáu chu·∫©n
            document.getElementById('calibrationProgress').style.display = 'block';
            document.getElementById('calibrateBtn').style.display = 'none';
            document.getElementById('stopCalibrateBtn').style.display = 'inline-block';
            
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i
            updateCalibrationStatus("calibrating", "ƒêang hi·ªáu chu·∫©n... Vui l√≤ng u·ªën t·∫•t c·∫£ ng√≥n tay h·∫øt m·ª©c c√≥ th·ªÉ!");
            
            // T·∫°o display cho c√°c c·∫£m bi·∫øn
            const display = document.getElementById('calibrationDisplay');
            display.innerHTML = '';
            
            for (let i = 0; i < 4; i++) {
                const sensorDiv = document.createElement('div');
                sensorDiv.className = 'sensor-calibration';
                sensorDiv.id = `calibrationSensor${i}`;
                sensorDiv.innerHTML = `
                    <div class="sensor-name">C·∫¢M BI·∫æN ${i}</div>
                    <div class="sensor-value">0</div>
                    <div class="sensor-max">Max: 0</div>
                    <div class="progress-container">
                        <div class="progress-bar" id="progressBar${i}" style="width: 0%"></div>
                    </div>
                `;
                display.appendChild(sensorDiv);
            }
            
            // B·∫Øt ƒë·∫ßu ƒë·∫øm ng∆∞·ª£c
            calibrationInterval = setInterval(updateCalibration, 1000);
            
            // C·∫≠p nh·∫≠t th√¥ng b√°o
            document.getElementById('calibrationMessage').textContent = `ƒêang hi·ªáu chu·∫©n... Vui l√≤ng u·ªën T·∫§T C·∫¢ ng√≥n tay h·∫øt m·ª©c!`;
            
            log('HI·ªÜU CHU·∫®N', 'B·∫Øt ƒë·∫ßu hi·ªáu chu·∫©n c·∫£m bi·∫øn u·ªën');
        }

        function updateCalibration() {
            if (!isCalibrating) return;
            
            calibrationCountdown--;
            document.getElementById('calibrationCountdown').textContent = calibrationCountdown;
            
            // C·∫≠p nh·∫≠t thanh ti·∫øn tr√¨nh
            const progress = ((10 - calibrationCountdown) / 10) * 100;
            document.getElementById('calibrationProgressBar').style.width = `${progress}%`;
            
            // C·∫≠p nh·∫≠t gi√° tr·ªã c·∫£m bi·∫øn n·∫øu c√≥ d·ªØ li·ªáu
            if (firebaseData) {
                const flexValues = [firebaseData.f0 || 0, firebaseData.f1 || 0, firebaseData.f2 || 0, firebaseData.f3 || 0];
                
                for (let i = 0; i < 4; i++) {
                    // C·∫≠p nh·∫≠t gi√° tr·ªã hi·ªán t·∫°i
                    const valueElement = document.querySelector(`#calibrationSensor${i} .sensor-value`);
                    if (valueElement) {
                        valueElement.textContent = flexValues[i];
                    }
                    
                    // C·∫≠p nh·∫≠t gi√° tr·ªã l·ªõn nh·∫•t
                    if (flexValues[i] > calibrationMaxValues[i]) {
                        calibrationMaxValues[i] = flexValues[i];
                        const maxElement = document.querySelector(`#calibrationSensor${i} .sensor-max`);
                        if (maxElement) {
                            maxElement.textContent = `Max: ${flexValues[i]}`;
                            maxElement.style.color = '#F44336';
                        }
                    }
                    
                    // C·∫≠p nh·∫≠t thanh ti·∫øn tr√¨nh cho t·ª´ng c·∫£m bi·∫øn
                    const progressValue = Math.min((flexValues[i] / 1024) * 100, 100);
                    const progressBar = document.getElementById(`progressBar${i}`);
                    if (progressBar) {
                        progressBar.style.width = `${progressValue}%`;
                        
                        // Thay ƒë·ªïi m√†u d·ª±a tr√™n m·ª©c ƒë·ªô u·ªën
                        if (progressValue < 30) {
                            progressBar.style.background = '#4CAF50'; // Th·∫≥ng
                        } else if (progressValue < 70) {
                            progressBar.style.background = '#FF9800'; // H∆°i u·ªën
                        } else {
                            progressBar.style.background = '#F44336'; // U·ªën h·∫øt
                        }
                    }
                }
            }
            
            // Ki·ªÉm tra k·∫øt th√∫c hi·ªáu chu·∫©n
            if (calibrationCountdown <= 0) {
                finishCalibration();
            }
        }

        function finishCalibration() {
            isCalibrating = false;
            clearInterval(calibrationInterval);
            calibrationStep = "done";
            
            // C·∫≠p nh·∫≠t bentThresholds v·ªõi gi√° tr·ªã m·ªõi
            let hasValidCalibration = false;
            for (let i = 0; i < 4; i++) {
                if (calibrationMaxValues[i] > STRAIGHT_THRESHOLDS[i] + 50) {
                    bentThresholds[i] = calibrationMaxValues[i];
                    hasValidCalibration = true;
                } else {
                    log('HI·ªÜU CHU·∫®N', `C·∫£m bi·∫øn ${i} kh√¥ng c√≥ d·ªØ li·ªáu hi·ªáu chu·∫©n h·ª£p l·ªá (Max: ${calibrationMaxValues[i]})`);
                }
            }
            
            if (hasValidCalibration) {
                // L∆∞u hi·ªáu chu·∫©n v√†o localStorage
                localStorage.setItem('bentThresholds', JSON.stringify(bentThresholds));
                
                // C·∫≠p nh·∫≠t giao di·ªán v·ªõi ng∆∞·ª°ng m·ªõi
                updateThresholdDisplay();
                
                // C·∫≠p nh·∫≠t tr·∫°ng th√°i
                updateCalibrationStatus("calibrated", `Hi·ªáu chu·∫©n ho√†n th√†nh! Ng∆∞·ª°ng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.`);
                
                log('HI·ªÜU CHU·∫®N', `Hi·ªáu chu·∫©n ho√†n th√†nh: ${bentThresholds}`);
                
                // ·∫®n ph·∫ßn hi·ªáu chu·∫©n sau 3 gi√¢y
                setTimeout(() => {
                    document.getElementById('calibrationProgress').style.display = 'none';
                    document.getElementById('calibrateBtn').style.display = 'inline-block';
                    document.getElementById('stopCalibrateBtn').style.display = 'none';
                }, 3000);
            } else {
                updateCalibrationStatus("error", "Hi·ªáu chu·∫©n th·∫•t b·∫°i! Kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá. Vui l√≤ng th·ª≠ l·∫°i.");
                log('HI·ªÜU CHU·∫®N', 'Hi·ªáu chu·∫©n th·∫•t b·∫°i: Kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá');
                
                setTimeout(() => {
                    document.getElementById('calibrationProgress').style.display = 'none';
                    document.getElementById('calibrateBtn').style.display = 'inline-block';
                    document.getElementById('stopCalibrateBtn').style.display = 'none';
                }, 3000);
            }
        }

        function stopCalibration() {
            if (isCalibrating) {
                isCalibrating = false;
                clearInterval(calibrationInterval);
                
                updateCalibrationStatus("ready", "Hi·ªáu chu·∫©n ƒë√£ d·ª´ng");
                
                document.getElementById('calibrationProgress').style.display = 'none';
                document.getElementById('calibrateBtn').style.display = 'inline-block';
                document.getElementById('stopCalibrateBtn').style.display = 'none';
                
                log('HI·ªÜU CHU·∫®N', 'Hi·ªáu chu·∫©n ƒë√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng');
            }
        }

        function resetCalibration() {
            bentThresholds = [300, 450, 350, 300];
            localStorage.removeItem('bentThresholds');
            
            updateThresholdDisplay();
            updateCalibrationStatus("ready", "ƒê√£ reset v·ªÅ gi√° tr·ªã m·∫∑c ƒë·ªãnh");
            
            log('HI·ªÜU CHU·∫®N', 'Reset hi·ªáu chu·∫©n v·ªÅ gi√° tr·ªã m·∫∑c ƒë·ªãnh');
        }

        function loadCalibration() {
            const savedThresholds = localStorage.getItem('bentThresholds');
            if (savedThresholds) {
                try {
                    bentThresholds = JSON.parse(savedThresholds);
                    updateThresholdDisplay();
                    updateCalibrationStatus("calibrated", "ƒê√£ t·∫£i hi·ªáu chu·∫©n t·ª´ b·ªô nh·ªõ");
                    log('HI·ªÜU CHU·∫®N', `ƒê√£ t·∫£i hi·ªáu chu·∫©n: ${bentThresholds}`);
                } catch (e) {
                    log('HI·ªÜU CHU·∫®N', `L·ªói khi t·∫£i hi·ªáu chu·∫©n: ${e.message}`);
                }
            } else {
                updateCalibrationStatus("ready", "Kh√¥ng t√¨m th·∫•y hi·ªáu chu·∫©n ƒë√£ l∆∞u");
                log('HI·ªÜU CHU·∫®N', 'Kh√¥ng t√¨m th·∫•y hi·ªáu chu·∫©n ƒë√£ l∆∞u');
            }
        }

        function updateThresholdDisplay() {
            for (let i = 0; i < 4; i++) {
                document.getElementById(`currentThreshold${i}`).textContent = bentThresholds[i];
            }
        }

        function updateCalibrationStatus(status, message) {
            const statusDiv = document.getElementById('calibrationStatus');
            statusDiv.innerHTML = '';
            
            let statusClass = "";
            let statusText = "";
            
            switch(status) {
                case "calibrating":
                    statusClass = "calibrating";
                    statusText = "ƒêANG HI·ªÜU CHU·∫®N";
                    break;
                case "calibrated":
                    statusClass = "calibrated";
                    statusText = "ƒê√É HI·ªÜU CHU·∫®N";
                    break;
                case "error":
                    statusClass = "calibration-error";
                    statusText = "L·ªñI HI·ªÜU CHU·∫®N";
                    break;
                default:
                    statusClass = "calibration-ready";
                    statusText = "S·∫¥N S√ÄNG";
            }
            
            const div = document.createElement('div');
            div.className = statusClass;
            div.innerHTML = `
                <div>${statusText}</div>
                <div style="font-size: 0.9rem; margin-top: 5px;">${message}</div>
            `;
            statusDiv.appendChild(div);
        }

        // === H√ÄM T·ªêI ∆ØU H√ìA FIREBASE ===
        async function fetchFirebaseDataOptimized() {
            if (isFetching) return null;
            
            // H·ªßy request tr∆∞·ªõc n·∫øu ƒëang ch·∫°y
            if (currentFetchController) {
                currentFetchController.abort();
            }
            
            isFetching = true;
            const startTime = performance.now();
            currentFetchController = new AbortController();
            const signal = currentFetchController.signal;
            
            try {
                // Th√™m timestamp ƒë·ªÉ tr√°nh cache
                const timestamp = Date.now();
                const url = `${FIREBASE_URL}?t=${timestamp}`;
                
                const response = await fetch(url, {
                    signal,
                    method: 'GET',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    },
                    priority: 'high'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                const fetchTime = performance.now() - startTime;
                
                // C·∫≠p nh·∫≠t th√¥ng tin ƒë·ªô tr·ªÖ
                document.getElementById('latency').textContent = Math.round(fetchTime);
                
                // Ch·ªâ x·ª≠ l√Ω n·∫øu d·ªØ li·ªáu thay ƒë·ªïi
                if (JSON.stringify(data) !== JSON.stringify(lastFirebaseData)) {
                    lastFirebaseData = data;
                    firebaseData = data;
                    lastUpdateTime = Date.now();
                    
                    updateConnectionStatus(true);
                    
                    // X·ª≠ l√Ω nhanh, kh√¥ng ch·ªù UI update
                    processDataImmediately(data);
                    
                    // L√™n l·ªãch update UI cho frame ti·∫øp theo
                    scheduleUIUpdate();
                    
                    log('Firebase', `Data updated (${Math.round(fetchTime)}ms)`);
                    
                    // ƒêi·ªÅu ch·ªânh polling interval d·ª±a tr√™n t·ªëc ƒë·ªô
                    if (fetchTime < 100) {
                        pollingInterval = turboMode ? 150 : 250;
                    } else if (fetchTime > 500) {
                        pollingInterval = 1000;
                    }
                    
                    updatePollingDisplay();
                } else {
                    // Ch·ªâ c·∫≠p nh·∫≠t th·ªùi gian
                    lastUpdateTime = Date.now();
                    document.getElementById('lastUpdate').textContent = 
                        `C·∫≠p nh·∫≠t: ${formatTime(Date.now())}`;
                }
                
                return data;
                
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.warn('Fetch error:', error);
                    updateConnectionStatus(false);
                    log('Firebase', `Error: ${error.message}`);
                    
                    // TƒÉng interval khi c√≥ l·ªói
                    pollingInterval = Math.min(pollingInterval * 2, 5000);
                    updatePollingDisplay();
                }
                return null;
            } finally {
                isFetching = false;
                const totalTime = performance.now() - startTime;
                document.getElementById('processingTime').textContent = `${Math.round(totalTime)}ms`;
            }
        }

        function processDataImmediately(data) {
            const startTime = performance.now();
            
            // 1. C·∫≠p nh·∫≠t sensor data nhanh
            if (data.o !== undefined) {
                const mpuElement = document.getElementById('mpuOrientation');
                if (mpuElement.textContent !== data.o) {
                    mpuElement.textContent = data.o || 'N/A';
                }
            }
            
            if (data.d !== undefined) {
                const shakeElement = document.getElementById('mpuShakeState');
                if (shakeElement.textContent !== data.d) {
                    shakeElement.textContent = data.d || 'No';
                }
            }
            
            if (data.sf !== undefined) {
                const isShakingElement = document.getElementById('isShaking');
                if (isShakingElement.textContent !== data.sf) {
                    isShakingElement.textContent = data.sf || 'NO';
                }
            }
            
            // 2. C·∫≠p nh·∫≠t flex sensors nhanh
            if (data.f0 !== undefined) {
                const flexValues = [data.f0, data.f1 || 0, data.f2 || 0, data.f3 || 0];
                for (let i = 0; i < 4; i++) {
                    const newState = calculateFlexState(flexValues[i], i);
                    if (flexStates[i] !== newState) {
                        flexStates[i] = newState;
                    }
                }
            }
            
            // 3. X·ª≠ l√Ω word construction (b·∫•t ƒë·ªìng b·ªô)
            setTimeout(() => {
                const mpuState = getMPUState(data.o || "", data.d || "");
                const a0 = flexStates[0];
                const a1 = flexStates[1];
                const a2 = flexStates[2];
                const a3 = flexStates[3];
                
                processWordConstructionFast(mpuState, a0, a1, a2, a3);
            }, 0);
        }

        // === H√ÄM T√çNH TR·∫†NG TH√ÅI U·ªêN V·ªöI HI·ªÜU CHU·∫®N ===
        function calculateFlexState(rawValue, sensorIndex) {
            const STRAIGHT_THRESHOLD = STRAIGHT_THRESHOLDS[sensorIndex];
            
            if (rawValue <= STRAIGHT_THRESHOLD) return 0;
            if (rawValue <= bentThresholds[sensorIndex]) return 1;
            return 2;
        }

        function processWordConstructionFast(mpu, a0, a1, a2, a3) {
            const currentState = `${mpu}_${a0}_${a1}_${a2}_${a3}`;
            
            if (currentState !== lastStateString) {
                lastStateString = currentState;
                stableCount = 0;
                holdStartMs = Date.now();
                holdFired = false;
            } else {
                stableCount++;
            }
            
            lastFlexStates = [a0, a1, a2, a3];
            
            if (stableCount >= DEBOUNCE_COUNT) {
                const held = Date.now() - holdStartMs;
                if (!holdFired && held >= HOLD_MS_DEFAULT) {
                    if (Date.now() - lastActionMs > POST_HOLD_COOLDOWN) {
                        performActionSlotLogic(mpu, a0, a1, a2, a3);
                        holdFired = true;
                        lastActionMs = Date.now();
                    }
                }
            }
        }

        function scheduleUIUpdate() {
            if (!uiUpdateScheduled) {
                uiUpdateScheduled = true;
                requestAnimationFrame(() => {
                    updateCriticalUI();
                    uiUpdateScheduled = false;
                });
            }
        }

        function updateCriticalUI() {
            const startTime = performance.now();
            
            // Ch·ªâ c·∫≠p nh·∫≠t c√°c ph·∫ßn quan tr·ªçng
            updateSensorDisplay();
            updateWordDisplays();
            updateSentenceDisplay();
            
            // C·∫≠p nh·∫≠t th·ªùi gian
            const updateTime = document.getElementById('lastUpdate');
            const currentTime = formatTime(Date.now());
            if (updateTime.textContent !== `C·∫≠p nh·∫≠t: ${currentTime}`) {
                updateTime.textContent = `C·∫≠p nh·∫≠t: ${currentTime}`;
                document.getElementById('lastUpdateTime').textContent = currentTime;
            }
            
            const uiTime = performance.now() - startTime;
            if (uiTime > 16) {
                console.warn(`UI update slow: ${Math.round(uiTime)}ms`);
            }
        }

        function updateSensorDisplay() {
            // C·∫≠p nh·∫≠t flex boxes n·∫øu c·∫ßn
            for (let i = 0; i < 4; i++) {
                const box = document.getElementById(`flex${i}-box`);
                if (box && box.textContent !== flexStates[i].toString()) {
                    box.textContent = flexStates[i];
                    box.className = `flex-box active-${flexStates[i]}`;
                }
            }
            
            // C·∫≠p nh·∫≠t raw values
            if (firebaseData) {
                const rawValues = [firebaseData.f0 || 0, firebaseData.f1 || 0, firebaseData.f2 || 0, firebaseData.f3 || 0];
                const rawValuesElement = document.getElementById('rawValues');
                const newRawText = rawValues.join(', ');
                if (rawValuesElement.textContent !== newRawText) {
                    rawValuesElement.textContent = newRawText;
                }
                
                const flexFormatElement = document.getElementById('flexFormat');
                const newFlexText = flexStates.join('');
                if (flexFormatElement.textContent !== newFlexText) {
                    flexFormatElement.textContent = newFlexText;
                }
            }
        }

        function updateWordDisplays() {
            // T√çNH convertedCurrentWord T·ª™ displayBuffer
            if (displayBuffer.length > 0) {
                convertedCurrentWord = convertVietnameseWordCached(displayBuffer);
            } else {
                convertedCurrentWord = "";
            }

            // Ho√°n ƒë·ªïi hi·ªÉn th·ªã
            const displayBufferElement = document.getElementById('displayBuffer');
            if (displayBufferElement.textContent !== convertedCurrentWord) {
                displayBufferElement.textContent = convertedCurrentWord || '---';
            }
            
            const slot1Element = document.getElementById('slot1');
            if (slot1Element.textContent !== slot1) {
                slot1Element.textContent = slot1 || '---';
            }
            
            const slot2Element = document.getElementById('slot2');
            if (slot2Element.textContent !== slot2) {
                slot2Element.textContent = slot2 || '---';
            }
            
            const convertedWordElement = document.getElementById('convertedCurrentWord');
            if (convertedWordElement.textContent !== displayBuffer) {
                convertedWordElement.textContent = displayBuffer || '---';
            }
        }

        function updateSentenceDisplay() {
            const sentenceElement = document.getElementById('sentenceDisplay');
            const newSentence = sentenceWords.join(' ');
            
            if (fullSentence !== newSentence) {
                fullSentence = newSentence;
                sentenceElement.textContent = fullSentence || '---';
                
                // Convert sentence
                convertedFullSentence = convertVietnameseTextFast(fullSentence);
                const convertedElement = document.getElementById('convertedSentenceDisplay');
                convertedElement.textContent = convertedFullSentence || '---';
                
                // C·∫≠p nh·∫≠t word list
                updateWordList();
                
                // C·∫≠p nh·∫≠t word count
                const wordCountElement = document.getElementById('wordCount');
                wordCountElement.textContent = sentenceWords.length;
                
                // Hi·ªÉn th·ªã ƒë·ªÅ xu·∫•t t·ª± ƒë·ªông
                showAutoSuggestions();
            }
        }

        function updateWordList() {
            const wordListDiv = document.getElementById('wordList');
            if (sentenceWords.length > 0) {
                wordListDiv.innerHTML = sentenceWords.map(word => 
                    `<div class="word-item">${word}</div>`
                ).join('');
            } else {
                wordListDiv.innerHTML = 'Ch∆∞a c√≥ t·ª´ n√†o';
            }
        }

        // === H√ÄM CACHE V√Ä T·ªêI ∆ØU ===
        function convertVietnameseWordCached(encodedWord) {
            if (!encodedWord || encodedWord.length === 0) return "";
            
            if (vietnameseCache.has(encodedWord)) {
                return vietnameseCache.get(encodedWord);
            }
            
            const result = convertVietnameseWordOriginal(encodedWord);
            vietnameseCache.set(encodedWord, result);
            return result;
        }

        // H√ÄM CHUY·ªÇN ƒê·ªîI CH√çNH
        function convertVietnameseWordOriginal(encodedWord) {
            if (!encodedWord || encodedWord.length === 0) return "";
            
            // Format: b_0inh_s
            const parts = encodedWord.split('_');
            if (parts.length !== 3) return encodedWord;
            
            const consonant = parts[0];
            const middle = parts[1];
            const vowelTypeStr = parts[2];
            
            if (middle.length < 2) return encodedWord;
            
            const toneChar = middle[0];
            const vowelKey = middle.substring(1);
            
            // Ki·ªÉm tra tone (0-5 t∆∞∆°ng ·ª©ng v·ªõi 1-6 trong b·∫£ng)
            let tone = parseInt(toneChar);
            if (isNaN(tone) || tone < 0 || tone > 5) {
                return encodedWord;
            }
            
            // Chuy·ªÉn t·ª´ 0-5 th√†nh 1-6 cho b·∫£ng
            tone = tone + 1;
            
            // X√°c ƒë·ªãnh lo·∫°i nguy√™n √¢m (s=0, b=6, p=12)
            let vowelType = 0;
            if (vowelTypeStr === "b") {
                vowelType = 1;
            } else if (vowelTypeStr === "p") {
                vowelType = 2;
            } else if (vowelTypeStr !== "s") {
                return encodedWord;
            }
            
            // T√≠nh index trong m·∫£ng forms: (tone-1) + (vowelType * 6)
            const tableIndex = (tone - 1) + (vowelType * 6);
            
            if (tableIndex < 0 || tableIndex >= 18) {
                return encodedWord;
            }
            
            // T√¨m vowelKey trong b·∫£ng
            const vowelKeyUpper = vowelKey.toUpperCase();
            
            for (let i = 0; i < vietnameseTable.length; i++) {
                if (vowelKeyUpper === vietnameseTable[i].key) {
                    const convertedVowel = vietnameseTable[i].forms[tableIndex];
                    return consonant + convertedVowel;
                }
            }
            
            return encodedWord;
        }

        function convertVietnameseTextFast(encodedText) {
            if (!encodedText || encodedText.length === 0) return "";
            
            const words = encodedText.split(' ');
            const convertedWords = words.map(word => convertVietnameseWordCached(word));
            return convertedWords.join(' ');
        }

        function getMappingForIndicesCached(mpuState, a0, a1, a2, a3) {
            const cacheKey = `${mpuState}_${a0}_${a1}_${a2}_${a3}`;
            
            if (mappingCache.has(cacheKey)) {
                return mappingCache.get(cacheKey);
            }
            
            const result = getMappingForIndicesOriginal(mpuState, a0, a1, a2, a3);
            mappingCache.set(cacheKey, result);
            return result;
        }

        function getMappingForIndicesOriginal(mpuState, a0, a1, a2, a3) {
            if (mpuState < 0 || mpuState > 7) return null;
            
            if (a3 === 2) {
                if (a0 < 3 && a1 < 3 && a2 < 3) {
                    return tableC[a0][a1][a2];
                }
                return null;
            }
            
            const a3bin = a3 === 1 ? 1 : 0;
            if (a1 < 0 || a1 >= 3 || a2 < 0 || a2 >= 3) return null;
            
            const flatIndex = a1 * 3 + a2;
            
            if (flatIndex >= 0 && flatIndex < 9) {
                return a3bin === 0 ? tableA[mpuState][flatIndex] : tableB[mpuState][flatIndex];
            }
            
            return null;
        }

        // === H√ÄM H·ªñ TR·ª¢ ===
        function log(source, message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = { timestamp, source, message };
            
            logEntries.unshift(logEntry);
            if (logEntries.length > MAX_LOG_ENTRIES) {
                logEntries.pop();
            }
            
            updateLogDisplay();
        }

        function updateLogDisplay() {
            const logContainer = document.getElementById('logContainer');
            const visibleEntries = logEntries.slice(0, 5);
            
            logContainer.innerHTML = visibleEntries.map(entry => 
                `<div class="log-entry">
                    <span style="color: #666; font-size: 0.8rem;">[${entry.timestamp}] ${entry.source}:</span>
                    <span style="color: #333;"> ${entry.message}</span>
                </div>`
            ).join('');
        }

        function clearLog() {
            logEntries = [];
            updateLogDisplay();
        }

        function exportLog() {
            const logText = logEntries.map(entry => 
                `[${entry.timestamp}] ${entry.source}: ${entry.message}`
            ).join('\n');
            
            const blob = new Blob([logText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `log_${new Date().toISOString().slice(0, 10)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            const firebaseStatus = document.getElementById('firebaseStatus');
            
            if (connected) {
                indicator.className = 'indicator online';
                statusText.textContent = 'ƒê√£ k·∫øt n·ªëi v·ªõi Firebase';
                firebaseStatus.textContent = 'ƒê√£ k·∫øt n·ªëi v·ªõi Firebase';
                firebaseStatus.style.color = '#4CAF50';
            } else {
                indicator.className = 'indicator';
                indicator.style.background = '#F44336';
                statusText.textContent = 'M·∫•t k·∫øt n·ªëi v·ªõi Firebase';
                firebaseStatus.textContent = 'M·∫•t k·∫øt n·ªëi v·ªõi Firebase';
                firebaseStatus.style.color = '#F44336';
            }
        }

        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        function getMPUState(orientation, shakeState) {
            if (shakeState === "Shake Left") return 6;
            if (shakeState === "Shake Right") return 7;
            
            switch(orientation) {
                case "Up": return 0;
                case "Down": return 1;
                case "Left": return 2;
                case "Right": return 3;
                case "Forward": return 4;
                case "Backward": return 5;
                default: return -1;
            }
        }

        // === H√ÄM X√ÇY D·ª∞NG C√ÇU ===
        function performActionSlotLogic(mpu, a0, a1, a2, a3) {
            const mapping = getMappingForIndicesCached(mpu, a0, a1, a2, a3);
            if (!mapping || mapping === "nullptr") return false;
            
            // Khi mapping l√† "_" (d·∫•u c√°ch), t·ª± ƒë·ªông th√™m t·ª´ v√†o c√¢u
            if (mapping === "_") {
                if (displayBuffer && displayBuffer.length > 0 && displayBuffer !== "---") {
                    addWordToSentence();
                } else {
                    log('WORD', 'D·∫•u c√°ch ƒë∆∞·ª£c ph√°t hi·ªán, nh∆∞ng kh√¥ng c√≥ t·ª´ trong b·ªô ƒë·ªám');
                }
                return true;
            }
            
            if (mapping === "COMMIT") {
                commitSentence();
                return true;
            }
            
            if (mapping === "<") {
                backspaceBuffer();
                scheduleUIUpdate();
                return true;
            }
            
            const isSlot1 = (a3 === 2);
            const held = Date.now() - holdStartMs;
            
            if (isSlot1 && stableCount >= DEBOUNCE_COUNT && held < HOLD_MS_DEFAULT) {
                const mode = flexModeCharFromA0(a0);
                slot2 = `${mapping}_${mode}`;
            } else if (isSlot1) {
                slot1 = `${mapping}_${mpu}`;
            } else {
                const mode = flexModeCharFromA0(a0);
                slot2 = `${mapping}_${mode}`;
            }
            
            updateDisplayBufferFromSlots();
            log('WORD', `H√†nh ƒë·ªông: ${displayBuffer}`);
            return true;
        }

        function flexModeCharFromA0(a0) {
            switch(a0) {
                case 0: return 's';
                case 1: return 'b';
                case 2: return 'p';
                default: return 'x';
            }
        }

        function updateDisplayBufferFromSlots() {
            const oldBuffer = displayBuffer;
            displayBuffer = '';
            
            if (slot1) displayBuffer += slot1.toLowerCase();
            if (slot2) displayBuffer += slot2.toLowerCase();
            
            if (oldBuffer !== displayBuffer) {
                scheduleUIUpdate();
                log('WORD', `ƒê√£ c·∫≠p nh·∫≠t: ${displayBuffer}`);
            }
        }

        function addWordToSentence() {
            if (!displayBuffer || displayBuffer === "---" || displayBuffer.length === 0) {
                log('SENTENCE', 'Kh√¥ng th·ªÉ th√™m t·ª´ tr·ªëng v√†o c√¢u');
                return;
            }
            
            if (sentenceWords.length < 10) {
                sentenceWords.push(displayBuffer);
                scheduleUIUpdate();
                log('SENTENCE', `ƒê√£ th√™m: '${displayBuffer}'`);
                
                // X√≥a ƒë·ªÉ nh·∫≠p t·ª´ ti·∫øp theo
                slot1 = '';
                slot2 = '';
                displayBuffer = '';
                convertedCurrentWord = '';
                
                scheduleUIUpdate();
            } else {
                log('SENTENCE', 'C√¢u ƒë√£ ƒë·∫ßy! T·ªëi ƒëa 10 t·ª´.');
            }
        }

        function commitSentence() {
            if (sentenceWords.length === 0) {
                log('SENTENCE', 'Kh√¥ng c√≥ t·ª´ n√†o ƒë·ªÉ ho√†n th√†nh!');
                return;
            }
            
            // N·∫øu c√≥ t·ª´ trong b·ªô ƒë·ªám, th√™m n√≥ tr∆∞·ªõc
            if (displayBuffer && displayBuffer.length > 0 && displayBuffer !== "---") {
                addWordToSentence();
            }
            
            log('SENTENCE', '=== C√ÇU ƒê√É HO√ÄN TH√ÄNH ===');
            log('SENTENCE', `ƒê·∫ßy ƒë·ªß: ${fullSentence}`);
            log('CONVERSION', `ƒê√£ chuy·ªÉn ƒë·ªïi: ${convertedFullSentence}`);
            
            // T·ª± ƒë·ªông d·ªãch c√¢u
            if (convertedFullSentence && convertedFullSentence !== "---") {
                document.getElementById('translationInput').value = convertedFullSentence;
                setTimeout(() => {
                    translateSentence();
                }, 500);
            }
            
            resetSentence();
        }

        function resetSentence() {
            sentenceWords = [];
            fullSentence = '';
            convertedFullSentence = '';
            slot1 = '';
            slot2 = '';
            displayBuffer = '';
            convertedCurrentWord = '';
            
            document.getElementById('autoSuggestionsPanel').style.display = 'none';
            document.getElementById('dynamicSuggestions').innerHTML = '';
            document.getElementById('dynamicSuggestions').classList.remove('show');
            
            log('SENTENCE', 'ƒê√£ ƒë·∫∑t l·∫°i c√¢u');
            scheduleUIUpdate();
        }

        function clearCurrentWord() {
            slot1 = '';
            slot2 = '';
            displayBuffer = '';
            convertedCurrentWord = '';
            
            document.getElementById('dynamicSuggestions').innerHTML = '';
            document.getElementById('dynamicSuggestions').classList.remove('show');
            
            scheduleUIUpdate();
            log('WORD', 'ƒê√£ x√≥a t·ª´ hi·ªán t·∫°i');
        }

        function backspaceBuffer() {
            if (displayBuffer.length > 0) {
                displayBuffer = displayBuffer.slice(0, -1);
                log('WORD', `X√≥a k√Ω t·ª± - B·ªô ƒë·ªám: ${displayBuffer}`);
            }
        }

        function backspace() {
            backspaceBuffer();
            scheduleUIUpdate();
        }

        // === H√ÄM ƒêI·ªÄU KHI·ªÇN ===
        function refreshData() {
            fetchFirebaseDataOptimized();
        }

        function toggleAutoRefresh() {
            autoRefresh = !autoRefresh;
            const btn = document.getElementById('autoRefreshBtn');
            
            if (autoRefresh) {
                btn.textContent = `T·ª± ƒë·ªông: B·∫¨T (${pollingInterval}ms)`;
                btn.className = 'green';
                
                // D√πng recursive setTimeout thay v√¨ setInterval
                function scheduleNextRefresh() {
                    if (!autoRefresh) return;
                    
                    setTimeout(() => {
                        if (autoRefresh) {
                            fetchFirebaseDataOptimized().then(() => {
                                if (autoRefresh) {
                                    scheduleNextRefresh();
                                }
                            });
                        }
                    }, pollingInterval);
                }
                
                scheduleNextRefresh();
                log('SYSTEM', `B·∫≠t t·ª± ƒë·ªông l√†m m·ªõi ${pollingInterval}ms`);
            } else {
                btn.textContent = 'T·ª± ƒë·ªông: T·∫ÆT';
                btn.className = 'red';
                log('SYSTEM', 'T·∫Øt t·ª± ƒë·ªông l√†m m·ªõi');
            }
        }

        function toggleTurboMode() {
            turboMode = !turboMode;
            const btn = document.getElementById('turboBtn');
            
            if (turboMode) {
                pollingInterval = 150;
                btn.textContent = 'üöÄ Turbo: B·∫¨T';
                btn.className = 'red';
                document.getElementById('fastModeIndicator').style.display = 'block';
                log('SYSTEM', 'B·∫≠t ch·∫ø ƒë·ªô Turbo (150ms polling)');
            } else {
                pollingInterval = 300;
                btn.textContent = 'üöÄ Ch·∫ø ƒë·ªô Turbo';
                btn.className = 'green';
                document.getElementById('fastModeIndicator').style.display = 'none';
                log('SYSTEM', 'T·∫Øt ch·∫ø ƒë·ªô Turbo');
            }
            
            updatePollingDisplay();
            
            // N·∫øu auto refresh ƒëang b·∫≠t, c·∫≠p nh·∫≠t l·∫°i
            if (autoRefresh) {
                toggleAutoRefresh();
                toggleAutoRefresh(); // B·∫≠t l·∫°i v·ªõi interval m·ªõi
            }
        }

        function updatePollingDisplay() {
            document.getElementById('pollingRate').textContent = pollingInterval;
            const btn = document.getElementById('autoRefreshBtn');
            if (autoRefresh) {
                btn.textContent = `T·ª± ƒë·ªông: B·∫¨T (${pollingInterval}ms)`;
            }
        }

        // === H√ÄM D·ªäCH THU·∫¨T & GI·ªåNG N√ìI N√ÇNG CAO ===
        
        function setVoiceGender(gender) {
            currentVoiceGender = gender;
            currentVoice.gender = gender;
            
            document.querySelectorAll('.voice-gender-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            updateUI();
            log('VOICE', `ƒê√£ ch·ªçn gi·ªçng: ${gender === 'female' ? 'N·ªØ' : 'Nam'}`);
        }

        function swapLanguages() {
            const sourceLang = document.getElementById('sourceLanguage').value;
            const targetLang = document.getElementById('targetLanguage').value;
            
            document.getElementById('sourceLanguage').value = targetLang;
            document.getElementById('targetLanguage').value = sourceLang;
            
            const inputText = document.getElementById('translationInput').value;
            const outputText = document.getElementById('translationOutput').textContent;
            
            if (outputText && !outputText.includes('ƒêang ch·ªù d·ªãch') && !outputText.includes('Vui l√≤ng nh·∫≠p')) {
                document.getElementById('translationInput').value = outputText;
                document.getElementById('translationOutput').textContent = inputText || 'ƒêang ch·ªù d·ªãch...';
                document.getElementById('translationOutput').className = 'conversion-display';
            }
            
            log('TRANSLATION', `ƒê√£ ƒë·ªïi chi·ªÅu d·ªãch: ${sourceLang} ‚Üî ${targetLang}`);
        }

        let translationTimeout = null;
        const TRANSLATION_DEBOUNCE = 1000;

        function handleTranslationInput() {
            const textarea = document.getElementById('translationInput');
            const text = textarea.value;
            const sourceLang = document.getElementById('sourceLanguage').value;
            
            // Hi·ªÉn th·ªã ƒë·ªÅ xu·∫•t
            showTranslationSuggestions(text, sourceLang);
            
            // T·ª± ƒë·ªông d·ªãch n·∫øu b·∫≠t
            const autoTranslate = document.getElementById('autoTranslate').checked;
            if (autoTranslate && text.trim().length > 0) {
                if (translationTimeout) {
                    clearTimeout(translationTimeout);
                }
                
                translationTimeout = setTimeout(() => {
                    translateSentence();
                }, TRANSLATION_DEBOUNCE);
            }
        }

        function showTranslationSuggestions(text, sourceLang) {
            const suggestionsDiv = document.getElementById('translationSuggestions');
            
            if (!text || text.trim().length === 0) {
                suggestionsDiv.classList.remove('show');
                return;
            }
            
            const currentLibrary = phraseLibrary[sourceLang] || [];
            const filteredPhrases = currentLibrary.filter(phrase => 
                phrase.toLowerCase().includes(text.toLowerCase()) && phrase !== text
            );
            
            if (filteredPhrases.length > 0) {
                suggestionsDiv.innerHTML = filteredPhrases.slice(0, 5).map(phrase => `
                    <div class="suggestion-dropdown-item" onclick="selectTranslationSuggestion('${phrase.replace(/'/g, "\\'")}')">
                        ${phrase}
                    </div>
                `).join('');
                suggestionsDiv.classList.add('show');
            } else {
                suggestionsDiv.classList.remove('show');
            }
        }

        function selectTranslationSuggestion(phrase) {
            document.getElementById('translationInput').value = phrase;
            document.getElementById('translationSuggestions').classList.remove('show');
            
            const autoTranslate = document.getElementById('autoTranslate').checked;
            if (autoTranslate) {
                translateSentence();
            }
            
            log('SUGGESTION', `ƒê√£ ch·ªçn ƒë·ªÅ xu·∫•t: "${phrase}"`);
        }

        // H√†m d·ªãch v·ªõi Gemini AI
        async function translateWithAI(text, sourceLang, targetLang) {
            const apiKey = GEMINI_API_KEY;
            const url = `${GEMINI_TRANSLATE_URL}?key=${apiKey}`;
            
            const sourceName = languageNames[sourceLang]?.code || sourceLang;
            const targetName = languageNames[targetLang]?.code || targetLang;
            
            try {
                const response = await fetch(url, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: `Translate from ${sourceName} to ${targetName}. 
                                Maintain natural and formal tone. Output ONLY the translated text, no quotes, no extra notes.
                                Text: "${text}"`
                            }]
                        }]
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                let translated = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
                translated = translated.replace(/^["']|["']$/g, '');
                return translated;
            } catch (error) {
                console.error("AI Translation Error:", error);
                throw error;
            }
        }

        async function translateSentence() {
            const textarea = document.getElementById('translationInput');
            const text = textarea.value.trim();
            const sourceLang = document.getElementById('sourceLanguage').value;
            const targetLang = document.getElementById('targetLanguage').value;
            const outputDiv = document.getElementById('translationOutput');
            
            if (!text) {
                outputDiv.innerHTML = '<span style="color: #F44336;">Vui l√≤ng nh·∫≠p vƒÉn b·∫£n ƒë·ªÉ d·ªãch!</span>';
                outputDiv.className = 'conversion-display error';
                return;
            }
            
            const cacheKey = text + '|' + sourceLang + '|' + targetLang;
            if (translationCache[cacheKey]) {
                outputDiv.innerHTML = translationCache[cacheKey];
                outputDiv.className = 'conversion-display success';
                return;
            }
            
            outputDiv.innerHTML = '<span class="loading">ƒêang d·ªãch v·ªõi AI... ‚è≥</span>';
            outputDiv.className = 'conversion-display loading';
            
            try {
                const translated = await translateWithAI(text, sourceLang, targetLang);
                translationCache[cacheKey] = translated;
                outputDiv.innerHTML = translated;
                outputDiv.className = 'conversion-display success';
                log('TRANSLATION', `ƒê√£ d·ªãch t·ª´ ${sourceLang} sang ${targetLang}: ${translated.substring(0, 50)}...`);
            } catch (error) {
                console.error('Translation error:', error);
                outputDiv.innerHTML = '<span style="color: #F44336;">D·ªãch thu·∫≠t th·∫•t b·∫°i. Vui l√≤ng th·ª≠ l·∫°i sau.</span>';
                outputDiv.className = 'conversion-display error';
            }
        }

        function clearTranslation() {
            document.getElementById('translationOutput').innerHTML = 'ƒêang ch·ªù d·ªãch...';
            document.getElementById('translationOutput').className = 'conversion-display';
            document.getElementById('translationInput').value = '';
            translationCache = {};
        }

        // === H√ÄM TTS N√ÇNG CAO ===
        const pcmToWav = (base64PCM, sampleRate = 24000) => {
            if (!base64PCM) return null;
            try {
                const normalizedBase64 = base64PCM.trim().replace(/\s/g, '');
                const binaryString = atob(normalizedBase64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                const wavHeader = new ArrayBuffer(44);
                const view = new DataView(wavHeader);
                const writeString = (view, offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };

                writeString(view, 0, "RIFF");
                view.setUint32(4, 36 + len, true);
                writeString(view, 8, "WAVE");
                writeString(view, 12, "fmt ");
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, 1, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * 2, true);
                view.setUint16(32, 2, true);
                view.setUint16(34, 16, true);
                writeString(view, 36, "data");
                view.setUint32(40, len, true);

                return new Blob([wavHeader, bytes], { type: "audio/wav" });
            } catch (e) {
                console.error("PCM to WAV conversion failed", e);
                return null;
            }
        };

        async function speakWithRetry(text, langCode, retries = 5) {
            const voiceName = voiceConfigs[currentVoice.gender]?.[langCode] || 
                            (currentVoice.gender === 'male' ? 'Aoede' : 'Kore');
            
            const maxRetries = 5;
            const delays = [1000, 2000, 4000, 8000, 16000];
            
            const cleanText = text.replace(/[*_#]/g, '').trim();
            
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(
                        `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                contents: [{ 
                                    role: "user",
                                    parts: [{ text: `Say this naturally in a clear voice: ${cleanText}` }] 
                                }],
                                generationConfig: {
                                    responseModalities: ["AUDIO"],
                                    speechConfig: {
                                        voiceConfig: { 
                                            prebuiltVoiceConfig: { 
                                                voiceName: voiceName 
                                            } 
                                        }
                                    }
                                }
                            }),
                        }
                    );
                    
                    if (!response.ok) {
                        const errData = await response.json().catch(() => ({}));
                        throw new Error(errData.error?.message || `HTTP ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const candidate = data.candidates?.[0];
                    if (!candidate) throw new Error("No candidates found in response");
                    
                    const part = candidate.content?.parts?.find(p => p.inlineData && p.inlineData.data);
                    const audioData = part?.inlineData?.data;
                    
                    if (audioData) return audioData;
                    throw new Error("Kh√¥ng nh·∫≠n ƒë∆∞·ª£c d·ªØ li·ªáu √¢m thanh t·ª´ AI.");
                } catch (err) {
                    if (i === retries - 1) throw err;
                    await new Promise(r => setTimeout(r, delays[i]));
                }
            }
        }

        function toggleTTSMode(useGemini) {
            useGeminiTTS = useGemini;
            
            document.getElementById('useGeminiTTS').classList.toggle('active', useGemini);
            document.getElementById('useWebSpeech').classList.toggle('active', !useGemini);
            
            updateUI();
            log('TTS', `Chuy·ªÉn sang ${useGemini ? 'Gemini AI' : 'Web Speech'} TTS`);
        }

        function updateSpeechStatus(status, message) {
            const statusDiv = document.getElementById('speechStatus');
            const indicator = statusDiv.querySelector('.speech-status-indicator');
            const text = document.getElementById('speechStatusText');
            
            statusDiv.style.display = 'flex';
            statusDiv.className = `speech-status ${status}`;
            indicator.className = `speech-status-indicator ${status}`;
            text.textContent = message;
            
            if (status === 'idle') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 1000);
            }
        }

        async function speakText(text, langCode) {
            if (isSpeaking) {
                stopAllSpeech();
                return;
            }
            
            if (!text || text.trim().length === 0) {
                log('SPEECH', 'Kh√¥ng c√≥ vƒÉn b·∫£n ƒë·ªÉ ƒë·ªçc');
                return;
            }
            
            if (useGeminiTTS && GEMINI_API_KEY) {
                await speakWithGeminiTTS(text, langCode);
            } else {
                speakWithWebSpeech(text, langCode);
            }
        }

        async function speakWithGeminiTTS(text, langCode) {
            if (!GEMINI_API_KEY) {
                speakWithWebSpeech(text, langCode);
                return;
            }
            
            try {
                setIsSpeaking(true);
                updateSpeechStatus('connecting', 'ƒêang k·∫øt n·ªëi v·ªõi AI...');
                
                const audioDataBase64 = await speakWithRetry(text, langCode);
                const wavBlob = pcmToWav(audioDataBase64);
                if (!wavBlob) {
                    throw new Error("Audio generation failed");
                }

                const audioUrl = URL.createObjectURL(wavBlob);
                const audio = new Audio(audioUrl);
                currentSpeech = audio;
                
                audio.onplay = () => {
                    updateSpeechStatus('speaking', 'ƒêang ph√°t √¢m thanh...');
                    startAudioVisualizer();
                    log('SPEECH', `B·∫Øt ƒë·∫ßu Gemini TTS: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`);
                };
                
                audio.onended = () => {
                    setIsSpeaking(false);
                    updateSpeechStatus('idle', 'Ho√†n th√†nh');
                    URL.revokeObjectURL(audioUrl);
                    stopAudioVisualizer();
                    log('SPEECH', 'K·∫øt th√∫c Gemini TTS');
                };
                
                audio.onerror = () => {
                    setIsSpeaking(false);
                    updateSpeechStatus('error', 'L·ªói ph√°t √¢m thanh');
                    URL.revokeObjectURL(audioUrl);
                    stopAudioVisualizer();
                    log('SPEECH', 'L·ªói Gemini TTS');
                };
                
                await audio.play();
                
            } catch (error) {
                console.error('Gemini TTS error:', error);
                setIsSpeaking(false);
                updateSpeechStatus('error', `L·ªói: ${error.message}`);
                log('SPEECH', `Gemini TTS th·∫•t b·∫°i: ${error.message}`);
                
                // Fallback to Web Speech
                speakWithWebSpeech(text, langCode);
            }
        }

        function speakWithWebSpeech(text, langCode) {
            if (isSpeaking) {
                stopAllSpeech();
                return;
            }
            
            if (!('speechSynthesis' in window)) {
                updateSpeechStatus('error', 'Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ t·ªïng h·ª£p gi·ªçng n√≥i');
                log('SPEECH', 'Speech synthesis not supported in this browser');
                return;
            }
            
            window.speechSynthesis.cancel();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = langCode;
            utterance.rate = 0.9;
            utterance.pitch = currentVoice.gender === 'male' ? 0.8 : 1.2;
            utterance.volume = 1;
            
            utterance.onstart = function() {
                setIsSpeaking(true);
                updateSpeechStatus('speaking', 'ƒêang ph√°t √¢m thanh...');
                startAudioVisualizer();
                log('SPEECH', `B·∫Øt ƒë·∫ßu Web Speech: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`);
            };
            
            utterance.onend = function() {
                setIsSpeaking(false);
                updateSpeechStatus('idle', 'Ho√†n th√†nh');
                currentSpeech = null;
                stopAudioVisualizer();
                log('SPEECH', 'K·∫øt th√∫c Web Speech');
            };
            
            utterance.onerror = function(event) {
                setIsSpeaking(false);
                updateSpeechStatus('error', 'L·ªói ph√°t √¢m thanh');
                currentSpeech = null;
                stopAudioVisualizer();
                log('SPEECH', `L·ªói Web Speech: ${event.error}`);
            };
            
            currentSpeech = utterance;
            window.speechSynthesis.speak(utterance);
        }

        function setIsSpeaking(speaking) {
            isSpeaking = speaking;
            updateUI();
        }

        function stopAllSpeech() {
            if (window.speechSynthesis) {
                window.speechSynthesis.cancel();
            }
            
            if (currentSpeech && currentSpeech.pause) {
                currentSpeech.pause();
                currentSpeech.currentTime = 0;
            }
            
            setIsSpeaking(false);
            currentSpeech = null;
            stopAudioVisualizer();
            updateUI();
            updateSpeechStatus('idle', 'ƒê√£ d·ª´ng');
            
            log('SPEECH', 'ƒê√£ d·ª´ng t·∫•t c·∫£ gi·ªçng n√≥i');
        }

        function startAudioVisualizer() {
            stopAudioVisualizer();
            
            const visualizer = document.getElementById('audioVisualizer');
            visualizer.innerHTML = '';
            
            for (let i = 0; i < 20; i++) {
                const bar = document.createElement('div');
                bar.className = 'audio-bar';
                bar.style.height = '5px';
                visualizer.appendChild(bar);
            }
            
            const bars = visualizer.querySelectorAll('.audio-bar');
            audioVisualizerInterval = setInterval(() => {
                bars.forEach(bar => {
                    const height = 5 + Math.random() * 35;
                    bar.style.height = `${height}px`;
                    bar.style.backgroundColor = `hsl(${120 + Math.random() * 60}, 70%, 50%)`;
                });
            }, 100);
        }

        function stopAudioVisualizer() {
            if (audioVisualizerInterval) {
                clearInterval(audioVisualizerInterval);
                audioVisualizerInterval = null;
            }
            
            const visualizer = document.getElementById('audioVisualizer');
            visualizer.innerHTML = '';
            
            for (let i = 0; i < 20; i++) {
                const bar = document.createElement('div');
                bar.className = 'audio-bar';
                bar.style.height = '5px';
                bar.style.backgroundColor = '#e0e0e0';
                visualizer.appendChild(bar);
            }
        }

        async function speakVietnameseSentence() {
            const text = convertedFullSentence || document.getElementById('convertedSentenceDisplay').textContent;
            if (!text || text === '---') {
                log('SPEECH', 'Kh√¥ng c√≥ vƒÉn b·∫£n ti·∫øng Vi·ªát ƒë·ªÉ ƒë·ªçc');
                return;
            }
            
            speakText(text, currentVoice.lang);
        }

        async function speakTranslation() {
            const text = document.getElementById('translationOutput').textContent;
            if (!text || text.includes('ƒêang ch·ªù d·ªãch') || text.includes('Vui l√≤ng nh·∫≠p')) {
                log('SPEECH', 'Kh√¥ng c√≥ vƒÉn b·∫£n d·ªãch ƒë·ªÉ ƒë·ªçc');
                return;
            }
            
            const lang = document.getElementById('targetLanguage').value;
            speakText(text, lang);
        }

        // === H√ÄM UPDATE UI COMPLETE ===
        function updateUI() {
            updateWordDisplays();
            updateSentenceDisplay();
            
            const speakVnBtn = document.getElementById('speakVnBtn');
            const speakTransBtn = document.getElementById('speakTransBtn');
            const stopSpeechBtn = document.getElementById('stopSpeechBtn');
            
            const hasVietnameseText = convertedFullSentence && convertedFullSentence !== '---';
            const hasTranslationText = document.getElementById('translationOutput').textContent && 
                                     !document.getElementById('translationOutput').textContent.includes('ƒêang ch·ªù d·ªãch');
            
            speakVnBtn.disabled = !hasVietnameseText || isSpeaking;
            speakTransBtn.disabled = !hasTranslationText || isSpeaking;
            stopSpeechBtn.disabled = !isSpeaking;
            
            if (isSpeaking) {
                speakVnBtn.classList.add('speaking');
            } else {
                speakVnBtn.classList.remove('speaking');
            }
            
            const langNames = {
                'vi-VN': 'Ti·∫øng Vi·ªát',
                'en-GB': 'Ti·∫øng Anh',
                'ja-JP': 'Ti·∫øng Nh·∫≠t',
                'ko-KR': 'Ti·∫øng H√†n',
                'zh-CN': 'Ti·∫øng Trung'
            };
            const genderNames = {
                'male': 'Nam',
                'female': 'N·ªØ'
            };
            const ttsMode = useGeminiTTS ? 'Gemini AI' : 'Web Speech';
            document.getElementById('currentVoiceDisplay').textContent = 
                `Hi·ªán t·∫°i: ${genderNames[currentVoice.gender]} ${langNames[currentVoice.lang] || currentVoice.lang} (${ttsMode})`;
            
            document.getElementById('useGeminiTTS').classList.toggle('active', useGeminiTTS);
            document.getElementById('useWebSpeech').classList.toggle('active', !useGeminiTTS);
        }

        // === KH·ªûI T·∫†O ===
        document.addEventListener('DOMContentLoaded', function() {
            log('SYSTEM', '·ª®ng d·ª•ng t·ªëi ∆∞u ƒë√£ kh·ªüi ƒë·ªông v·ªõi t√≠nh nƒÉng hi·ªáu chu·∫©n');
            
            // Kh·ªüi t·∫°o FPS counter
            function updateFPS() {
                frameCount++;
                const currentTime = performance.now();
                if (currentTime - lastFrameTime >= 1000) {
                    currentFPS = frameCount;
                    frameCount = 0;
                    lastFrameTime = currentTime;
                    
                    document.getElementById('fps').textContent = currentFPS;
                    
                    if (currentFPS < 30 && pollingInterval > 150) {
                        pollingInterval = Math.min(pollingInterval * 1.5, 1000);
                        updatePollingDisplay();
                        log('PERF', `FPS th·∫•p (${currentFPS}), tƒÉng t·∫ßn su·∫•t c·∫≠p nh·∫≠t l√™n ${pollingInterval}ms`);
                    } else if (currentFPS > 50 && pollingInterval < 1000) {
                        pollingInterval = Math.max(pollingInterval * 0.8, 150);
                        updatePollingDisplay();
                    }
                }
                requestAnimationFrame(updateFPS);
            }
            
            requestAnimationFrame(updateFPS);
            
            // T·∫£i hi·ªáu chu·∫©n t·ª´ localStorage n·∫øu c√≥
            loadCalibration();
            
            if ('speechSynthesis' in window) {
                speechSynthesis.getVoices();
                
                speechSynthesis.onvoiceschanged = function() {
                    log('SPEECH', 'ƒê√£ t·∫£i gi·ªçng n√≥i t·ªïng h·ª£p');
                };
            }
            
            setTimeout(() => {
                fetchFirebaseDataOptimized();
                toggleAutoRefresh();
            }, 100);
            
            if (!GEMINI_API_KEY) {
                log('SYSTEM', 'L∆∞u √Ω: Kh√¥ng c√≥ c·∫•u h√¨nh kh√≥a API Gemini. S·ª≠ d·ª•ng Web Speech API.');
                useGeminiTTS = false;
            }
        });
    </script>
</body>
</html>
