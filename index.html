<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Word Constructor - Firebase Monitor</title>
    <style>
        /* T·∫•t c·∫£ CSS gi·ªØ nguy√™n, th√™m th√™m style cho audio visualizer */
        .audio-visualizer {
            margin-top: 10px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
        }
        
        .audio-bar {
            width: 4px;
            background: #4CAF50;
            border-radius: 2px;
            transition: height 0.1s ease;
        }
        
        .audio-wave {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
            height: 40px;
        }
        
        .wave-bar {
            width: 3px;
            background: linear-gradient(to top, #4CAF50, #2196F3);
            border-radius: 1.5px;
            animation: wave 1.5s ease-in-out infinite;
        }
        
        @keyframes wave {
            0%, 100% { transform: scaleY(0.3); }
            50% { transform: scaleY(1); }
        }
        
        .voice-selection {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .voice-option {
            padding: 8px 16px;
            border: 2px solid #4A00E0;
            border-radius: 20px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        
        .voice-option.selected {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            border-color: transparent;
        }
        
        .voice-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(74, 0, 224, 0.2);
        }
        
        .phrase-suggestions {
            margin-top: 15px;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 10px;
            border: 1px solid #dee2e6;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .phrase-pills {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        
        .phrase-pill {
            padding: 8px 16px;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(76, 175, 80, 0.2);
        }
        
        .phrase-pill:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
            background: linear-gradient(135deg, #45a049 0%, #3d8b40 100%);
        }
        
        .phrase-pill.blue {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
        }
        
        .phrase-pill.blue:hover {
            background: linear-gradient(135deg, #1976D2 0%, #1565C0 100%);
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.3);
        }
        
        .speech-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .speech-btn {
            padding: 12px 24px;
            background: linear-gradient(to right, #9C27B0, #673AB7);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }
        
        .speech-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(156,39,176,0.3);
        }
        
        .speech-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .speech-btn.speaking {
            background: linear-gradient(to right, #FF5722, #E64A19);
            animation: pulse 1s infinite;
        }
        
        .speech-btn.blue {
            background: linear-gradient(to right, #2196F3, #1976D2);
        }
        
        .speech-btn.red {
            background: linear-gradient(to right, #FF416C, #FF4B2B);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ESP32 Word Constructor - Firebase Monitor</h1>
            <div>Real-time monitoring from Firebase Realtime Database</div>
            <div class="firebase-status" id="firebaseStatus">
                Connecting to Firebase...
            </div>
        </header>

        <div class="dashboard">
            <!-- Sentence Construction Card -->
            <div class="card">
                <h3>Sentence Construction</h3>
                <div style="text-align: center; padding: 20px; margin-bottom: 20px;">
                    <div class="sensor-label">CURRENT WORD (Encoded)</div>
                    <div class="current-word-display" id="displayBuffer">---</div>
                    <div class="sensor-label">CURRENT WORD (Vietnamese)</div>
                    <div class="conversion-display" id="convertedCurrentWord">---</div>
                    
                    <div style="margin: 15px 0; color: #666;">
                        <div><strong>Use '_' to add word to sentence</strong></div>
                        <div><strong>Use 'COMMIT' to finalize sentence</strong></div>
                    </div>
                    
                    <div class="sensor-label">FULL SENTENCE (Encoded)</div>
                    <div class="sentence-display" id="sentenceDisplay">---</div>
                    <div class="sensor-label">FULL SENTENCE (Vietnamese)</div>
                    <div class="conversion-display" id="convertedSentenceDisplay">---</div>
                    
                    <!-- Phrase Suggestions -->
                    <div class="phrase-suggestions">
                        <h4>üìù PHRASE SUGGESTIONS (Based on current words)</h4>
                        <div class="phrase-pills" id="phrasePills">
                            <!-- Phrase pills will be added here by JavaScript -->
                        </div>
                    </div>
                    
                    <!-- Voice Selection -->
                    <div class="voice-selection">
                        <div class="voice-option selected" data-gender="female" data-voice="Aoede">
                            <span>üë© Female Voice (Aoede)</span>
                        </div>
                        <div class="voice-option" data-gender="male" data-voice="Kore">
                            <span>üë® Male Voice (Kore)</span>
                        </div>
                        <div class="voice-option" data-gender="female" data-voice="Zubenelgenubi">
                            <span>üë© Female Voice 2 (Zuben)</span>
                        </div>
                    </div>
                    
                    <!-- Speech Controls -->
                    <div class="speech-controls">
                        <button class="speech-btn" onclick="speakVietnameseSentence()" id="speakVnBtn">
                            üîä Speak Vietnamese
                        </button>
                        <button class="speech-btn blue" onclick="speakTranslation()" id="speakTransBtn">
                            üîà Speak Translation
                        </button>
                        <button class="speech-btn red" onclick="stopAllSpeech()" id="stopSpeechBtn">
                            ‚èπ Stop Speech
                        </button>
                    </div>
                    
                    <div class="audio-wave" id="audioVisualizer">
                        <!-- Audio wave will be generated here -->
                    </div>
                    
                    <div class="word-list" id="wordList">No words yet</div>
                    <div class="word-count">Words in sentence: <span id="wordCount">0</span>/10</div>
                    
                    <div style="display: flex; justify-content: space-around; margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                        <div>
                            <div class="sensor-label">SLOT 1</div>
                            <div class="sensor-value" id="slot1" style="font-size: 1.2rem;">---</div>
                        </div>
                        <div>
                            <div class="sensor-label">SLOT 2</div>
                            <div class="sensor-value" id="slot2" style="font-size: 1.2rem;">---</div>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button onclick="clearCurrentWord()" class="red">Clear Current</button>
                        <button onclick="backspace()">Backspace</button>
                        <button onclick="addWordToSentence()" class="green">Add Word (_)</button>
                        <button onclick="commitSentence()" class="blue">Commit Sentence</button>
                        <button onclick="resetSentence()" class="red">Reset All</button>
                    </div>
                </div>
            </div>

            <!-- Translation Card -->
            <div class="card">
                <h3>Translation</h3>
                <div style="margin-bottom: 20px;">
                    <div class="sensor-label">FULL SENTENCE (Vietnamese - For Translation)</div>
                    <textarea id="translationInput" placeholder="Enter Vietnamese text here..."></textarea>
                    
                    <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                        <div><strong>Translation Options:</strong></div>
                        <div style="display: flex; gap: 15px; margin-top: 10px; flex-wrap: wrap;">
                            <div>
                                <div class="sensor-label">Target Language</div>
                                <select id="targetLanguage" class="language-select">
                                    <option value="en-GB">English</option>
                                    <option value="ja-JP">Japanese</option>
                                    <option value="ko-KR">Korean</option>
                                    <option value="zh-CN">Chinese</option>
                                </select>
                            </div>
                            <div>
                                <div class="sensor-label">Voice Language</div>
                                <select id="voiceLanguage" class="language-select">
                                    <option value="vi-VN">Vietnamese</option>
                                    <option value="en-GB">English</option>
                                    <option value="ja-JP">Japanese</option>
                                    <option value="ko-KR">Korean</option>
                                    <option value="zh-CN">Chinese</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="sensor-label">TRANSLATED RESULT</div>
                <div id="translationOutput" class="conversion-display" style="min-height: 80px; margin-bottom: 15px;">
                    Waiting for translation...
                </div>

                <div class="controls">
                    <button onclick="translateSentence()" class="blue">Translate Sentence</button>
                    <button onclick="clearTranslation()" class="red">Clear Translation</button>
                </div>
            </div>

            <!-- Sensors Display Card -->
            <div class="card">
                <h3>Sensors Data from Firebase</h3>
                <div class="sensor-grid">
                    <div class="sensor-item mpu">
                        <div class="sensor-label">MPU6050 ORIENTATION</div>
                        <div class="sensor-value" id="mpuOrientation">Unknown</div>
                        <div class="sensor-label">SHAKE STATUS</div>
                        <div class="sensor-value" id="mpuShakeState">None</div>
                        <div class="sensor-label">IS SHAKING?</div>
                        <div class="sensor-value" id="isShaking">NO</div>
                    </div>
                    <div class="sensor-item flex">
                        <div class="sensor-label">FLEX SENSORS</div>
                        <div>
                            <div>
                                <span class="flex-box" id="flex0-box">0</span>
                                <span class="flex-box" id="flex1-box">0</span>
                                <span class="flex-box" id="flex2-box">0</span>
                                <span class="flex-box" id="flex3-box">0</span>
                            </div>
                            <div class="sensor-label" style="margin-top: 10px;">
                                Raw Values: <span id="rawValues">0, 0, 0, 0</span>
                            </div>
                            <div class="sensor-label">
                                State: <span id="flexFormat">0000</span> (a0,a1,a2,a3)
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="sensor-item" style="margin-top: 15px;">
                    <div class="sensor-label">SYSTEM STATUS</div>
                    <div>Last Update: <span id="lastUpdateTime" class="last-update">Never</span></div>
                </div>
                
                <div class="controls" style="margin-top: 15px;">
                    <button onclick="refreshData()" class="blue">Refresh Now</button>
                    <button onclick="toggleAutoRefresh()" id="autoRefreshBtn" class="green">Auto: ON</button>
                </div>
            </div>

            <!-- Log Display Card -->
            <div class="card">
                <h3>System Log</h3>
                <div style="max-height: 300px; overflow-y: auto; background: #f8f9fa; border-radius: 8px; padding: 10px;">
                    <div id="logContainer">
                        <div class="log-entry">System started. Waiting for Firebase data...</div>
                    </div>
                </div>
                <div class="controls" style="margin-top: 15px;">
                    <button onclick="clearLog()" class="red">Clear Log</button>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div>
                <span class="indicator" id="connectionStatus"></span>
                <span id="statusText">Connecting to Firebase...</span>
            </div>
            <div>
                <span id="lastUpdate">Last Firebase update: --:--:--</span>
            </div>
        </div>
    </div>

    <script>
        // Firebase Configuration
        const FIREBASE_URL = "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/sensorData.json";
        
        // Tables from ESP32 code (gi·ªØ nguy√™n)
        const tableA = [
            ["IAY","IC","ICH","IE","IEC","IEM","IEN","IENG","IEO"],
            ["IEP","IET","IEU","IM","IN","ING","INH","IO","IOI"],
            ["ENG","ENH","EO","EP","ET","EU","I","IA","IAC"],
            ["IAI","IAM","IAN","IANG","IANH","IAO","IAP","IAT","IAU"],
            ["AP","AT","AU","AY","E","EC","ECH","EM","EN"],
            ["A","AC","ACH","AI","AM","AN","ANG","ANH","AO"],
            ["IUN","IUONG","IUP","O","OA","OAC","OACH","OAI","OAM"],
            ["ION","IONG","IOT","IP","IT","IU","IUA","IUC","IUI"]
        ];

        const tableB = [
            ["UE","UECH","UEN","UENH","UEO","UET","UI","UM","UN"],
            ["UNG","UO","UOC","UOI","UOM","UON","UONG","UOP","OUT"],
            ["ONG","OOC","OONG","OP","OT","U","UA","UAC","UACH"],
            ["UAI","UAM","UAN","UANG","UANH","UAO","UAT","UAY","UC"],
            ["OAY","OC","OE","OEN","OEO","OET","OI","OM","ON"],
            ["COMMIT","_","nullptr","nullptr","OAN","OANG","OANH","OAP","OAT"],
            ["UYNH","UYP","UYT","UYU","Y","YEM","YEN","YET","YEU"],
            ["UOU","UP","UT","UU","UY","UYA","UYCH","UYEN","UYET"]
        ];

        const tableC = [
            [ ["B","C","D"],["ƒê","G","H"],["K","L","M"] ],
            [ ["N","P","Q"],["R","S","T"],["V","X","CH"] ],
            [ ["GH","KH","NG"],["NGH","NH","PH"],["TH","TR","_"] ]
        ];

        // Vietnamese Conversion Table (gi·ªØ nguy√™n)
        const vietnameseTable = [
            {key: "IAY", forms: ["i√°y", "i√†y", "i·∫£y", "i√£y", "i·∫°y", "iay", "i·∫•y", "i·∫ßy", "i·∫©y", "i·∫´y", "i·∫≠y", "i√¢y", "i·∫Øy", "i·∫±y", "i·∫≥y", "i·∫µy", "i·∫∑y", "iƒÉy"]},
            // ... (gi·ªØ nguy√™n t·∫•t c·∫£ c√°c ph·∫ßn t·ª≠)
        ];

        // Global variables
        let firebaseData = null;
        let lastUpdateTime = 0;
        let autoRefresh = true;
        let autoRefreshInterval;
        let logEntries = [];
        const MAX_LOG_ENTRIES = 20;
        
        // Sentence construction variables
        let slot1 = "";
        let slot2 = "";
        let displayBuffer = "";
        let convertedCurrentWord = "";
        let sentenceWords = [];
        let fullSentence = "";
        let convertedFullSentence = "";
        
        // Flex sensor state
        let flexStates = [0, 0, 0, 0];
        let lastFlexStates = [-1, -1, -1, -1];
        let stableCount = 0;
        let lastDetectedIndex = -1;
        let holdStartMs = 0;
        let holdFired = false;
        const DEBOUNCE_COUNT = 3;
        const HOLD_MS_DEFAULT = 800;
        const POST_HOLD_COOLDOWN = 600;
        let lastActionMs = 0;
        
        // MPU state mapping
        const mpuStateMap = {
            "Up": 0,
            "Down": 1,
            "Left": 2,
            "Right": 3,
            "Forward": 4,
            "Backward": 5
        };

        // Phrase Suggestions Database
        const phraseDatabase = {
            // Ch√†o h·ªèi
            "xin": ["xin ch√†o", "xin l·ªói", "xin vui l√≤ng", "xin c·∫£m ∆°n"],
            "ch√†o": ["ch√†o bu·ªïi s√°ng", "ch√†o m·ª´ng", "ch√†o t·∫°m bi·ªát"],
            "c·∫£m": ["c·∫£m ∆°n", "c·∫£m gi√°c", "c·∫£m ƒë·ªông"],
            "∆°n": ["c·∫£m ∆°n", "∆°n tr·ªùi", "∆°n gi·ªùi"],
            
            // C√¢u h·ªèi
            "b·∫°n": ["b·∫°n kh·ªèe kh√¥ng", "b·∫°n t√™n l√† g√¨", "b·∫°n bao nhi√™u tu·ªïi", "b·∫°n ƒë·∫øn t·ª´ ƒë√¢u"],
            "t√¥i": ["t√¥i mu·ªën", "t√¥i c·∫ßn", "t√¥i ƒë√≥i", "t√¥i kh√°t", "t√¥i m·ªát"],
            "bao": ["bao nhi√™u ti·ªÅn", "bao l√¢u", "bao gi·ªù"],
            "nhi√™u": ["bao nhi√™u", "nhi√™u ti·ªÅn", "nhi√™u ƒë√≥"],
            
            // ƒê·ªãa ƒëi·ªÉm
            "ƒë∆∞·ªùng": ["ƒë∆∞·ªùng n√†y", "ƒë∆∞·ªùng n√†o", "ƒë∆∞·ªùng ƒë·∫øn", "ch·ªâ ƒë∆∞·ªùng"],
            "ƒë·∫øn": ["ƒë·∫øn ƒë√¢y", "ƒë·∫øn ƒë√≥", "ƒë·∫øn khi", "ƒë·∫øn n∆°i"],
            "nh√†": ["nh√† t√¥i", "nh√† b·∫°n", "nh√† v·ªá sinh", "nh√† h√†ng"],
            
            // Th·ªùi gian
            "ng√†y": ["ng√†y mai", "ng√†y h√¥m nay", "ng√†y m·∫•y", "ch√∫c ng√†y t·ªët"],
            "gi·ªù": ["m·∫•y gi·ªù", "b√¢y gi·ªù", "gi·ªù ƒë√¢y", "gi·ªù h·ªçc"],
            
            // C·∫£m x√∫c
            "vui": ["r·∫•t vui", "vui l√≤ng", "vui v·∫ª", "vui t√≠nh"],
            "bu·ªìn": ["r·∫•t bu·ªìn", "bu·ªìn b√£", "bu·ªìn ng·ªß"],
            "y√™u": ["y√™u b·∫°n", "y√™u th∆∞∆°ng", "t√¨nh y√™u"],
            
            // Nhu c·∫ßu c∆° b·∫£n
            "ƒë√≥i": ["t√¥i ƒë√≥i", "ƒë√≥i b·ª•ng", "ƒë√≥i qu√°"],
            "kh√°t": ["t√¥i kh√°t", "kh√°t n∆∞·ªõc", "kh√°t qu√°"],
            "m·ªát": ["t√¥i m·ªát", "m·ªát m·ªèi", "m·ªát qu√°"],
            
            // Mua s·∫Øm
            "ti·ªÅn": ["bao nhi√™u ti·ªÅn", "ti·ªÅn ƒë√¢y", "tr·∫£ ti·ªÅn", "thi·∫øu ti·ªÅn"],
            "mua": ["mu·ªën mua", "mua ƒë·ªì", "mua s·∫Øm"],
            "gi√°": ["gi√° bao nhi√™u", "gi√° c·∫£", "gi√° r·∫ª"],
            
            // Hi·ªÉu bi·∫øt
            "hi·ªÉu": ["t√¥i hi·ªÉu", "kh√¥ng hi·ªÉu", "hi·ªÉu bi·∫øt"],
            "bi·∫øt": ["t√¥i bi·∫øt", "kh√¥ng bi·∫øt", "bi·∫øt r·ªìi"],
            
            // Common phrases for quick access
            "common": [
                "Xin ch√†o, r·∫•t vui ƒë∆∞·ª£c g·∫∑p b·∫°n",
                "B·∫°n kh·ªèe kh√¥ng?",
                "C·∫£m ∆°n b·∫°n r·∫•t nhi·ªÅu",
                "L√†m ∆°n cho t√¥i h·ªèi ƒë∆∞·ªùng",
                "Ch√∫c m·ªôt ng√†y t·ªët l√†nh",
                "T√¥i y√™u ng√¥n ng·ªØ n√†y",
                "H·∫πn g·∫∑p l·∫°i sau",
                "T√¥i ƒë√≥i b·ª•ng",
                "Bao nhi√™u ti·ªÅn?",
                "T√¥i kh√¥ng hi·ªÉu",
                "B·∫°n t√™n l√† g√¨?",
                "T√¥i ƒë·∫øn t·ª´ Vi·ªát Nam",
                "R·∫•t vui ƒë∆∞·ª£c l√†m quen",
                "Xin l·ªói, t√¥i kh√¥ng bi·∫øt",
                "T·∫°m bi·ªát, h·∫πn g·∫∑p l·∫°i"
            ]
        };

        // Speech synthesis variables
        let isSpeaking = false;
        let isConnecting = false;
        let currentAudio = null;
        let audioCache = {};
        let selectedVoice = "Aoede"; // Default to female voice
        
        // Helper to convert PCM16 (L16) data to a playable WAV Blob
        const pcmToWav = (base64PCM, sampleRate = 24000) => {
            const binaryString = atob(base64PCM);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }

            const wavHeader = new ArrayBuffer(44);
            const view = new DataView(wavHeader);

            const writeString = (view, offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };

            writeString(view, 0, "RIFF");
            view.setUint32(4, 36 + len, true);
            writeString(view, 8, "WAVE");
            writeString(view, 12, "fmt ");
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, "data");
            view.setUint32(40, len, true);

            return new Blob([view, bytes], { type: "audio/wav" });
        };

        // Voice map for different languages
        const voiceMap = {
            "vi-VN": "Aoede",
            "en-GB": "Kore",
            "ja-JP": "Aoede",
            "ko-KR": "Kore",
            "zh-CN": "Zubenelgenubi"
        };

        // Helper Functions
        function log(source, message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = { timestamp, source, message };
            
            logEntries.unshift(logEntry);
            if (logEntries.length > MAX_LOG_ENTRIES) {
                logEntries.pop();
            }
            
            updateLogDisplay();
        }

        function updateLogDisplay() {
            const logContainer = document.getElementById('logContainer');
            logContainer.innerHTML = logEntries.map(entry => 
                `<div class="log-entry">
                    <span style="color: #666; font-size: 0.8rem;">[${entry.timestamp}] ${entry.source}:</span>
                    <span style="color: #333;"> ${entry.message}</span>
                </div>`
            ).join('');
        }

        function clearLog() {
            logEntries = [];
            updateLogDisplay();
        }

        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            
            if (connected) {
                indicator.className = 'indicator online';
                statusText.textContent = 'Connected to Firebase';
            } else {
                indicator.className = 'indicator';
                statusText.textContent = 'Disconnected from Firebase';
            }
        }

        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        // Vietnamese Conversion Functions (gi·ªØ nguy√™n)
        function convertVietnameseWord(encodedWord) {
            if (!encodedWord || encodedWord.length === 0) return "";
            
            const firstUnderscore = encodedWord.indexOf('_');
            if (firstUnderscore === -1) return encodedWord;
            
            const secondUnderscore = encodedWord.indexOf('_', firstUnderscore + 1);
            if (secondUnderscore === -1) return encodedWord;
            
            // Extract parts
            const consonant = encodedWord.substring(0, firstUnderscore);
            const middle = encodedWord.substring(firstUnderscore + 1, secondUnderscore);
            const vowelTypeStr = encodedWord.substring(secondUnderscore + 1);
            
            if (middle.length < 2) return encodedWord;
            
            const toneChar = middle[0];
            if (toneChar < '1' || toneChar > '6') return encodedWord;
            
            const tone = parseInt(toneChar);
            const vowelKey = middle.substring(1);
            
            // Convert vowelType
            let vowelType = 0;
            if (vowelTypeStr === "b") {
                vowelType = 1;
            } else if (vowelTypeStr === "p") {
                vowelType = 2;
            } else if (vowelTypeStr !== "s") {
                return encodedWord;
            }
            
            const tableIndex = (tone - 1) + (vowelType * 6);
            
            if (tableIndex < 0 || tableIndex >= 18) {
                return encodedWord;
            }
            
            const vowelKeyUpper = vowelKey.toUpperCase();
            
            for (let i = 0; i < vietnameseTable.length; i++) {
                if (vowelKeyUpper === vietnameseTable[i].key) {
                    const convertedVowel = vietnameseTable[i].forms[tableIndex];
                    return consonant + convertedVowel;
                }
            }
            
            return encodedWord;
        }

        function convertVietnameseText(encodedText) {
            if (!encodedText || encodedText.length === 0) return "";
            
            let result = "";
            let start = 0;
            let end = 0;
            
            while (end < encodedText.length) {
                end = encodedText.indexOf(' ', start);
                if (end === -1) {
                    end = encodedText.length;
                }
                
                const word = encodedText.substring(start, end);
                const convertedWord = convertVietnameseWord(word);
                
                if (result.length > 0) {
                    result += " ";
                }
                result += convertedWord;
                
                start = end + 1;
                if (start > encodedText.length) {
                    break;
                }
            }
            
            return result;
        }

        function updateConversions() {
            // Update current word conversion
            if (displayBuffer.length > 0) {
                convertedCurrentWord = convertVietnameseWord(displayBuffer);
            } else {
                convertedCurrentWord = "";
            }
            
            // Update full sentence conversion
            if (fullSentence.length > 0) {
                convertedFullSentence = convertVietnameseText(fullSentence);
            } else {
                convertedFullSentence = "";
            }
        }

        // Phrase Suggestion Functions
        function updatePhraseSuggestions() {
            const phrasePills = document.getElementById('phrasePills');
            phrasePills.innerHTML = '';
            
            let suggestions = new Set();
            
            // Get the last word in the sentence
            const lastWord = sentenceWords[sentenceWords.length - 1];
            
            if (lastWord) {
                const convertedLastWord = convertVietnameseWord(lastWord);
                if (convertedLastWord && convertedLastWord !== lastWord) {
                    // Try to find suggestions based on the converted word
                    const words = convertedLastWord.toLowerCase().split(' ');
                    words.forEach(word => {
                        if (phraseDatabase[word]) {
                            phraseDatabase[word].forEach(phrase => suggestions.add(phrase));
                        }
                    });
                }
            }
            
            // Also get suggestions from the entire converted sentence
            if (convertedFullSentence) {
                const words = convertedFullSentence.toLowerCase().split(' ');
                words.forEach(word => {
                    // Clean the word (remove punctuation)
                    const cleanWord = word.replace(/[.,!?;:]/g, '');
                    if (phraseDatabase[cleanWord]) {
                        phraseDatabase[cleanWord].forEach(phrase => suggestions.add(phrase));
                    }
                });
            }
            
            // Add some common phrases if we don't have enough suggestions
            if (suggestions.size < 3) {
                phraseDatabase.common.slice(0, 5).forEach(phrase => suggestions.add(phrase));
            }
            
            // Convert Set to Array and limit to 6 suggestions
            const suggestionArray = Array.from(suggestions).slice(0, 6);
            
            if (suggestionArray.length === 0) {
                // Add default suggestions
                phraseDatabase.common.slice(0, 4).forEach(phrase => {
                    const pill = document.createElement('button');
                    pill.className = 'phrase-pill blue';
                    pill.textContent = phrase;
                    pill.onclick = () => usePhraseSuggestion(phrase);
                    phrasePills.appendChild(pill);
                });
                return;
            }
            
            // Create pills for each suggestion
            suggestionArray.forEach((phrase, index) => {
                const pill = document.createElement('button');
                pill.className = index % 2 === 0 ? 'phrase-pill' : 'phrase-pill blue';
                pill.textContent = phrase;
                pill.onclick = () => usePhraseSuggestion(phrase);
                phrasePills.appendChild(pill);
            });
            
            log('PHRASE', `Updated suggestions: ${suggestionArray.length} phrases`);
        }

        function usePhraseSuggestion(phrase) {
            // Set the phrase in translation input
            document.getElementById('translationInput').value = phrase;
            
            // Auto-translate
            translatePhrase(phrase);
            
            // Log the action
            log('PHRASE', `Selected phrase: "${phrase}"`);
            
            // Highlight the selected pill briefly
            event.target.style.transform = 'scale(0.95)';
            setTimeout(() => {
                event.target.style.transform = '';
            }, 200);
        }

        function translatePhrase(phrase) {
            const textarea = document.getElementById('translationInput');
            const outputDiv = document.getElementById('translationOutput');
            
            textarea.value = phrase;
            translateSentence();
        }

        // Speech Synthesis Functions with Gemini TTS
        async function speakWithRetry(text, langCode, retries = 3) {
            const voiceName = selectedVoice;
            const apiKey = "AIzaSyBShPKBG5MkEnw3HdsDGs4S9n1N4VUzpxY"; // Replace with your actual API key
            
            for (let i = 0; i < retries; i++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000);

                    const response = await fetch(
                        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`,
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            signal: controller.signal,
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: text }] }],
                                generationConfig: {
                                    responseModalities: ["AUDIO"],
                                    speechConfig: {
                                        voiceConfig: { prebuiltVoiceConfig: { voiceName } },
                                    },
                                },
                            }),
                        }
                    );

                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(`API_ERROR_${response.status}: ${errorData?.error?.message || response.statusText}`);
                    }

                    const data = await response.json();
                    const inlineData = data.candidates?.[0]?.content?.parts?.[0]?.inlineData;
                    
                    if (!inlineData || !inlineData.data) {
                        throw new Error("NO_DATA");
                    }

                    return inlineData.data;
                } catch (err) {
                    if (i === retries - 1) throw err;
                    const delay = Math.pow(2, i) * 1000;
                    await new Promise(r => setTimeout(r, delay));
                }
            }
        }

        async function speakText(text, langCode) {
            if (!text || isSpeaking) return;
            
            // Stop any ongoing speech
            stopAllSpeech();
            
            // Set speaking state
            isSpeaking = true;
            isConnecting = true;
            updateUI();
            startAudioVisualizer();
            
            const cacheKey = `${langCode}:${selectedVoice}:${text}`;
            
            try {
                let audioUrl;
                
                // Check cache first
                if (audioCache[cacheKey]) {
                    audioUrl = audioCache[cacheKey];
                } else {
                    // Generate new speech
                    const audioDataBase64 = await speakWithRetry(text, langCode);
                    const wavBlob = pcmToWav(audioDataBase64, 24000);
                    audioUrl = URL.createObjectURL(wavBlob);
                    
                    // Cache the URL
                    audioCache[cacheKey] = audioUrl;
                }
                
                isConnecting = false;
                
                // Play the audio
                currentAudio = new Audio(audioUrl);
                currentAudio.onended = () => {
                    isSpeaking = false;
                    stopAudioVisualizer();
                    updateUI();
                    log('SPEECH', 'Finished speaking');
                };
                
                currentAudio.onerror = (e) => {
                    console.error("Audio playback error:", e);
                    isSpeaking = false;
                    isConnecting = false;
                    stopAudioVisualizer();
                    updateUI();
                    log('SPEECH', 'Speech error');
                };
                
                await currentAudio.play();
                log('SPEECH', `Started speaking: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`);
                
            } catch (err) {
                console.error("TTS Failed:", err);
                isSpeaking = false;
                isConnecting = false;
                stopAudioVisualizer();
                updateUI();
                
                // Fallback to Web Speech API if Gemini TTS fails
                log('SPEECH', 'Falling back to Web Speech API');
                speakWithWebSpeechAPI(text, langCode);
            }
        }

        function speakWithWebSpeechAPI(text, langCode) {
            if (!('speechSynthesis' in window)) {
                log('SPEECH', 'Speech synthesis not supported in this browser');
                return;
            }
            
            window.speechSynthesis.cancel();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = langCode;
            utterance.rate = 0.9;
            utterance.pitch = 1;
            utterance.volume = 1;
            
            utterance.onstart = function() {
                isSpeaking = true;
                updateUI();
                startAudioVisualizer();
            };
            
            utterance.onend = function() {
                isSpeaking = false;
                stopAudioVisualizer();
                updateUI();
                log('SPEECH', 'Finished speaking (Web Speech API)');
            };
            
            utterance.onerror = function(event) {
                isSpeaking = false;
                stopAudioVisualizer();
                updateUI();
                log('SPEECH', `Speech error: ${event.error}`);
            };
            
            window.speechSynthesis.speak(utterance);
        }

        function speakVietnameseSentence() {
            const text = convertedFullSentence || document.getElementById('convertedSentenceDisplay').textContent;
            if (!text || text === '---') {
                log('SPEECH', 'No Vietnamese text to speak');
                return;
            }
            
            speakText(text, 'vi-VN');
        }

        function speakTranslation() {
            const text = document.getElementById('translationOutput').textContent;
            if (!text || text.includes('Waiting for translation') || text.includes('Please enter')) {
                log('SPEECH', 'No translation text to speak');
                return;
            }
            
            const lang = document.getElementById('voiceLanguage').value;
            speakText(text, lang);
        }

        function stopAllSpeech() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
            }
            
            isSpeaking = false;
            isConnecting = false;
            stopAudioVisualizer();
            updateUI();
            log('SPEECH', 'Speech stopped');
        }

        function startAudioVisualizer() {
            stopAudioVisualizer();
            
            const visualizer = document.getElementById('audioVisualizer');
            visualizer.innerHTML = '';
            
            // Create 20 wave bars
            for (let i = 0; i < 20; i++) {
                const bar = document.createElement('div');
                bar.className = 'wave-bar';
                bar.style.height = `${10 + Math.random() * 20}px`;
                bar.style.animationDelay = `${i * 0.05}s`;
                visualizer.appendChild(bar);
            }
        }

        function stopAudioVisualizer() {
            const visualizer = document.getElementById('audioVisualizer');
            visualizer.innerHTML = '';
            
            // Create static bars when not speaking
            for (let i = 0; i < 20; i++) {
                const bar = document.createElement('div');
                bar.className = 'wave-bar';
                bar.style.height = '5px';
                bar.style.backgroundColor = '#e0e0e0';
                bar.style.animation = 'none';
                visualizer.appendChild(bar);
            }
        }

        // Voice Selection Functions
        function setupVoiceSelection() {
            const voiceOptions = document.querySelectorAll('.voice-option');
            voiceOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selected class from all options
                    voiceOptions.forEach(opt => opt.classList.remove('selected'));
                    
                    // Add selected class to clicked option
                    option.classList.add('selected');
                    
                    // Update selected voice
                    selectedVoice = option.dataset.voice;
                    const gender = option.dataset.gender;
                    
                    log('SPEECH', `Selected ${gender} voice: ${selectedVoice}`);
                    
                    // Clear audio cache when voice changes
                    audioCache = {};
                });
            });
        }

        // C√°c h√†m c√≤n l·∫°i gi·ªØ nguy√™n (fetchFirebaseData, updateDisplay, processWordConstruction, etc.)
        // ... (gi·ªØ nguy√™n t·∫•t c·∫£ c√°c h√†m kh√°c t·ª´ code g·ªëc)

        // Sentence Functions - UPDATED to include phrase suggestions
        function addWordToSentence() {
            if (!displayBuffer) return;
            
            if (sentenceWords.length < 10) {
                sentenceWords.push(displayBuffer);
                updateFullSentence();
                log('SENTENCE', `Added word: '${displayBuffer}'`);
                
                // Clear current word
                slot1 = '';
                slot2 = '';
                displayBuffer = '';
                convertedCurrentWord = '';
                
                updateUI();
                
                // Update phrase suggestions when a word is added
                updatePhraseSuggestions();
                
            } else {
                log('SENTENCE', 'Sentence full! Max 10 words reached.');
            }
        }

        function updateFullSentence() {
            fullSentence = sentenceWords.join(' ');
            convertedFullSentence = convertVietnameseText(fullSentence);
        }

        function commitSentence() {
            if (sentenceWords.length === 0) {
                log('SENTENCE', 'No words to commit!');
                return;
            }
            
            if (displayBuffer) {
                addWordToSentence();
            }
            
            log('SENTENCE', '=== COMMIT SENTENCE ===');
            log('SENTENCE', `Full sentence: ${fullSentence}`);
            log('CONVERSION', `Converted sentence: ${convertedFullSentence}`);
            
            sentenceWords.forEach((word, i) => {
                const convertedWord = convertVietnameseWord(word);
                log('SENTENCE', `Word ${i + 1}: ${word} -> ${convertedWord}`);
            });
            
            // Reset sentence
            resetSentence();
        }

        function resetSentence() {
            sentenceWords = [];
            fullSentence = '';
            convertedFullSentence = '';
            slot1 = '';
            slot2 = '';
            displayBuffer = '';
            convertedCurrentWord = '';
            
            log('SENTENCE', 'Sentence reset - ready for new input');
            updateUI();
            
            // Update phrase suggestions when sentence is reset
            updatePhraseSuggestions();
        }

        function updateUI() {
            // ... (gi·ªØ nguy√™n t·∫•t c·∫£ code updateUI g·ªëc)
            
            // Update speech buttons state
            const speakVnBtn = document.getElementById('speakVnBtn');
            const speakTransBtn = document.getElementById('speakTransBtn');
            const stopSpeechBtn = document.getElementById('stopSpeechBtn');
            
            speakVnBtn.disabled = !convertedFullSentence || isSpeaking;
            speakTransBtn.disabled = !document.getElementById('translationOutput').textContent || isSpeaking;
            stopSpeechBtn.disabled = !isSpeaking;
            
            if (isSpeaking) {
                speakVnBtn.classList.add('speaking');
                speakVnBtn.textContent = isConnecting ? '‚è≥ Connecting...' : 'üîä Speaking...';
            } else {
                speakVnBtn.classList.remove('speaking');
                speakVnBtn.textContent = 'üîä Speak Vietnamese';
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            log('SYSTEM', 'Application started');
            
            // Initialize voice selection
            setupVoiceSelection();
            
            // Initialize phrase suggestions
            updatePhraseSuggestions();
            
            // Load voices for speech synthesis
            if ('speechSynthesis' in window) {
                speechSynthesis.getVoices();
            }
            
            // Start with auto-refresh
            fetchFirebaseData();
            toggleAutoRefresh();
        });

        // C√°c h√†m c√≤n l·∫°i gi·ªØ nguy√™n (translateSentence, clearTranslation, refreshData, toggleAutoRefresh, etc.)
        // ... (gi·ªØ nguy√™n t·∫•t c·∫£ c√°c h√†m kh√°c)

    </script>
</body>
</html>
