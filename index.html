<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>·ª®ng d·ª•ng D·ªãch Th·ªß Ng·ªØ v·ªõi ƒê·ªìng b·ªô Firebase</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            padding: 20px;
            text-align: center;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .dashboard {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            border: 1px solid #eaeaea;
            will-change: transform, opacity;
            contain: content;
        }

        .card h3 {
            color: #4A00E0;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }

        /* === CARD HI·ªÜU CHU·∫®N === */
        .calibration-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
            border: 2px solid #e0e6ff;
        }

        .calibration-status {
            margin: 15px 0;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
        }

        .calibrating {
            background: #FFF3CD;
            border: 2px solid #FFC107;
            color: #856404;
            animation: pulse 1s infinite;
        }

        .calibrated {
            background: #D4EDDA;
            border: 2px solid #28A745;
            color: #155724;
        }

        .calibration-ready {
            background: #E3F2FD;
            border: 2px solid #2196F3;
            color: #0d47a1;
        }

        .calibration-error {
            background: #FFEBEE;
            border: 2px solid #F44336;
            color: #b71c1c;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        @keyframes countdown {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .calibration-display {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 15px 0;
        }

        .sensor-calibration {
            padding: 15px;
            background: white;
            border-radius: 10px;
            border: 1px solid #eaeaea;
            text-align: center;
        }

        .sensor-name {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 8px;
        }

        .sensor-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin: 5px 0;
        }

        .sensor-max {
            font-size: 1.2rem;
            color: #4CAF50;
            font-weight: bold;
        }

        .sensor-threshold {
            font-size: 1rem;
            color: #2196F3;
            margin-top: 5px;
        }

        .progress-container {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #45a049);
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .calibration-countdown {
            font-size: 2.5rem;
            font-weight: bold;
            color: #FF5722;
            margin: 10px 0;
            animation: countdown 1s infinite;
        }

        .calibration-instructions {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #2196F3;
        }

        .calibration-step {
            margin: 8px 0;
            padding-left: 20px;
            position: relative;
        }

        .calibration-step:before {
            content: "‚Ä¢";
            position: absolute;
            left: 0;
            color: #2196F3;
            font-weight: bold;
        }

        .flex-sensor-legend {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .legend-text {
            font-size: 0.9rem;
            color: #666;
        }

        .conversion-display {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2196F3;
            margin: 10px 0;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #E3F2FD;
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #2196F3;
            line-height: 1.4;
            contain: strict;
            transform: translateZ(0);
        }

        .sentence-display {
            font-size: 1.8rem;
            font-weight: bold;
            color: #4CAF50;
            margin: 10px 0;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #E8F5E9;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #4CAF50;
            line-height: 1.4;
            contain: strict;
            transform: translateZ(0);
        }

        .current-word-display {
            font-size: 2rem;
            font-weight: bold;
            color: #FF5722;
            margin: 10px 0;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #FFF8E1;
            border-radius: 10px;
            padding: 15px;
            border: 2px dashed #FFC107;
            contain: strict;
            transform: translateZ(0);
        }

        .word-list {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #eaeaea;
        }

        .word-item {
            display: inline-block;
            padding: 8px 15px;
            margin: 5px;
            background: #e3f2fd;
            border-radius: 20px;
            border: 1px solid #bbdefb;
        }

        .word-count {
            font-size: 0.9rem;
            color: #666;
            margin-top: 10px;
        }

        .sensor-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .sensor-item {
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid;
        }

        .sensor-item.mpu {
            border-left-color: #2196F3;
        }

        .sensor-item.flex {
            border-left-color: #4CAF50;
        }

        .sensor-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
            margin: 5px 0;
        }

        .sensor-label {
            font-size: 0.8rem;
            color: #444;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .flex-box {
            display: inline-block;
            width: 40px;
            height: 40px;
            line-height: 40px;
            text-align: center;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 2px;
            font-weight: bold;
            border: 2px solid transparent;
        }

        .flex-box.active-0 { background: #4CAF50; color: white; }
        .flex-box.active-1 { background: #FF9800; color: white; }
        .flex-box.active-2 { background: #F44336; color: white; }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        button.red {
            background: linear-gradient(to right, #FF416C, #FF4B2B);
        }

        button.green {
            background: linear-gradient(to right, #00b09b, #96c93d);
        }

        button.blue {
            background: linear-gradient(to right, #2196F3, #21CBF3);
        }

        button.orange {
            background: linear-gradient(to right, #FF9800, #FF5722);
        }

        button.purple {
            background: linear-gradient(to right, #9C27B0, #673AB7);
        }

        .status-bar {
            background: #f8f9fa;
            padding: 15px;
            border-top: 1px solid #eaeaea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        .indicator.online {
            background: #4CAF50;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        .shake-active {
            color: #FF5722 !important;
            font-weight: bold !important;
            animation: shake 0.5s infinite;
        }

        .language-select {
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid #ccc;
            background: white;
            font-size: 1rem;
        }

        .phrase-btn {
            padding: 8px 15px;
            background: linear-gradient(to right, #FF9800, #FF5722);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .phrase-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(255,87,34,0.3);
        }

        .loading {
            animation: pulse 1s infinite;
            color: #2196F3 !important;
        }

        .error {
            color: #F44336 !important;
            border-color: #F44336 !important;
            background: #FFEBEE !important;
        }

        .success {
            color: #4CAF50 !important;
            border-color: #4CAF50 !important;
            background: #E8F5E9 !important;
        }

        textarea {
            width: 100%;
            height: 120px;
            font-size: 1.5rem;
            padding: 15px;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            background: #E8F5E9;
            color: #333;
            resize: vertical;
        }

        select {
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid #ccc;
            min-width: 150px;
        }

        .firebase-status {
            font-size: 0.9rem;
            color: #444;
            margin-top: 5px;
        }

        .last-update {
            font-size: 0.8rem;
            color: #777;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }

        .phrase-suggestions {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #eaeaea;
        }

        .phrase-suggestions h4 {
            margin-bottom: 10px;
            color: #4A00E0;
            font-size: 1rem;
        }

        .phrase-pills {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .phrase-pill {
            padding: 6px 12px;
            background: linear-gradient(to right, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .phrase-pill:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(76,175,80,0.3);
        }

        .phrase-pill.blue {
            background: linear-gradient(to right, #2196F3, #1976D2);
        }

        .speech-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        .speech-btn {
            padding: 10px 20px;
            background: linear-gradient(to right, #9C27B0, #673AB7);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .speech-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(156,39,176,0.3);
        }

        .speech-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .speech-btn.speaking {
            background: linear-gradient(to right, #FF5722, #E64A19);
            animation: pulse 1s infinite;
        }

        .audio-visualizer {
            margin-top: 10px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
        }

        .audio-bar {
            width: 4px;
            background: #4CAF50;
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        .dynamic-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .dynamic-suggestions.show {
            display: block;
        }

        .suggestion-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background 0.2s;
        }

        .suggestion-item:hover {
            background: #f0f7ff;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .text-input-container {
            position: relative;
        }

        .auto-suggestions-panel {
            margin-top: 15px;
            padding: 15px;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
            border-radius: 10px;
            border: 2px solid #e0e6ff;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .auto-suggestions-title {
            font-size: 0.9rem;
            font-weight: bold;
            color: #4A00E0;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .auto-suggestions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
        }

        .auto-suggestion-item {
            padding: 12px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .auto-suggestion-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-color: #4A00E0;
        }

        .auto-suggestion-text {
            font-size: 0.9rem;
            margin-bottom: 8px;
        }

        .auto-suggestion-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .auto-suggestion-btn {
            padding: 4px 8px;
            font-size: 0.75rem;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            flex: 1;
            text-align: center;
        }

        .auto-suggestion-btn.speak {
            background: linear-gradient(to right, #9C27B0, #673AB7);
            color: white;
        }

        .auto-suggestion-btn.use {
            background: linear-gradient(to right, #4CAF50, #45a049);
            color: white;
        }

        .auto-suggestion-btn.translate {
            background: linear-gradient(to right, #2196F3, #1976D2);
            color: white;
        }

        .voice-options {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .voice-btn {
            padding: 6px 12px;
            background: linear-gradient(to right, #FF9800, #FF5722);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .voice-btn.active {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            box-shadow: 0 2px 8px rgba(74,0,224,0.3);
        }

        .language-voice-display {
            font-size: 0.8rem;
            color: #444;
            text-align: center;
            margin-top: 5px;
        }

        .ai-speech-status {
            margin-top: 5px;
            font-size: 0.8rem;
            color: #4CAF50;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .ai-loading {
            animation: pulse 1s infinite;
        }

        .tts-toggle {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .tts-toggle-btn {
            padding: 6px 12px;
            background: #f0f0f0;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .tts-toggle-btn.active {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            border-color: #4A00E0;
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        .performance-info {
            font-size: 0.7rem;
            color: #666;
            text-align: center;
            margin-top: 5px;
        }

        .fast-mode {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #4CAF50;
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            z-index: 1000;
        }

        .phrase-list-container {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eaeaea;
            border-radius: 10px;
            background: white;
        }

        .phrase-list-item {
            padding: 12px 15px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .phrase-list-item:hover {
            background: #f0f7ff;
            border-left: 3px solid #4A00E0;
        }

        .phrase-list-item:last-child {
            border-bottom: none;
        }

        .accent-selector {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .accent-btn {
            padding: 8px 15px;
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s;
        }

        .accent-btn.active {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            border-color: #4A00E0;
        }

        .accent-btn.north {
            background: #E3F2FD;
            border-color: #2196F3;
        }

        .accent-btn.central {
            background: #E8F5E9;
            border-color: #4CAF50;
        }

        .accent-btn.south {
            background: #FFF3E0;
            border-color: #FF9800;
        }

        .voice-gender-selector {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            justify-content: center;
        }

        .voice-gender-btn {
            padding: 8px 20px;
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .voice-gender-btn.active {
            background: linear-gradient(to right, #FF9800, #FF5722);
            color: white;
            border-color: #FF9800;
        }

        .tts-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 10px 0;
            padding: 10px;
            background: #FFF3CD;
            border-radius: 8px;
            border: 1px solid #FFC107;
        }

        .tts-loading span {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #FFEBEE;
            border: 1px solid #F44336;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            color: #b71c1c;
            text-align: center;
            animation: pulse 1s infinite;
        }

        .suggestion-header {
            background: #f8f9fa;
            padding: 4px 8px;
            font-size: 0.7rem;
            color: #666;
            border-radius: 4px;
            margin-top: 4px;
            display: inline-block;
        }
        
        .sync-status {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            font-size: 0.8rem;
        }
        
        .sync-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ddd;
        }
        
        .sync-indicator.syncing {
            background: #FF9800;
            animation: pulse 1s infinite;
        }
        
        .sync-indicator.synced {
            background: #4CAF50;
        }
        
        .sync-indicator.error {
            background: #F44336;
        }
        
        .device-id {
            font-size: 0.7rem;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="fast-mode" id="fastModeIndicator" style="display: none;">üöÄ Ch·∫ø ƒë·ªô t·ªëc ƒë·ªô cao: B·∫¨T</div>
    <div class="container">
        <header>
            <h1>·ª®ng d·ª•ng D·ªãch Th·ªß Ng·ªØ v·ªõi ƒê·ªìng b·ªô Firebase</h1>
            <div>Gi√°m s√°t th·ªùi gian th·ª±c v√† ƒë·ªìng b·ªô ƒëa thi·∫øt b·ªã</div>
            <div class="firebase-status" id="firebaseStatus">ƒêang k·∫øt n·ªëi v·ªõi Firebase...</div>
            <div class="sync-status">
                <span class="sync-indicator" id="syncIndicator"></span>
                <span id="syncStatus">Ch∆∞a ƒë·ªìng b·ªô</span>
            </div>
            <div class="device-id">ID Thi·∫øt b·ªã: <span id="deviceId">ƒêang t·∫°o...</span></div>
            <div class="performance-info" id="performanceInfo">
                ƒê·ªô tr·ªÖ: <span id="latency">--</span>ms | FPS: <span id="fps">--</span> | T·∫ßn su·∫•t: <span id="pollingRate">--</span>ms | ƒê·ªìng b·ªô: <span id="syncCount">0</span> h√†nh ƒë·ªông
            </div>
        </header>

        <div class="dashboard">
            <!-- Card X√¢y d·ª±ng C√¢u -->
            <div class="card">
                <h3>X√¢y d·ª±ng C√¢u</h3>
                <div style="text-align: center; padding: 20px; margin-bottom: 20px;">
                    <div class="sensor-label">T·ª™ HI·ªÜN T·∫†I (Ti·∫øng Vi·ªát)</div>
                    <div class="current-word-display" id="displayBuffer">---</div>
                    <div class="sensor-label">T·ª™ HI·ªÜN T·∫†I (M√£ h√≥a)</div>
                    <div class="conversion-display" id="convertedCurrentWord">---</div>
                    
                    <div style="margin: 15px 0; color: #444;">
                        <div><strong>S·ª≠ d·ª•ng '_' ƒë·ªÉ th√™m t·ª´ v√†o c√¢u</strong></div>
                        <div><strong>S·ª≠ d·ª•ng 'COMMIT' ƒë·ªÉ ho√†n th√†nh c√¢u</strong></div>
                    </div>
                    
                    <div class="sensor-label">C√ÇU ƒê·∫¶Y ƒê·ª¶ (M√£ h√≥a)</div>
                    <div class="sentence-display" id="sentenceDisplay">---</div>
                    <div class="sensor-label">C√ÇU ƒê·∫¶Y ƒê·ª¶ (Ti·∫øng Vi·ªát)</div>
                    <div class="conversion-display" id="convertedSentenceDisplay">---</div>
                    
                    <!-- Ph·∫ßn ƒë·ªÅ xu·∫•t c·ª•m t·ª´ -->
                    <div class="phrase-suggestions">
                        <h4>üìù ƒê·ªÄ XU·∫§T C·ª§M T·ª™ TH√îNG D·ª§NG</h4>
                        <div class="phrase-pills" id="phrasePills"></div>
                    </div>
                    
                    <!-- Chuy·ªÉn ƒë·ªïi TTS -->
                    <div class="tts-toggle">
                        <button class="tts-toggle-btn active" id="useGoogleTTS" onclick="toggleTTSMode(true)">üîä Google TTS</button>
                        <button class="tts-toggle-btn" id="useWebSpeech" onclick="toggleTTSMode(false)">üé§ Web Speech</button>
                    </div>
                    
                    <!-- B·∫£ng ƒë·ªÅ xu·∫•t t·ª± ƒë·ªông -->
                    <div class="auto-suggestions-panel" id="autoSuggestionsPanel" style="display: none;">
                        <div class="auto-suggestions-title"><span>üí° ƒê·ªÄ XU·∫§T D·ª∞A TR√äN C√ÇU C·ª¶A B·∫†N</span></div>
                        <div class="auto-suggestions-grid" id="autoSuggestionsGrid"></div>
                    </div>
                    
                    <!-- T√πy ch·ªçn gi·ªçng n√≥i -->
                    <div class="voice-options">
                        <div class="voice-btn male active" data-gender="male" data-lang="vi-VN" onclick="selectVoice(this)">üë® Nam Ti·∫øng Vi·ªát</div>
                        <div class="voice-btn female" data-gender="female" data-lang="vi-VN" onclick="selectVoice(this)">üë© N·ªØ Ti·∫øng Vi·ªát</div>
                        <div class="voice-btn male" data-gender="male" data-lang="en-GB" onclick="selectVoice(this)">üë® Nam Ti·∫øng Anh</div>
                        <div class="voice-btn female" data-gender="female" data-lang="en-GB" onclick="selectVoice(this)">üë© N·ªØ Ti·∫øng Anh</div>
                    </div>
                    
                    <div class="language-voice-display" id="currentVoiceDisplay">Hi·ªán t·∫°i: Nam Ti·∫øng Vi·ªát (Google TTS)</div>
                    
                    <!-- ƒêi·ªÅu khi·ªÉn gi·ªçng n√≥i -->
                    <div class="speech-controls">
                        <button class="speech-btn" onclick="speakVietnameseSentence()" id="speakVnBtn">üîä ƒê·ªçc Ti·∫øng Vi·ªát</button>
                        <button class="speech-btn blue" onclick="speakTranslation()" id="speakTransBtn">üîà ƒê·ªçc B·∫£n d·ªãch</button>
                        <button class="speech-btn red" onclick="stopAllSpeech()" id="stopSpeechBtn">‚èπ D·ª´ng ƒë·ªçc</button>
                    </div>
                    
                    <div class="audio-visualizer" id="audioVisualizer"></div>
                    
                    <div class="word-list" id="wordList">Ch∆∞a c√≥ t·ª´ n√†o</div>
                    <div class="word-count">S·ªë t·ª´ trong c√¢u: <span id="wordCount">0</span>/10</div>
                    
                    <div style="display: flex; justify-content: space-around; margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                        <div><div class="sensor-label">KHE 1</div><div class="sensor-value" id="slot1" style="font-size: 1.2rem;">---</div></div>
                        <div><div class="sensor-label">KHE 2</div><div class="sensor-value" id="slot2" style="font-size: 1.2rem;">---</div></div>
                    </div>
                    
                    <div class="controls">
                        <button onclick="clearCurrentWord()" class="red">X√≥a t·ª´ hi·ªán t·∫°i</button>
                        <button onclick="backspace()">X√≥a k√Ω t·ª±</button>
                        <button onclick="addWordToSentence()" class="green">Th√™m t·ª´ (_)</button>
                        <button onclick="commitSentence()" class="blue">Ho√†n th√†nh c√¢u</button>
                        <button onclick="resetSentence()" class="red">ƒê·∫∑t l·∫°i t·∫•t c·∫£</button>
                    </div>
                </div>
            </div>

            <!-- Card Hi·ªáu chu·∫©n -->
            <div class="card calibration-card">
                <h3>üéØ Hi·ªáu chu·∫©n C·∫£m bi·∫øn U·ªën</h3>
                <div class="calibration-instructions">
                    <h4>üìã H∆∞·ªõng d·∫´n Hi·ªáu chu·∫©n:</h4>
                    <div class="calibration-step">ƒê·∫∑t tay th·∫≥ng v√† th∆∞ gi√£n</div>
                    <div class="calibration-step">Nh·∫•n "B·∫Øt ƒë·∫ßu Hi·ªáu chu·∫©n"</div>
                    <div class="calibration-step">L·∫ßn l∆∞·ª£t u·ªën t·ª´ng ng√≥n tay h·∫øt m·ª©c c√≥ th·ªÉ (10 gi√¢y)</div>
                    <div class="calibration-step">H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông l∆∞u gi√° tr·ªã ng∆∞·ª°ng u·ªën</div>
                    <div class="calibration-step">Sau khi ho√†n th√†nh, h·ªá th·ªëng s·∫Ω s·ª≠ d·ª•ng gi√° tr·ªã ƒë√£ hi·ªáu chu·∫©n</div>
                </div>
                
                <div class="calibration-status" id="calibrationStatus">
                    <div class="calibration-ready">S·∫µn s√†ng ƒë·ªÉ Hi·ªáu chu·∫©n</div>
                </div>
                
                <!-- Hi·ªÉn th·ªã qu√° tr√¨nh hi·ªáu chu·∫©n -->
                <div id="calibrationProgress" style="display: none;">
                    <div class="calibration-countdown" id="calibrationCountdown">10</div>
                    <div style="text-align: center; margin: 10px 0; font-weight: bold; color: #4A00E0;">
                        <span id="calibrationMessage">ƒêang hi·ªáu chu·∫©n... Vui l√≤ng u·ªën ng√≥n tay h·∫øt m·ª©c!</span>
                    </div>
                    
                    <div class="calibration-display" id="calibrationDisplay"></div>
                    
                    <div class="progress-container">
                        <div class="progress-bar" id="calibrationProgressBar" style="width: 0%"></div>
                    </div>
                </div>
                
                <!-- Hi·ªÉn th·ªã ng∆∞·ª°ng hi·ªán t·∫°i -->
                <div class="sensor-calibration" style="margin-top: 20px;">
                    <div class="sensor-label">NG∆Ø·ª†NG HI·ªÜN T·∫†I</div>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 10px;">
                        <div><div class="sensor-name">C·∫£m bi·∫øn 0</div><div class="sensor-threshold" id="currentThreshold0">300</div></div>
                        <div><div class="sensor-name">C·∫£m bi·∫øn 1</div><div class="sensor-threshold" id="currentThreshold1">450</div></div>
                        <div><div class="sensor-name">C·∫£m bi·∫øn 2</div><div class="sensor-threshold" id="currentThreshold2">350</div></div>
                        <div><div class="sensor-name">C·∫£m bi·∫øn 3</div><div class="sensor-threshold" id="currentThreshold3">300</div></div>
                    </div>
                </div>
                
                <div class="flex-sensor-legend">
                    <div class="legend-item"><div class="legend-color" style="background: #4CAF50;"></div><div class="legend-text">Th·∫≥ng (0)</div></div>
                    <div class="legend-item"><div class="legend-color" style="background: #FF9800;"></div><div class="legend-text">H∆°i u·ªën (1)</div></div>
                    <div class="legend-item"><div class="legend-color" style="background: #F44336;"></div><div class="legend-text">U·ªën h·∫øt (2)</div></div>
                </div>
                
                <div class="controls">
                    <button onclick="startCalibration()" class="orange" id="calibrateBtn">üéØ B·∫Øt ƒë·∫ßu Hi·ªáu chu·∫©n</button>
                    <button onclick="stopCalibration()" class="red" id="stopCalibrateBtn" style="display: none;">‚èπ D·ª´ng Hi·ªáu chu·∫©n</button>
                    <button onclick="resetCalibration()" class="purple">üîÑ Reset v·ªÅ M·∫∑c ƒë·ªãnh</button>
                    <button onclick="loadCalibration()" class="blue">üíæ T·∫£i Hi·ªáu chu·∫©n</button>
                </div>
                
                <div class="calibration-info" style="margin-top: 15px; font-size: 0.8rem; color: #444; text-align: center;">
                    <div>Ng∆∞·ª°ng th·∫≥ng c·ªë ƒë·ªãnh: C·∫£m bi·∫øn 0-2: 75, C·∫£m bi·∫øn 3: 75</div>
                    <div>Ng∆∞·ª°ng u·ªën s·∫Ω ƒë∆∞·ª£c hi·ªáu chu·∫©n t·ª± ƒë·ªông</div>
                </div>
            </div>

            <!-- Card D·ªãch thu·∫≠t v·ªõi Google Translate API -->
            <div class="card">
                <h3>D·ªãch thu·∫≠t v·ªõi Google Translate</h3>
                <div style="margin-bottom: 20px;">
                    <div class="sensor-label">C√ÇU ƒê·∫¶Y ƒê·ª¶ (Ti·∫øng Vi·ªát - ƒê·ªÉ d·ªãch)</div>
                    <div class="text-input-container">
                        <textarea id="translationInput" placeholder="Nh·∫≠p vƒÉn b·∫£n ti·∫øng Vi·ªát ·ªü ƒë√¢y..." oninput="handleTranslationInput()"></textarea>
                        <div class="dynamic-suggestions" id="translationSuggestions"></div>
                    </div>
                    
                    <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                        <div><strong>T√πy ch·ªçn d·ªãch thu·∫≠t:</strong></div>
                        <div style="display: flex; gap: 15px; margin-top: 10px; flex-wrap: wrap;">
                            <div>
                                <div class="sensor-label">Ng√¥n ng·ªØ ngu·ªìn</div>
                                <select id="sourceLanguage" class="language-select" onchange="updateLanguage()">
                                    <option value="vi">Ti·∫øng Vi·ªát</option>
                                    <option value="en">Ti·∫øng Anh</option>
                                    <option value="ja">Ti·∫øng Nh·∫≠t</option>
                                    <option value="ko">Ti·∫øng H√†n</option>
                                    <option value="zh-CN">Ti·∫øng Trung</option>
                                </select>
                            </div>
                            <div>
                                <div class="sensor-label">Ng√¥n ng·ªØ ƒë√≠ch</div>
                                <select id="targetLanguage" class="language-select" onchange="updateLanguage()">
                                    <option value="en">Ti·∫øng Anh</option>
                                    <option value="vi">Ti·∫øng Vi·ªát</option>
                                    <option value="ja">Ti·∫øng Nh·∫≠t</option>
                                    <option value="ko">Ti·∫øng H√†n</option>
                                    <option value="zh-CN">Ti·∫øng Trung</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="sensor-label">K·∫æT QU·∫¢ D·ªäCH</div>
                <div id="translationOutput" class="conversion-display" style="min-height: 80px; margin-bottom: 15px;">ƒêang ch·ªù d·ªãch...</div>

                <div class="controls">
                    <button onclick="translateWithGoogle()" class="blue">D·ªãch c√¢u</button>
                    <button onclick="clearTranslation()" class="red">X√≥a b·∫£n d·ªãch</button>
                </div>
            </div>

            <!-- Card Hi·ªÉn th·ªã C·∫£m bi·∫øn -->
            <div class="card">
                <h3>D·ªØ li·ªáu C·∫£m bi·∫øn t·ª´ Firebase</h3>
                <div class="sensor-grid">
                    <div class="sensor-item mpu">
                        <div class="sensor-label">ƒê·ªäNH H∆Ø·ªöNG MPU6050</div>
                        <div class="sensor-value" id="mpuOrientation">Kh√¥ng x√°c ƒë·ªãnh</div>
                        <div class="sensor-label">TR·∫†NG TH√ÅI L·∫ÆC</div>
                        <div class="sensor-value" id="mpuShakeState">Kh√¥ng</div>
                        <div class="sensor-label">ƒêANG L·∫ÆC?</div>
                        <div class="sensor-value" id="isShaking">KH√îNG</div>
                    </div>
                    <div class="sensor-item flex">
                        <div class="sensor-label">C·∫¢M BI·∫æN U·ªêN</div>
                        <div>
                            <div>
                                <span class="flex-box" id="flex0-box">0</span>
                                <span class="flex-box" id="flex1-box">0</span>
                                <span class="flex-box" id="flex2-box">0</span>
                                <span class="flex-box" id="flex3-box">0</span>
                            </div>
                            <div class="sensor-label" style="margin-top: 10px;">
                                Gi√° tr·ªã th√¥: <span id="rawValues">0, 0, 0, 0</span>
                            </div>
                            <div class="sensor-label">
                                Tr·∫°ng th√°i: <span id="flexFormat">0000</span> (a0,a1,a2,a3)
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="sensor-item" style="margin-top: 15px;">
                    <div class="sensor-label">TR·∫†NG TH√ÅI H·ªÜ TH·ªêNG</div>
                    <div>C·∫≠p nh·∫≠t l·∫ßn cu·ªëi: <span id="lastUpdateTime" class="last-update">Ch∆∞a bao gi·ªù</span></div>
                    <div>Th·ªùi gian x·ª≠ l√Ω: <span id="processingTime" class="last-update">0ms</span></div>
                    <div>H√†nh ƒë·ªông ƒë·ªìng b·ªô: <span id="actionCount" class="last-update">0</span></div>
                </div>
                
                <div class="controls" style="margin-top: 15px;">
                    <button onclick="refreshData()" class="blue">L√†m m·ªõi ngay</button>
                    <button onclick="toggleAutoRefresh()" id="autoRefreshBtn" class="green">T·ª± ƒë·ªông: B·∫¨T (300ms)</button>
                    <button onclick="toggleTurboMode()" id="turboBtn" class="green">üöÄ Ch·∫ø ƒë·ªô Turbo</button>
                    <button onclick="clearAllSync()" class="red" id="clearSyncBtn">üóëÔ∏è X√≥a ƒë·ªìng b·ªô</button>
                </div>
            </div>

            <!-- Card Hi·ªÉn th·ªã Nh·∫≠t k√Ω -->
            <div class="card">
                <h3>Nh·∫≠t k√Ω H·ªá th·ªëng & ƒê·ªìng b·ªô</h3>
                <div style="max-height: 300px; overflow-y: auto; background: #f8f9fa; border-radius: 8px; padding: 10px;">
                    <div id="logContainer">
                        <div class="log-entry">H·ªá th·ªëng ƒë√£ kh·ªüi ƒë·ªông. ƒêang ch·ªù d·ªØ li·ªáu Firebase...</div>
                    </div>
                </div>
                <div class="controls" style="margin-top: 15px;">
                    <button onclick="clearLog()" class="red">X√≥a nh·∫≠t k√Ω</button>
                    <button onclick="exportLog()" class="blue">Xu·∫•t nh·∫≠t k√Ω</button>
                </div>
            </div>
            
            <!-- Card ƒê·ªìng b·ªô H√†nh ƒë·ªông -->
            <div class="card">
                <h3>üîÑ ƒê·ªìng b·ªô H√†nh ƒë·ªông</h3>
                <div style="margin-bottom: 15px;">
                    <div class="sensor-label">TR·∫†NG TH√ÅI ƒê·ªíNG B·ªò</div>
                    <div style="padding: 15px; background: #f8f9fa; border-radius: 10px; margin: 10px 0;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <span>Thi·∫øt b·ªã hi·ªán t·∫°i:</span>
                            <strong id="currentDeviceName">ƒêang t·∫°o...</strong>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <span>H√†nh ƒë·ªông ƒë·ªìng b·ªô:</span>
                            <strong id="syncActionsCount">0</strong>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span>Thi·∫øt b·ªã ƒëang online:</span>
                            <strong id="onlineDevices">1</strong>
                        </div>
                    </div>
                    
                    <div class="sensor-label">L·ªäCH S·ª¨ H√ÄNH ƒê·ªòNG G·∫¶N ƒê√ÇY</div>
                    <div style="max-height: 200px; overflow-y: auto; margin-top: 10px; padding: 10px; background: white; border-radius: 8px; border: 1px solid #eaeaea;">
                        <div id="actionHistory">
                            <div class="log-entry">Ch∆∞a c√≥ h√†nh ƒë·ªông n√†o</div>
                        </div>
                    </div>
                </div>
                
                <div class="controls">
                    <button onclick="toggleSync()" id="syncToggleBtn" class="green">üîõ B·∫≠t ƒê·ªìng b·ªô</button>
                    <button onclick="syncAllData()" class="blue">üîÑ ƒê·ªìng b·ªô t·∫•t c·∫£</button>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div>
                <span class="indicator" id="connectionStatus"></span>
                <span id="statusText">ƒêang k·∫øt n·ªëi v·ªõi Firebase...</span>
            </div>
            <div>
                <span id="lastUpdate">C·∫≠p nh·∫≠t Firebase l·∫ßn cu·ªëi: --:--:--</span>
            </div>
        </div>
    </div>

<script>
    // === C·∫§U H√åNH FIREBASE ===
    const firebaseConfig = {
        apiKey: "AIzaSyB8B5G5q0q5q0q5q0q5q0q5q0q5q0q5q0q5",
        authDomain: "gangtay-f1efe.firebaseapp.com",
        databaseURL: "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "gangtay-f1efe",
        storageBucket: "gangtay-f1efe.appspot.com",
        messagingSenderId: "123456789012",
        appId: "1:123456789012:web:abcdef1234567890abcdef"
    };
    
    // Kh·ªüi t·∫°o Firebase
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();
    
    // === C·∫§U H√åNH T·ªêC ƒê·ªò CAO ===
    const FIREBASE_URL = "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/sensorData.json";
    
    // === CONFIGURATION FOR GOOGLE TTS PROXY ===
    const TTS_PROXY_SERVERS = [
        'https://translate.google.com/translate_tts',
        'https://translate.googleapis.com/translate_tts'
    ];
    
    const CORS_PROXY = 'https://corsproxy.io/?';
    const USE_CORS_PROXY = true;
    
    // === BI·∫æN HI·ªÜU CHU·∫®N ===
    let bentThresholds = [300, 450, 350, 300];
    const STRAIGHT_THRESHOLDS = [75, 75, 75, 75];
    
    let isCalibrating = false;
    let calibrationTimeout = null;
    let calibrationInterval = null;
    let calibrationCountdown = 10;
    let calibrationStartTime = 0;
    let calibrationMaxValues = [0, 0, 0, 0];
    let calibrationCurrentSensor = 0;
    let calibrationStep = "waiting";
    
    // === BI·∫æN T·ªêI ∆ØU H√ìA ===
    let firebaseData = null;
    let lastUpdateTime = 0;
    let autoRefresh = true;
    let autoRefreshInterval;
    let logEntries = [];
    const MAX_LOG_ENTRIES = 20;
    let isFetching = false;
    let lastFirebaseData = null;
    let uiUpdateScheduled = false;
    let lastFrameTime = performance.now();
    let frameCount = 0;
    let currentFPS = 60;
    let pollingInterval = 300;
    let turboMode = false;
    let currentFetchController = null;
    
    // Bi·∫øn x√¢y d·ª±ng c√¢u
    let slot1 = "";
    let slot2 = "";
    let displayBuffer = "";
    let convertedCurrentWord = "";
    let sentenceWords = [];
    let fullSentence = "";
    let convertedFullSentence = "";
    
    // Tr·∫°ng th√°i c·∫£m bi·∫øn u·ªën
    let flexStates = [0, 0, 0, 0];
    let lastFlexStates = [-1, -1, -1, -1];
    let stableCount = 0;
    let lastDetectedIndex = -1;
    let holdStartMs = 0;
    let holdFired = false;
    const DEBOUNCE_COUNT = 3;
    const HOLD_MS_DEFAULT = 1000;
    const POST_HOLD_COOLDOWN = 800;
    let lastActionMs = 0;
    let lastStateString = '';
    
    // CACHE cho t·ªëi ∆∞u h√≥a
    const mappingCache = new Map();
    const vietnameseCache = new Map();
    let translationCache = {};
    let audioCache = new Map();
    
    // === BI·∫æN ƒê·ªíNG B·ªò FIREBASE ===
    let deviceId = 'device_' + Math.random().toString(36).substring(2) + '_' + Date.now().toString(36);
    let deviceName = 'Thi·∫øt b·ªã ' + Math.floor(Math.random() * 1000);
    let isSyncing = false;
    let lastSyncTime = 0;
    let syncActions = [];
    let onlineDevices = [];
    let isProcessingRemoteAction = false;
    
    // === FIX: Bi·∫øn ƒë·ªÉ ngƒÉn ch·∫∑n l·∫∑p h√†nh ƒë·ªông ===
    let processedActionIds = new Set();
    const MAX_PROCESSED_IDS = 1000;
    let lastActionFromDevice = new Map();
    
    // === FIX TH√äM: Bi·∫øn ƒë·ªÉ ki·ªÉm so√°t listener ===
    let isActionListenerAttached = false;
    
    // === B·∫¢NG D·ªÆ LI·ªÜU ===
    const tableA = [
        ["IAY","IC","ICH","IE","IEC","IEM","IEN","IENG","IEO"],
        ["IEP","IET","IEU","IM","IN","ING","INH","IO","IOI"],
        ["ENG","ENH","EO","EP","ET","EU","I","IA","IAC"],
        ["IAI","IAM","IAN","IANG","IANH","IAO","IAP","IAT","IAU"],
        ["AP","AT","AU","AY","E","EC","ECH","EM","EN"],
        ["A","AC","ACH","AI","AM","AN","ANG","ANH","AO"],
        ["IUN","IUONG","IUP","O","OA","OAC","OACH","OAI","OAM"],
        ["ION","IONG","IOT","IP","IT","IU","IUA","IUC","IUI"]
    ];

    const tableB = [
        ["UE","UECH","UEN","UENH","UEO","UET","UI","UM","UN"],
        ["UNG","UO","UOC","UOI","UOM","UON","UONG","UOP","OUT"],
        ["ONG","OOC","OONG","OP","OT","U","UA","UAC","UACH"],
        ["UAI","UAM","UAN","UANG","UANH","UAO","UAT","UAY","UC"],
        ["OAY","OC","OE","OEN","OEO","OET","OI","OM","ON"],
        ["COMMIT","_","nullptr","nullptr","OAN","OANG","OANH","OAP","OAT"],
        ["UYNH","UYP","UYT","UYU","Y","YEM","YEN","YET","YEU"],
        ["UOU","UP","UT","UU","UY","UYA","UYCH","UYEN","UYET"]
    ];

    const tableC = [
        [ ["B","C","D"],["ƒê","G","H"],["K","L","M"] ],
        [ ["N","P","Q"],["R","S","T"],["V","X","CH"] ],
        [ ["GH","KH","NG"],["NGH","NH","PH"],["TH","TR","_"] ]
    ];
    
    // √Ånh x·∫° tr·∫°ng th√°i MPU
    const mpuStateMap = {
        "Up": 0,
        "Down": 1,
        "Left": 2,
        "Right": 3,
        "Forward": 4,
        "Backward": 5
    };

    // Danh s√°ch c·ª•m t·ª´ ƒë·ªÅ xu·∫•t
    const commonPhrases = [
        "Xin ch√†o, r·∫•t vui ƒë∆∞·ª£c g·∫∑p b·∫°n",
        "Ch√†o bu·ªïi s√°ng",
        "Ch√†o bu·ªïi chi·ªÅu",
        "Ch√†o bu·ªïi t·ªëi",
        "L√†m ∆°n cho t√¥i xin h√≥a ƒë∆°n",
        "B·∫°n kh·ªèe kh√¥ng?",
        "C·∫£m ∆°n b·∫°n r·∫•t nhi·ªÅu",
        "L√†m ∆°n cho t√¥i h·ªèi ƒë∆∞·ªùng",
        "Ch√∫c m·ªôt ng√†y t·ªët l√†nh",
        "T√¥i y√™u ng√¥n ng·ªØ n√†y",
        "H·∫πn g·∫∑p l·∫°i sau",
        "T√¥i ƒë√≥i b·ª•ng",
        "Bao nhi√™u ti·ªÅn?",
        "T√¥i kh√¥ng hi·ªÉu",
        "B·∫°n c√≥ th·ªÉ n√≥i ch·∫≠m h∆°n ƒë∆∞·ª£c kh√¥ng?",
        "B·∫°n t√™n l√† g√¨?",
        "T√¥i t√™n l√†...",
        "R·∫•t vui ƒë∆∞·ª£c l√†m quen",
        "T√¥i c·∫ßn gi√∫p ƒë·ª°",
        "L√†m ∆°n ch·ªâ ƒë∆∞·ªùng ƒë·∫øn nh√† ga",
        "Nh√† v·ªá sinh ·ªü ƒë√¢u?",
        "T√¥i b·ªã l·∫°c ƒë∆∞·ªùng",
        "B·∫°n n√≥i ti·∫øng Anh ƒë∆∞·ª£c kh√¥ng?",
        "Xin l·ªói, t√¥i kh√¥ng nghe r√µ",
        "B·∫°n c√≥ th·ªÉ l·∫∑p l·∫°i kh√¥ng?"
    ];

    // B·∫£ng chuy·ªÉn ƒë·ªïi Ti·∫øng Vi·ªát (gi·ªØ nguy√™n)

    // === GOOGLE TTS CONFIGURATION ===
    const TTS_CONFIG = {
        languages: {
            'vi-VN': {
                name: 'Ti·∫øng Vi·ªát',
                voices: {
                    male: { speed: 0.9, pitch: 'low' },
                    female: { speed: 1.0, pitch: 'high' }
                }
            },
            'en-GB': {
                name: 'Ti·∫øng Anh (Anh)',
                voices: {
                    male: { speed: 0.9, pitch: 'low' },
                    female: { speed: 1.0, pitch: 'high' }
                }
            }
        },
        
        googleLangCodes: {
            'vi-VN': 'vi',
            'en-GB': 'en',
            'en-US': 'en',
            'ja-JP': 'ja',
            'ko-KR': 'ko',
            'zh-CN': 'zh-CN'
        },
        
        langDisplayNames: {
            'vi-VN': 'Ti·∫øng Vi·ªát',
            'en-GB': 'Ti·∫øng Anh (Anh)',
            'en-US': 'Ti·∫øng Anh (M·ªπ)',
            'ja-JP': 'Ti·∫øng Nh·∫≠t',
            'ko-KR': 'Ti·∫øng H√†n',
            'zh-CN': 'Ti·∫øng Trung'
        }
    };

    // Bi·∫øn t·ªïng h·ª£p gi·ªçng n√≥i
    let isSpeaking = false;
    let currentSpeech = null;
    let audioVisualizerInterval = null;
    
    // Ch·∫ø ƒë·ªô TTS - M·∫∑c ƒë·ªãnh d√πng Google TTS Proxy
    let useGoogleTTS = true;
    
    // C√†i ƒë·∫∑t gi·ªçng n√≥i hi·ªán t·∫°i
    let currentVoice = {
        lang: 'vi-VN',
        gender: 'male',
        accent: 'vn-native'
    };

    // === H√ÄM ƒê·ªíNG B·ªò FIREBASE (ƒê√É S·ª¨A L·ªñI L·∫∂P) ===
    
    function initializeFirebaseSync() {
        // L∆∞u th√¥ng tin thi·∫øt b·ªã
        document.getElementById('deviceId').textContent = deviceId;
        document.getElementById('currentDeviceName').textContent = deviceName;
        
        // C·∫≠p nh·∫≠t tr·∫°ng th√°i thi·∫øt b·ªã online
        const deviceRef = database.ref('devices/' + deviceId);
        deviceRef.set({
            name: deviceName,
            lastSeen: Date.now(),
            isOnline: true
        });
        
        // C·∫≠p nh·∫≠t ƒë·ªãnh k·ª≥ tr·∫°ng th√°i online
        setInterval(() => {
            deviceRef.update({
                lastSeen: Date.now(),
                isOnline: true
            });
        }, 30000);
        
        // Theo d√µi c√°c thi·∫øt b·ªã online
        database.ref('devices').on('value', (snapshot) => {
            const devices = snapshot.val();
            onlineDevices = [];
            let count = 0;
            
            if (devices) {
                for (const id in devices) {
                    if (devices[id].isOnline && Date.now() - devices[id].lastSeen < 60000) {
                        onlineDevices.push(devices[id]);
                        count++;
                    }
                }
            }
            
            document.getElementById('onlineDevices').textContent = count;
        });
        
        // B·∫≠t ƒë·ªìng b·ªô m·∫∑c ƒë·ªãnh
        toggleSync(true);
        
        log('SYNC', `ƒê√£ kh·ªüi t·∫°o ƒë·ªìng b·ªô cho thi·∫øt b·ªã: ${deviceName}`);
    }
    
    function toggleSync(forceEnable = null) {
        if (forceEnable !== null) {
            isSyncing = forceEnable;
        } else {
            isSyncing = !isSyncing;
        }
        
        const syncBtn = document.getElementById('syncToggleBtn');
        const syncIndicator = document.getElementById('syncIndicator');
        const syncStatus = document.getElementById('syncStatus');
        
        if (isSyncing) {
            syncBtn.textContent = 'üî¥ T·∫Øt ƒê·ªìng b·ªô';
            syncBtn.className = 'red';
            syncIndicator.className = 'sync-indicator synced';
            syncStatus.textContent = 'ƒêang ƒë·ªìng b·ªô...';
            
            // B·∫Øt ƒë·∫ßu l·∫Øng nghe h√†nh ƒë·ªông
            startListeningToActions();
            log('SYNC', 'ƒê√£ b·∫≠t ch·∫ø ƒë·ªô ƒë·ªìng b·ªô');
        } else {
            syncBtn.textContent = 'üü¢ B·∫≠t ƒê·ªìng b·ªô';
            syncBtn.className = 'green';
            syncIndicator.className = 'sync-indicator';
            syncStatus.textContent = 'ƒê√£ t·∫Øt ƒë·ªìng b·ªô';
            
            // FIX: D·ª´ng l·∫Øng nghe v√† ƒë·∫∑t l·∫°i tr·∫°ng th√°i
            stopListeningToActions();
            log('SYNC', 'ƒê√£ t·∫Øt ch·∫ø ƒë·ªô ƒë·ªìng b·ªô');
        }
    }
    
    function startListeningToActions() {
        // FIX: Ch·ªâ g·∫Øn listener m·ªôt l·∫ßn
        if (isActionListenerAttached) {
            return;
        }
        
        // L·∫Øng nghe c√°c h√†nh ƒë·ªông m·ªõi - FIXED: S·ª≠ d·ª•ng timestamp ƒë·ªÉ tr√°nh l·∫∑p
        const now = Date.now();
        const actionsRef = database.ref('actions');
        
        // FIX: G·∫Øn listener v·ªõi startAt ƒë·ªÉ ch·ªâ nh·∫≠n h√†nh ƒë·ªông m·ªõi
        actionsRef.orderByChild('timestamp').startAt(now).on('child_added', (snapshot) => {
            const actionId = snapshot.key;
            const action = snapshot.val();
            
            // FIX: B·ªè qua n·∫øu ƒë√£ x·ª≠ l√Ω action n√†y
            if (processedActionIds.has(actionId)) {
                return;
            }
            
            // B·ªè qua h√†nh ƒë·ªông c·ªßa ch√≠nh thi·∫øt b·ªã n√†y
            if (action.deviceId === deviceId) {
                processedActionIds.add(actionId);
                return;
            }
            
            // FIX: Ki·ªÉm tra xem h√†nh ƒë·ªông n√†y t·ª´ thi·∫øt b·ªã n√†y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω g·∫ßn ƒë√¢y ch∆∞a
            const lastActionTime = lastActionFromDevice.get(action.deviceId) || 0;
            if (action.timestamp <= lastActionTime) {
                return; // H√†nh ƒë·ªông c≈©, b·ªè qua
            }
            
            // ƒê√°nh d·∫•u ƒë√£ x·ª≠ l√Ω
            processedActionIds.add(actionId);
            lastActionFromDevice.set(action.deviceId, action.timestamp);
            
            // Gi·ªõi h·∫°n k√≠ch th∆∞·ªõc Set
            if (processedActionIds.size > MAX_PROCESSED_IDS) {
                // Chuy·ªÉn Set th√†nh m·∫£ng v√† x√≥a 100 ph·∫ßn t·ª≠ c≈© nh·∫•t
                const array = Array.from(processedActionIds);
                const toRemove = array.slice(0, Math.min(100, array.length));
                toRemove.forEach(id => processedActionIds.delete(id));
            }
            
            // X·ª≠ l√Ω h√†nh ƒë·ªông t·ª´ thi·∫øt b·ªã kh√°c
            processRemoteAction(action, actionId);
        });
        
        isActionListenerAttached = true;
        
        // Load l·ªãch s·ª≠ h√†nh ƒë·ªông g·∫ßn ƒë√¢y
        loadRecentActions();
    }
    
    function stopListeningToActions() {
        // FIX: G·ª° t·∫•t c·∫£ listeners v√† ƒë·∫∑t l·∫°i tr·∫°ng th√°i
        database.ref('actions').off();
        isActionListenerAttached = false;
    }
    
    function logAction(actionType, data = null) {
        if (!isSyncing) return;
        
        // FIX: Kh√¥ng g·ª≠i h√†nh ƒë·ªông n·∫øu ƒëang x·ª≠ l√Ω h√†nh ƒë·ªông t·ª´ xa
        if (isProcessingRemoteAction) {
            return;
        }
        
        const action = {
            type: actionType,
            data: data,
            deviceId: deviceId,
            deviceName: deviceName,
            timestamp: Date.now(),
            timestampReadable: new Date().toLocaleTimeString()
        };
        
        // L∆∞u l√™n Firebase
        const newActionRef = database.ref('actions').push();
        newActionRef.set(action)
            .then(() => {
                lastSyncTime = Date.now();
                updateSyncStatus();
                log('SYNC', `ƒê√£ g·ª≠i h√†nh ƒë·ªông: ${actionType}`);
                
                // C·∫≠p nh·∫≠t UI
                syncActions.push(action);
                document.getElementById('syncActionsCount').textContent = syncActions.length;
                document.getElementById('syncCount').textContent = syncActions.length;
                
                // Th√™m v√†o l·ªãch s·ª≠ hi·ªÉn th·ªã
                addToActionHistory(action);
            })
            .catch((error) => {
                log('SYNC', `L·ªói g·ª≠i h√†nh ƒë·ªông: ${error.message}`);
            });
    }
    
    function processRemoteAction(action, actionId = null) {
        if (isProcessingRemoteAction) {
            // FIX: N·∫øu ƒëang x·ª≠ l√Ω, ƒë·ª£i m·ªôt ch√∫t r·ªìi th·ª≠ l·∫°i
            setTimeout(() => {
                if (!processedActionIds.has(actionId)) {
                    processRemoteAction(action, actionId);
                }
            }, 100);
            return;
        }
        
        isProcessingRemoteAction = true;
        
        try {
            log('SYNC', `Nh·∫≠n h√†nh ƒë·ªông t·ª´ ${action.deviceName}: ${action.type}`);
            
            // Hi·ªÉn th·ªã th√¥ng b√°o
            showActionNotification(action);
            
            // X·ª≠ l√Ω h√†nh ƒë·ªông d·ª±a tr√™n lo·∫°i
            switch (action.type) {
                case 'addWord':
                    if (action.data && action.data.word && action.data.word !== displayBuffer) {
                        displayBuffer = action.data.word;
                        addWordToSentence();
                    }
                    break;
                    
                case 'backspace':
                    backspace();
                    break;
                    
                case 'clearCurrentWord':
                    clearCurrentWord();
                    break;
                    
                case 'commitSentence':
                    commitSentence();
                    break;
                    
                case 'resetSentence':
                    resetSentence();
                    break;
                    
                case 'startCalibration':
                    if (!isCalibrating) startCalibration();
                    break;
                    
                case 'stopCalibration':
                    if (isCalibrating) stopCalibration();
                    break;
                    
                case 'resetCalibration':
                    resetCalibration();
                    break;
                    
                case 'loadCalibration':
                    loadCalibration();
                    break;
                    
                case 'translate':
                    if (action.data) {
                        const currentInput = document.getElementById('translationInput').value;
                        if (currentInput !== action.data.text) {
                            document.getElementById('translationInput').value = action.data.text || '';
                            if (action.data.sourceLang) {
                                document.getElementById('sourceLanguage').value = action.data.sourceLang;
                            }
                            if (action.data.targetLang) {
                                document.getElementById('targetLanguage').value = action.data.targetLang;
                            }
                            setTimeout(() => translateWithGoogle(), 100);
                        }
                    }
                    break;
                    
                case 'clearTranslation':
                    clearTranslation();
                    break;
                    
                case 'speakVietnamese':
                    if (action.data && action.data.text) {
                        convertedFullSentence = action.data.text;
                        setTimeout(() => speakVietnameseSentence(), 500);
                    }
                    break;
                    
                case 'speakTranslation':
                    if (action.data && action.data.text) {
                        document.getElementById('translationOutput').textContent = action.data.text;
                        setTimeout(() => speakTranslation(), 500);
                    }
                    break;
                    
                case 'stopSpeech':
                    stopAllSpeech();
                    break;
                    
                case 'selectVoice':
                    if (action.data) {
                        const button = document.querySelector(`.voice-btn[data-lang="${action.data.lang}"][data-gender="${action.data.gender}"]`);
                        if (button) {
                            selectVoice(button);
                        }
                    }
                    break;
                    
                case 'toggleTTSMode':
                    if (action.data) {
                        toggleTTSMode(action.data.useGoogleTTS);
                    }
                    break;
                    
                case 'selectPhrase':
                    if (action.data && action.data.phrase) {
                        document.getElementById('translationInput').value = action.data.phrase;
                        setTimeout(() => translateWithGoogle(), 500);
                    }
                    break;
                    
                case 'useSuggestion':
                    if (action.data && action.data.suggestion) {
                        useSuggestion(action.data.suggestion);
                    }
                    break;
                    
                case 'translateSuggestion':
                    if (action.data && action.data.suggestion) {
                        translateSuggestion(action.data.suggestion);
                    }
                    break;
                    
                case 'refreshData':
                    refreshData();
                    break;
                    
                case 'toggleAutoRefresh':
                    toggleAutoRefresh();
                    break;
                    
                case 'toggleTurboMode':
                    toggleTurboMode();
                    break;
                    
                case 'updateTranslationInput':
                    if (action.data && action.data.text) {
                        document.getElementById('translationInput').value = action.data.text;
                    }
                    break;
                    
                case 'changeLanguage':
                    if (action.data) {
                        if (action.data.sourceLang) {
                            document.getElementById('sourceLanguage').value = action.data.sourceLang;
                        }
                        if (action.data.targetLang) {
                            document.getElementById('targetLanguage').value = action.data.targetLang;
                        }
                    }
                    break;
            }
            
            // Th√™m v√†o l·ªãch s·ª≠ hi·ªÉn th·ªã
            addToActionHistory(action);
            
        } catch (error) {
            log('SYNC', `L·ªói x·ª≠ l√Ω h√†nh ƒë·ªông t·ª´ xa: ${error.message}`);
        } finally {
            // FIX: ƒê·∫∑t l·∫°i tr·∫°ng th√°i x·ª≠ l√Ω sau 50ms ƒë·ªÉ tr√°nh l·∫∑p
            setTimeout(() => {
                isProcessingRemoteAction = false;
            }, 50);
        }
    }
    
    function showActionNotification(action) {
        // T·∫°o th√¥ng b√°o t·∫°m th·ªùi
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4A00E0;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 10000;
            animation: slideInRight 0.3s ease;
        `;
        
        notification.innerHTML = `
            <div style="font-weight: bold;">üì° ƒê·ªìng b·ªô t·ª´ ${action.deviceName}</div>
            <div style="font-size: 0.9rem; margin-top: 5px;">${action.type}</div>
            <div style="font-size: 0.7rem; opacity: 0.8; margin-top: 3px;">${action.timestampReadable}</div>
        `;
        
        document.body.appendChild(notification);
        
        // T·ª± ƒë·ªông x√≥a sau 3 gi√¢y
        setTimeout(() => {
            notification.style.animation = 'slideOutRight 0.3s ease';
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 300);
        }, 3000);
        
        // Th√™m style cho animation
        if (!document.getElementById('sync-animations')) {
            const style = document.createElement('style');
            style.id = 'sync-animations';
            style.textContent = `
                @keyframes slideInRight {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                @keyframes slideOutRight {
                    from { transform: translateX(0); opacity: 1; }
                    to { transform: translateX(100%); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
        }
    }
    
    function addToActionHistory(action) {
        const historyDiv = document.getElementById('actionHistory');
        const actionElement = document.createElement('div');
        actionElement.className = 'log-entry';
        actionElement.style.cssText = 'padding: 8px; border-bottom: 1px solid #eee; font-size: 0.85rem;';
        
        const time = new Date(action.timestamp).toLocaleTimeString();
        actionElement.innerHTML = `
            <div style="display: flex; justify-content: space-between;">
                <span style="color: #4A00E0; font-weight: bold;">${action.deviceName}</span>
                <span style="color: #666; font-size: 0.8rem;">${time}</span>
            </div>
            <div style="color: #333; margin-top: 3px;">${action.type}</div>
            ${action.data ? `<div style="color: #666; font-size: 0.8rem; margin-top: 2px;">${JSON.stringify(action.data).substring(0, 50)}...</div>` : ''}
        `;
        
        historyDiv.insertBefore(actionElement, historyDiv.firstChild);
        
        // Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng hi·ªÉn th·ªã
        while (historyDiv.children.length > 10) {
            historyDiv.removeChild(historyDiv.lastChild);
        }
    }
    
    function loadRecentActions() {
        database.ref('actions').orderByChild('timestamp').limitToLast(20).once('value')
            .then((snapshot) => {
                const actions = snapshot.val();
                const historyDiv = document.getElementById('actionHistory');
                historyDiv.innerHTML = '';
                
                if (actions) {
                    const actionArray = [];
                    for (const id in actions) {
                        actionArray.push(actions[id]);
                    }
                    
                    // S·∫Øp x·∫øp theo th·ªùi gian m·ªõi nh·∫•t
                    actionArray.sort((a, b) => b.timestamp - a.timestamp);
                    
                    // Hi·ªÉn th·ªã 10 h√†nh ƒë·ªông g·∫ßn nh·∫•t
                    actionArray.slice(0, 10).forEach(action => {
                        addToActionHistory(action);
                    });
                } else {
                    historyDiv.innerHTML = '<div class="log-entry">Ch∆∞a c√≥ h√†nh ƒë·ªông n√†o</div>';
                }
            });
    }
    
    function syncAllData() {
        // ƒê·ªìng b·ªô t·∫•t c·∫£ tr·∫°ng th√°i hi·ªán t·∫°i
        logAction('syncAll', {
            sentenceWords: sentenceWords,
            displayBuffer: displayBuffer,
            convertedFullSentence: convertedFullSentence,
            translationInput: document.getElementById('translationInput').value,
            translationOutput: document.getElementById('translationOutput').textContent,
            sourceLang: document.getElementById('sourceLanguage').value,
            targetLang: document.getElementById('targetLanguage').value,
            currentVoice: currentVoice,
            useGoogleTTS: useGoogleTTS,
            bentThresholds: bentThresholds
        });
        
        log('SYNC', 'ƒê√£ g·ª≠i y√™u c·∫ßu ƒë·ªìng b·ªô t·∫•t c·∫£ d·ªØ li·ªáu');
    }
    
    function clearAllSync() {
        if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a t·∫•t c·∫£ d·ªØ li·ªáu ƒë·ªìng b·ªô tr√™n Firebase?')) {
            database.ref('actions').remove()
                .then(() => {
                    log('SYNC', 'ƒê√£ x√≥a t·∫•t c·∫£ d·ªØ li·ªáu ƒë·ªìng b·ªô');
                    document.getElementById('actionHistory').innerHTML = '<div class="log-entry">ƒê√£ x√≥a l·ªãch s·ª≠ ƒë·ªìng b·ªô</div>';
                    syncActions = [];
                    processedActionIds.clear();
                    lastActionFromDevice.clear();
                    document.getElementById('syncActionsCount').textContent = '0';
                    document.getElementById('syncCount').textContent = '0';
                })
                .catch((error) => {
                    log('SYNC', `L·ªói x√≥a d·ªØ li·ªáu: ${error.message}`);
                });
        }
    }
    
    function updateSyncStatus() {
        const syncIndicator = document.getElementById('syncIndicator');
        const syncStatus = document.getElementById('syncStatus');
        
        if (isSyncing) {
            const timeSinceSync = Date.now() - lastSyncTime;
            if (timeSinceSync < 5000) {
                syncIndicator.className = 'sync-indicator synced';
                syncStatus.textContent = 'ƒê√£ ƒë·ªìng b·ªô g·∫ßn ƒë√¢y';
            } else {
                syncIndicator.className = 'sync-indicator syncing';
                syncStatus.textContent = 'ƒêang ch·ªù ƒë·ªìng b·ªô...';
            }
        }
    }

    // === H√ÄM HI·ªÜU CHU·∫®N ===
    function startCalibration() {
        if (isCalibrating) return;
        
        isCalibrating = true;
        calibrationCountdown = 10;
        calibrationStartTime = Date.now();
        calibrationMaxValues = [0, 0, 0, 0];
        calibrationCurrentSensor = 0;
        calibrationStep = "calibrating";
        
        document.getElementById('calibrationProgress').style.display = 'block';
        document.getElementById('calibrateBtn').style.display = 'none';
        document.getElementById('stopCalibrateBtn').style.display = 'inline-block';
        
        updateCalibrationStatus("calibrating", "ƒêang hi·ªáu chu·∫©n... Vui l√≤ng u·ªën t·∫•t c·∫£ ng√≥n tay h·∫øt m·ª©c c√≥ th·ªÉ!");
        
        const display = document.getElementById('calibrationDisplay');
        display.innerHTML = '';
        
        for (let i = 0; i < 4; i++) {
            const sensorDiv = document.createElement('div');
            sensorDiv.className = 'sensor-calibration';
            sensorDiv.id = `calibrationSensor${i}`;
            sensorDiv.innerHTML = `
                <div class="sensor-name">C·∫¢M BI·∫æN ${i}</div>
                <div class="sensor-value">0</div>
                <div class="sensor-max">Max: 0</div>
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar${i}" style="width: 0%"></div>
                </div>
            `;
            display.appendChild(sensorDiv);
        }
        
        calibrationInterval = setInterval(updateCalibration, 1000);
        document.getElementById('calibrationMessage').textContent = `ƒêang hi·ªáu chu·∫©n... Vui l√≤ng u·ªën T·∫§T C·∫¢ ng√≥n tay h·∫øt m·ª©c!`;
        
        log('HI·ªÜU CHU·∫®N', 'B·∫Øt ƒë·∫ßu hi·ªáu chu·∫©n c·∫£m bi·∫øn u·ªën');
        logAction('startCalibration');
    }

    function stopCalibration() {
        if (isCalibrating) {
            isCalibrating = false;
            clearInterval(calibrationInterval);
            
            updateCalibrationStatus("ready", "Hi·ªáu chu·∫©n ƒë√£ d·ª´ng");
            
            document.getElementById('calibrationProgress').style.display = 'none';
            document.getElementById('calibrateBtn').style.display = 'inline-block';
            document.getElementById('stopCalibrateBtn').style.display = 'none';
            
            log('HI·ªÜU CHU·∫®N', 'Hi·ªáu chu·∫©n ƒë√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng');
            logAction('stopCalibration');
        }
    }

    function resetCalibration() {
        bentThresholds = [300, 450, 350, 300];
        localStorage.removeItem('bentThresholds');
        
        updateThresholdDisplay();
        updateCalibrationStatus("ready", "ƒê√£ reset v·ªÅ gi√° tr·ªã m·∫∑c ƒë·ªãnh");
        
        log('HI·ªÜU CHU·∫®N', 'Reset hi·ªáu chu·∫©n v·ªÅ gi√° tr·ªã m·∫∑c ƒë·ªãnh');
        logAction('resetCalibration');
    }

    function loadCalibration() {
        const savedThresholds = localStorage.getItem('bentThresholds');
        if (savedThresholds) {
            try {
                bentThresholds = JSON.parse(savedThresholds);
                updateThresholdDisplay();
                updateCalibrationStatus("calibrated", "ƒê√£ t·∫£i hi·ªáu chu·∫©n t·ª´ b·ªô nh·ªõ");
                log('HI·ªÜU CHU·∫®N', `ƒê√£ t·∫£i hi·ªáu chu·∫©n: ${bentThresholds}`);
            } catch (e) {
                log('HI·ªÜU CHU·∫®N', `L·ªói khi t·∫£i hi·ªáu chu·∫©n: ${e.message}`);
            }
        } else {
            updateCalibrationStatus("ready", "Kh√¥ng t√¨m th·∫•y hi·ªáu chu·∫©n ƒë√£ l∆∞u");
            log('HI·ªÜU CHU·∫®N', 'Kh√¥ng t√¨m th·∫•y hi·ªáu chu·∫©n ƒë√£ l∆∞u');
        }
        logAction('loadCalibration');
    }

    // === C√ÅC H√ÄM CH√çNH V·ªöI LOG ACTION ===
    
    function addWordToSentence() {
        if (!displayBuffer || displayBuffer === "---" || displayBuffer.length === 0) {
            log('SENTENCE', 'Kh√¥ng th·ªÉ th√™m t·ª´ tr·ªëng v√†o c√¢u');
            return;
        }
        
        if (sentenceWords.length < 10) {
            sentenceWords.push(displayBuffer);
            scheduleUIUpdate();
            log('SENTENCE', `ƒê√£ th√™m: '${displayBuffer}'`);
            
            // G·ª≠i h√†nh ƒë·ªông l√™n Firebase
            logAction('addWord', { word: displayBuffer });
            
            slot1 = '';
            slot2 = '';
            displayBuffer = '';
            convertedCurrentWord = '';
            
            scheduleUIUpdate();
        } else {
            log('SENTENCE', 'C√¢u ƒë√£ ƒë·∫ßy! T·ªëi ƒëa 10 t·ª´.');
        }
    }
    
    function backspace() {
        backspaceBuffer();
        scheduleUIUpdate();
        logAction('backspace');
    }
    
    function clearCurrentWord() {
        slot1 = '';
        slot2 = '';
        displayBuffer = '';
        convertedCurrentWord = '';
        
        document.getElementById('dynamicSuggestions').innerHTML = '';
        document.getElementById('dynamicSuggestions').classList.remove('show');
        
        scheduleUIUpdate();
        log('WORD', 'ƒê√£ x√≥a t·ª´ hi·ªán t·∫°i');
        logAction('clearCurrentWord');
    }
    
    function commitSentence() {
        if (sentenceWords.length === 0) {
            log('SENTENCE', 'Kh√¥ng c√≥ t·ª´ n√†o ƒë·ªÉ ho√†n th√†nh!');
            return;
        }
        
        if (displayBuffer && displayBuffer.length > 0 && displayBuffer !== "---") {
            addWordToSentence();
        }
        
        log('SENTENCE', '=== C√ÇU ƒê√É HO√ÄN TH√ÄNH ===');
        log('SENTENCE', `ƒê·∫ßy ƒë·ªß: ${fullSentence}`);
        log('CONVERSION', `ƒê√£ chuy·ªÉn ƒë·ªïi: ${convertedFullSentence}`);
        
        logAction('commitSentence', { sentence: fullSentence, convertedSentence: convertedFullSentence });
        
        if (convertedFullSentence && convertedFullSentence !== "---") {
            document.getElementById('translationInput').value = convertedFullSentence;
            setTimeout(() => {
                translateWithGoogle();
            }, 500);
        }
        
        resetSentence();
    }
    
    function resetSentence() {
        sentenceWords = [];
        fullSentence = '';
        convertedFullSentence = '';
        slot1 = '';
        slot2 = '';
        displayBuffer = '';
        convertedCurrentWord = '';
        
        document.getElementById('autoSuggestionsPanel').style.display = 'none';
        document.getElementById('dynamicSuggestions').innerHTML = '';
        document.getElementById('dynamicSuggestions').classList.remove('show');
        
        log('SENTENCE', 'ƒê√£ ƒë·∫∑t l·∫°i c√¢u');
        logAction('resetSentence');
        scheduleUIUpdate();
    }
    
    async function translateWithGoogle() {
        const textarea = document.getElementById('translationInput');
        const text = textarea.value.trim();
        const sourceLang = document.getElementById('sourceLanguage').value;
        const targetLang = document.getElementById('targetLanguage').value;
        const outputDiv = document.getElementById('translationOutput');
        
        if (!text) {
            outputDiv.innerHTML = '<span style="color: #F44336;">Vui l√≤ng nh·∫≠p vƒÉn b·∫£n ƒë·ªÉ d·ªãch!</span>';
            outputDiv.className = 'conversion-display error';
            return;
        }
        
        const cacheKey = text + '|' + sourceLang + '|' + targetLang;
        if (translationCache[cacheKey]) {
            outputDiv.innerHTML = translationCache[cacheKey];
            outputDiv.className = 'conversion-display success';
            log('TRANSLATION', `S·ª≠ d·ª•ng k·∫øt qu·∫£ d·ªãch t·ª´ cache`);
            return;
        }
        
        outputDiv.innerHTML = '<span class="loading">ƒêang d·ªãch v·ªõi Google Translate... ‚è≥</span>';
        outputDiv.className = 'conversion-display loading';
        
        try {
            const encodedText = encodeURIComponent(text);
            const apiUrl = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${sourceLang}&tl=${targetLang}&dt=t&q=${encodedText}`;
            
            const response = await fetch(apiUrl);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            const data = await response.json();
            let translated = '';
            
            if (data && data[0]) {
                data[0].forEach(item => {
                    if (item[0]) {
                        translated += item[0];
                    }
                });
            }
            
            translationCache[cacheKey] = translated;
            
            const cacheKeys = Object.keys(translationCache);
            if (cacheKeys.length > 50) {
                delete translationCache[cacheKeys[0]];
            }
            
            outputDiv.innerHTML = translated;
            outputDiv.className = 'conversion-display success';
            
            log('TRANSLATION', `ƒê√£ d·ªãch t·ª´ ${sourceLang} sang ${targetLang}: ${translated.substring(0, 100)}...`);
            
            // G·ª≠i h√†nh ƒë·ªông l√™n Firebase
            logAction('translate', { 
                text: text, 
                translated: translated,
                sourceLang: sourceLang, 
                targetLang: targetLang 
            });
            
        } catch (error) {
            console.error('Translation error:', error);
            outputDiv.innerHTML = '<span style="color: #F44336;">D·ªãch thu·∫≠t th·∫•t b·∫°i. Vui l√≤ng th·ª≠ l·∫°i sau.</span>';
            outputDiv.className = 'conversion-display error';
            log('TRANSLATION', `L·ªói d·ªãch thu·∫≠t: ${error.message}`);
        }
    }
    
    function clearTranslation() {
        document.getElementById('translationOutput').innerHTML = 'ƒêang ch·ªù d·ªãch...';
        document.getElementById('translationOutput').className = 'conversion-display';
        logAction('clearTranslation');
    }
    
    async function speakVietnameseSentence() {
        const text = convertedFullSentence || document.getElementById('convertedSentenceDisplay').textContent;
        if (!text || text === '---' || text.trim().length === 0) {
            log('SPEECH', 'Kh√¥ng c√≥ vƒÉn b·∫£n ti·∫øng Vi·ªát ƒë·ªÉ ƒë·ªçc');
            return;
        }
        
        await speakText(text, currentVoice.lang, currentVoice.gender);
        logAction('speakVietnamese', { text: text });
    }
    
    async function speakTranslation() {
        const text = document.getElementById('translationOutput').textContent;
        if (!text || text.includes('ƒêang ch·ªù d·ªãch') || text.includes('Vui l√≤ng nh·∫≠p') || text.trim().length === 0) {
            log('SPEECH', 'Kh√¥ng c√≥ vƒÉn b·∫£n d·ªãch ƒë·ªÉ ƒë·ªçc');
            return;
        }
        
        const targetLang = document.getElementById('targetLanguage').value;
        const langMap = {
            'vi': 'vi-VN',
            'en': 'en-GB',
            'ja': 'ja-JP',
            'ko': 'ko-KR',
            'zh-CN': 'zh-CN'
        };
        
        const langCode = langMap[targetLang] || targetLang;
        
        await speakText(text, langCode, currentVoice.gender || 'male');
        logAction('speakTranslation', { text: text, lang: langCode });
    }
    
    function stopAllSpeech() {
        if (window.speechSynthesis) {
            window.speechSynthesis.cancel();
        }
        
        if (currentSpeech) {
            if (currentSpeech.pause) {
                currentSpeech.pause();
                currentSpeech.currentTime = 0;
            }
            currentSpeech = null;
        }
        
        setIsSpeaking(false);
        stopAudioVisualizer();
        updateUI();
        
        log('SPEECH', 'ƒê√£ d·ª´ng t·∫•t c·∫£ gi·ªçng n√≥i');
        logAction('stopSpeech');
    }
    
    function selectVoice(button) {
        const lang = button.getAttribute('data-lang');
        const gender = button.getAttribute('data-gender');
        
        currentVoice = {
            lang: lang,
            gender: gender,
            accent: 'native'
        };
        
        document.querySelectorAll('.voice-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        button.classList.add('active');
        
        updateUI();
        log('VOICE', `ƒê√£ ch·ªçn gi·ªçng: ${TTS_CONFIG.langDisplayNames[lang] || lang} ${gender === 'male' ? 'Nam' : 'N·ªØ'}`);
        
        logAction('selectVoice', { lang: lang, gender: gender });
    }
    
    function toggleTTSMode(useGoogle) {
        useGoogleTTS = useGoogle;
        
        document.getElementById('useGoogleTTS').classList.toggle('active', useGoogle);
        document.getElementById('useWebSpeech').classList.toggle('active', !useGoogle);
        
        updateUI();
        log('TTS', `Chuy·ªÉn sang ${useGoogle ? 'Google TTS Proxy' : 'Web Speech API'}`);
        
        logAction('toggleTTSMode', { useGoogleTTS: useGoogle });
    }
    
    function refreshData() {
        fetchFirebaseDataOptimized();
        logAction('refreshData');
    }
    
    function toggleAutoRefresh() {
        autoRefresh = !autoRefresh;
        const btn = document.getElementById('autoRefreshBtn');
        
        if (autoRefresh) {
            btn.textContent = `T·ª± ƒë·ªông: B·∫¨T (${pollingInterval}ms)`;
            btn.className = 'green';
            
            function scheduleNextRefresh() {
                if (!autoRefresh) return;
                
                setTimeout(() => {
                    if (autoRefresh) {
                        fetchFirebaseDataOptimized().then(() => {
                            if (autoRefresh) {
                                scheduleNextRefresh();
                            }
                        });
                    }
                }, pollingInterval);
            }
            
            scheduleNextRefresh();
            log('SYSTEM', `B·∫≠t t·ª± ƒë·ªông l√†m m·ªõi ${pollingInterval}ms`);
        } else {
            btn.textContent = 'T·ª± ƒë·ªông: T·∫ÆT';
            btn.className = 'red';
            log('SYSTEM', 'T·∫Øt t·ª± ƒë·ªông l√†m m·ªõi');
        }
        
        logAction('toggleAutoRefresh', { autoRefresh: autoRefresh });
    }
    
    function toggleTurboMode() {
        turboMode = !turboMode;
        const btn = document.getElementById('turboBtn');
        
        if (turboMode) {
            pollingInterval = 150;
            btn.textContent = 'üöÄ Turbo: B·∫¨T';
            btn.className = 'red';
            document.getElementById('fastModeIndicator').style.display = 'block';
            log('SYSTEM', 'B·∫≠t ch·∫ø ƒë·ªô Turbo (150ms polling)');
        } else {
            pollingInterval = 300;
            btn.textContent = 'üöÄ Ch·∫ø ƒë·ªô Turbo';
            btn.className = 'green';
            document.getElementById('fastModeIndicator').style.display = 'none';
            log('SYSTEM', 'T·∫Øt ch·∫ø ƒë·ªô Turbo');
        }
        
        updatePollingDisplay();
        
        if (autoRefresh) {
            toggleAutoRefresh();
            toggleAutoRefresh();
        }
        
        logAction('toggleTurboMode', { turboMode: turboMode });
    }
    
    function updateLanguage() {
        const sourceLang = document.getElementById('sourceLanguage').value;
        const targetLang = document.getElementById('targetLanguage').value;
        
        logAction('changeLanguage', { 
            sourceLang: sourceLang, 
            targetLang: targetLang 
        });
    }
    
    function handleTranslationInput() {
        const input = document.getElementById('translationInput').value;
        const suggestionsDiv = document.getElementById('translationSuggestions');
        
        if (!input || input.trim().length === 0) {
            suggestionsDiv.innerHTML = '';
            suggestionsDiv.classList.remove('show');
            return;
        }
        
        const inputLower = input.toLowerCase();
        const filteredPhrases = commonPhrases.filter(phrase => 
            phrase.toLowerCase().includes(inputLower) && phrase !== input
        );
        
        if (filteredPhrases.length > 0) {
            suggestionsDiv.innerHTML = filteredPhrases.map(phrase => `
                <div class="suggestion-item" onclick="selectTranslationSuggestion('${phrase.replace(/'/g, "\\'")}')">
                    ${phrase}
                </div>
            `).join('');
            suggestionsDiv.classList.add('show');
        } else {
            suggestionsDiv.innerHTML = '';
            suggestionsDiv.classList.remove('show');
        }
        
        // G·ª≠i h√†nh ƒë·ªông c·∫≠p nh·∫≠t input
        logAction('updateTranslationInput', { text: input });
    }
    
    function selectTranslationSuggestion(phrase) {
        document.getElementById('translationInput').value = phrase;
        document.getElementById('translationSuggestions').innerHTML = '';
        document.getElementById('translationSuggestions').classList.remove('show');
        translateWithGoogle();
        
        logAction('selectPhrase', { phrase: phrase });
    }
    
    function translatePhrase(phrase) {
        document.getElementById('translationInput').value = phrase;
        translateWithGoogle();
        logAction('selectPhrase', { phrase: phrase });
    }
    
    function useSuggestion(text) {
        document.getElementById('translationInput').value = text;
        translateWithGoogle();
        log('SUGGESTION', `S·ª≠ d·ª•ng ƒë·ªÅ xu·∫•t: "${text}"`);
        logAction('useSuggestion', { suggestion: text });
    }
    
    function translateSuggestion(text) {
        document.getElementById('translationInput').value = text;
        translateWithGoogle();
        log('SUGGESTION', `D·ªãch ƒë·ªÅ xu·∫•t: "${text}"`);
        logAction('translateSuggestion', { suggestion: text });
    }

    // === C√ÅC H√ÄM H·ªñ TR·ª¢ KH√ÅC ===
    
    async function fetchFirebaseDataOptimized() {
        if (isFetching) return null;
        
        if (currentFetchController) {
            currentFetchController.abort();
        }
        
        isFetching = true;
        const startTime = performance.now();
        currentFetchController = new AbortController();
        const signal = currentFetchController.signal;
        
        try {
            const timestamp = Date.now();
            const url = `${FIREBASE_URL}?t=${timestamp}`;
            
            const response = await fetch(url, {
                signal,
                method: 'GET',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                },
                priority: 'high'
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            const data = await response.json();
            const fetchTime = performance.now() - startTime;
            
            document.getElementById('latency').textContent = Math.round(fetchTime);
            
            if (JSON.stringify(data) !== JSON.stringify(lastFirebaseData)) {
                lastFirebaseData = data;
                firebaseData = data;
                lastUpdateTime = Date.now();
                
                updateConnectionStatus(true);
                processDataImmediately(data);
                scheduleUIUpdate();
                
                log('Firebase', `Data updated (${Math.round(fetchTime)}ms)`);
                
                if (fetchTime < 100) {
                    pollingInterval = turboMode ? 150 : 250;
                } else if (fetchTime > 500) {
                    pollingInterval = 1000;
                }
                
                updatePollingDisplay();
            } else {
                lastUpdateTime = Date.now();
                document.getElementById('lastUpdate').textContent = 
                    `C·∫≠p nh·∫≠t: ${formatTime(Date.now())}`;
            }
            
            return data;
            
        } catch (error) {
            if (error.name !== 'AbortError') {
                console.warn('Fetch error:', error);
                updateConnectionStatus(false);
                log('Firebase', `Error: ${error.message}`);
                
                pollingInterval = Math.min(pollingInterval * 2, 5000);
                updatePollingDisplay();
            }
            return null;
        } finally {
            isFetching = false;
            const totalTime = performance.now() - startTime;
            document.getElementById('processingTime').textContent = `${Math.round(totalTime)}ms`;
        }
    }
    
    function processDataImmediately(data) {
        const startTime = performance.now();
        
        if (data.o !== undefined) {
            const mpuElement = document.getElementById('mpuOrientation');
            if (mpuElement.textContent !== data.o) {
                mpuElement.textContent = data.o || 'N/A';
            }
        }
        
        if (data.d !== undefined) {
            const shakeElement = document.getElementById('mpuShakeState');
            if (shakeElement.textContent !== data.d) {
                shakeElement.textContent = data.d || 'No';
            }
        }
        
        if (data.sf !== undefined) {
            const isShakingElement = document.getElementById('isShaking');
            if (isShakingElement.textContent !== data.sf) {
                isShakingElement.textContent = data.sf || 'NO';
            }
        }
        
        if (data.f0 !== undefined) {
            const flexValues = [data.f0, data.f1 || 0, data.f2 || 0, data.f3 || 0];
            for (let i = 0; i < 4; i++) {
                const newState = calculateFlexState(flexValues[i], i);
                if (flexStates[i] !== newState) {
                    flexStates[i] = newState;
                }
            }
        }
        
        setTimeout(() => {
            const mpuState = getMPUState(data.o || "", data.d || "");
            const a0 = flexStates[0];
            const a1 = flexStates[1];
            const a2 = flexStates[2];
            const a3 = flexStates[3];
            
            processWordConstructionFast(mpuState, a0, a1, a2, a3);
        }, 0);
    }
    
    function calculateFlexState(rawValue, sensorIndex) {
        const STRAIGHT_THRESHOLD = STRAIGHT_THRESHOLDS[sensorIndex];
        
        if (rawValue <= STRAIGHT_THRESHOLD) return 0;
        if (rawValue <= bentThresholds[sensorIndex]) return 1;
        return 2;
    }
    
    function processWordConstructionFast(mpu, a0, a1, a2, a3) {
        const currentState = `${mpu}_${a0}_${a1}_${a2}_${a3}`;
        
        if (currentState !== lastStateString) {
            lastStateString = currentState;
            stableCount = 0;
            holdStartMs = Date.now();
            holdFired = false;
        } else {
            stableCount++;
        }
        
        lastFlexStates = [a0, a1, a2, a3];
        
        if (stableCount >= DEBOUNCE_COUNT) {
            const held = Date.now() - holdStartMs;
            if (!holdFired && held >= HOLD_MS_DEFAULT) {
                if (Date.now() - lastActionMs > POST_HOLD_COOLDOWN) {
                    performActionSlotLogic(mpu, a0, a1, a2, a3);
                    holdFired = true;
                    lastActionMs = Date.now();
                }
            }
        }
    }
    
    function performActionSlotLogic(mpu, a0, a1, a2, a3) {
        const mapping = getMappingForIndicesCached(mpu, a0, a1, a2, a3);
        if (!mapping || mapping === "nullptr") return false;
        
        if (mapping === "_") {
            if (displayBuffer && displayBuffer.length > 0 && displayBuffer !== "---") {
                addWordToSentence();
            } else {
                log('WORD', 'D·∫•u c√°ch ƒë∆∞·ª£c ph√°t hi·ªán, nh∆∞ng kh√¥ng c√≥ t·ª´ trong b·ªô ƒë·ªám');
            }
            return true;
        }
        
        if (mapping === "COMMIT") {
            commitSentence();
            return true;
        }
        
        if (mapping === "<") {
            backspaceBuffer();
            scheduleUIUpdate();
            return true;
        }
        
        const isSlot1 = (a3 === 2);
        const held = Date.now() - holdStartMs;
        
        if (isSlot1 && stableCount >= DEBOUNCE_COUNT && held < HOLD_MS_DEFAULT) {
            const mode = flexModeCharFromA0(a0);
            slot2 = `${mapping}_${mode}`;
        } else if (isSlot1) {
            slot1 = `${mapping}_${mpu}`;
        } else {
            const mode = flexModeCharFromA0(a0);
            slot2 = `${mapping}_${mode}`;
        }
        
        updateDisplayBufferFromSlots();
        log('WORD', `H√†nh ƒë·ªông: ${displayBuffer}`);
        return true;
    }
    
    function updateDisplayBufferFromSlots() {
        const oldBuffer = displayBuffer;
        displayBuffer = '';
        
        if (slot1) displayBuffer += slot1.toLowerCase();
        if (slot2) displayBuffer += slot2.toLowerCase();
        
        if (oldBuffer !== displayBuffer) {
            scheduleUIUpdate();
            log('WORD', `ƒê√£ c·∫≠p nh·∫≠t: ${displayBuffer}`);
        }
    }
    
    function backspaceBuffer() {
        if (displayBuffer.length > 0) {
            displayBuffer = displayBuffer.slice(0, -1);
            log('WORD', `X√≥a k√Ω t·ª± - B·ªô ƒë·ªám: ${displayBuffer}`);
        }
    }
    
    function scheduleUIUpdate() {
        if (!uiUpdateScheduled) {
            uiUpdateScheduled = true;
            requestAnimationFrame(() => {
                updateCriticalUI();
                uiUpdateScheduled = false;
            });
        }
    }
    
    function updateCriticalUI() {
        const startTime = performance.now();
        
        updateSensorDisplay();
        updateWordDisplays();
        updateSentenceDisplay();
        
        const updateTime = document.getElementById('lastUpdate');
        const currentTime = formatTime(Date.now());
        if (updateTime.textContent !== `C·∫≠p nh·∫≠t: ${currentTime}`) {
            updateTime.textContent = `C·∫≠p nh·∫≠t: ${currentTime}`;
            document.getElementById('lastUpdateTime').textContent = currentTime;
        }
        
        const uiTime = performance.now() - startTime;
        if (uiTime > 16) {
            console.warn(`UI update slow: ${Math.round(uiTime)}ms`);
        }
    }
    
    function updateSensorDisplay() {
        for (let i = 0; i < 4; i++) {
            const box = document.getElementById(`flex${i}-box`);
            if (box && box.textContent !== flexStates[i].toString()) {
                box.textContent = flexStates[i];
                box.className = `flex-box active-${flexStates[i]}`;
            }
        }
        
        if (firebaseData) {
            const rawValues = [firebaseData.f0 || 0, firebaseData.f1 || 0, firebaseData.f2 || 0, firebaseData.f3 || 0];
            const rawValuesElement = document.getElementById('rawValues');
            const newRawText = rawValues.join(', ');
            if (rawValuesElement.textContent !== newRawText) {
                rawValuesElement.textContent = newRawText;
            }
            
            const flexFormatElement = document.getElementById('flexFormat');
            const newFlexText = flexStates.join('');
            if (flexFormatElement.textContent !== newFlexText) {
                flexFormatElement.textContent = newFlexText;
            }
        }
    }
    
    function updateWordDisplays() {
        if (displayBuffer.length > 0) {
            convertedCurrentWord = convertVietnameseWordCached(displayBuffer);
        } else {
            convertedCurrentWord = "";
        }

        const displayBufferElement = document.getElementById('displayBuffer');
        if (displayBufferElement.textContent !== convertedCurrentWord) {
            displayBufferElement.textContent = convertedCurrentWord || '---';
        }
        
        const slot1Element = document.getElementById('slot1');
        if (slot1Element.textContent !== slot1) {
            slot1Element.textContent = slot1 || '---';
        }
        
        const slot2Element = document.getElementById('slot2');
        if (slot2Element.textContent !== slot2) {
            slot2Element.textContent = slot2 || '---';
        }
        
        const convertedWordElement = document.getElementById('convertedCurrentWord');
        if (convertedWordElement.textContent !== displayBuffer) {
            convertedWordElement.textContent = displayBuffer || '---';
        }
    }
    
    function updateSentenceDisplay() {
        const sentenceElement = document.getElementById('sentenceDisplay');
        const newSentence = sentenceWords.join(' ');
        
        if (fullSentence !== newSentence) {
            fullSentence = newSentence;
            sentenceElement.textContent = fullSentence || '---';
            
            convertedFullSentence = convertVietnameseTextFast(fullSentence);
            const convertedElement = document.getElementById('convertedSentenceDisplay');
            convertedElement.textContent = convertedFullSentence || '---';
            
            updateWordList();
            
            const wordCountElement = document.getElementById('wordCount');
            wordCountElement.textContent = sentenceWords.length;
            
            showAutoSuggestions();
        }
    }
    
    function updateWordList() {
        const wordListDiv = document.getElementById('wordList');
        if (sentenceWords.length > 0) {
            wordListDiv.innerHTML = sentenceWords.map(word => 
                `<div class="word-item">${word}</div>`
            ).join('');
        } else {
            wordListDiv.innerHTML = 'Ch∆∞a c√≥ t·ª´ n√†o';
        }
    }
    
    function convertVietnameseWordCached(encodedWord) {
        if (!encodedWord || encodedWord.length === 0) return "";
        
        if (vietnameseCache.has(encodedWord)) {
            return vietnameseCache.get(encodedWord);
        }
        
        const result = convertVietnameseWordOriginal(encodedWord);
        vietnameseCache.set(encodedWord, result);
        return result;
    }
    
    function getMappingForIndicesCached(mpuState, a0, a1, a2, a3) {
        const cacheKey = `${mpuState}_${a0}_${a1}_${a2}_${a3}`;
        
        if (mappingCache.has(cacheKey)) {
            return mappingCache.get(cacheKey);
        }
        
        const result = getMappingForIndicesOriginal(mpuState, a0, a1, a2, a3);
        mappingCache.set(cacheKey, result);
        return result;
    }
    
    function getMappingForIndicesOriginal(mpuState, a0, a1, a2, a3) {
        if (mpuState < 0 || mpuState > 7) return null;
        
        if (a3 === 2) {
            if (a0 < 3 && a1 < 3 && a2 < 3) {
                return tableC[a0][a1][a2];
            }
            return null;
        }
        
        const a3bin = a3 === 1 ? 1 : 0;
        if (a1 < 0 || a1 >= 3 || a2 < 0 || a2 >= 3) return null;
        
        const flatIndex = a1 * 3 + a2;
        
        if (flatIndex >= 0 && flatIndex < 9) {
            return a3bin === 0 ? tableA[mpuState][flatIndex] : tableB[mpuState][flatIndex];
        }
        
        return null;
    }
    
    function flexModeCharFromA0(a0) {
        switch(a0) {
            case 0: return 's';
            case 1: return 'b';
            case 2: return 'p';
            default: return 'x';
        }
    }
    
    function updateCalibrationStatus(status, message) {
        const statusDiv = document.getElementById('calibrationStatus');
        statusDiv.innerHTML = '';
        
        let statusClass = "";
        let statusText = "";
        
        switch(status) {
            case "calibrating":
                statusClass = "calibrating";
                statusText = "ƒêANG HI·ªÜU CHU·∫®N";
                break;
            case "calibrated":
                statusClass = "calibrated";
                statusText = "ƒê√É HI·ªÜU CHU·∫®N";
                break;
            case "error":
                statusClass = "calibration-error";
                statusText = "L·ªñI HI·ªÜU CHU·∫®N";
                break;
            default:
                statusClass = "calibration-ready";
                statusText = "S·∫¥N S√ÄNG";
        }
        
        const div = document.createElement('div');
        div.className = statusClass;
        div.innerHTML = `
            <div>${statusText}</div>
            <div style="font-size: 0.9rem; margin-top: 5px;">${message}</div>
        `;
        statusDiv.appendChild(div);
    }
    
    function updateThresholdDisplay() {
        for (let i = 0; i < 4; i++) {
            document.getElementById(`currentThreshold${i}`).textContent = bentThresholds[i];
        }
    }
    
    function log(source, message) {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = { timestamp, source, message };
        
        logEntries.unshift(logEntry);
        if (logEntries.length > MAX_LOG_ENTRIES) {
            logEntries.pop();
        }
        
        updateLogDisplay();
    }
    
    function updateLogDisplay() {
        const logContainer = document.getElementById('logContainer');
        const visibleEntries = logEntries.slice(0, 5);
        
        logContainer.innerHTML = visibleEntries.map(entry => 
            `<div class="log-entry">
                <span style="color: #666; font-size: 0.8rem;">[${entry.timestamp}] ${entry.source}:</span>
                <span style="color: #333;"> ${entry.message}</span>
            </div>`
        ).join('');
    }
    
    function clearLog() {
        logEntries = [];
        updateLogDisplay();
    }
    
    function exportLog() {
        const logText = logEntries.map(entry => 
            `[${entry.timestamp}] ${entry.source}: ${entry.message}`
        ).join('\n');
        
        const blob = new Blob([logText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `log_${new Date().toISOString().slice(0, 10)}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    
    function updateConnectionStatus(connected) {
        const indicator = document.getElementById('connectionStatus');
        const statusText = document.getElementById('statusText');
        const firebaseStatus = document.getElementById('firebaseStatus');
        
        if (connected) {
            indicator.className = 'indicator online';
            statusText.textContent = 'ƒê√£ k·∫øt n·ªëi v·ªõi Firebase';
            firebaseStatus.textContent = 'ƒê√£ k·∫øt n·ªëi v·ªõi Firebase';
            firebaseStatus.style.color = '#4CAF50';
        } else {
            indicator.className = 'indicator';
            indicator.style.background = '#F44336';
            statusText.textContent = 'M·∫•t k·∫øt n·ªëi v·ªõi Firebase';
            firebaseStatus.textContent = 'M·∫•t k·∫øt n·ªëi v·ªõi Firebase';
            firebaseStatus.style.color = '#F44336';
        }
    }
    
    function formatTime(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }
    
    function getMPUState(orientation, shakeState) {
        if (shakeState === "Shake Left") return 6;
        if (shakeState === "Shake Right") return 7;
        
        switch(orientation) {
            case "Up": return 0;
            case "Down": return 1;
            case "Left": return 2;
            case "Right": return 3;
            case "Forward": return 4;
            case "Backward": return 5;
            default: return -1;
        }
    }
    
    function updatePollingDisplay() {
        document.getElementById('pollingRate').textContent = pollingInterval;
        const btn = document.getElementById('autoRefreshBtn');
        if (autoRefresh) {
            btn.textContent = `T·ª± ƒë·ªông: B·∫¨T (${pollingInterval}ms)`;
        }
    }
    
    function loadPhraseSuggestions() {
        const phrasePills = document.getElementById('phrasePills');
        phrasePills.innerHTML = '';
        
        commonPhrases.forEach(phrase => {
            const pill = document.createElement('button');
            pill.className = 'phrase-pill';
            pill.textContent = phrase.length > 30 ? phrase.substring(0, 27) + '...' : phrase;
            pill.onclick = () => {
                document.getElementById('translationInput').value = phrase;
                translatePhrase(phrase);
                log('PHRASE', `ƒê√£ ch·ªçn c·ª•m t·ª´: "${phrase}"`);
            };
            pill.title = phrase;
            phrasePills.appendChild(pill);
        });
    }
    
    function normalizeVietnamese(str) {
        if (!str) return '';
        return str.normalize('NFD')
                  .replace(/[\u0300-\u036f]/g, '')
                  .toLowerCase()
                  .trim();
    }
    
    function showAutoSuggestions() {
        if (sentenceWords.length === 0) {
            document.getElementById('autoSuggestionsPanel').style.display = 'none';
            return;
        }
        
        const panel = document.getElementById('autoSuggestionsPanel');
        const grid = document.getElementById('autoSuggestionsGrid');
        
        const currentSentence = convertedFullSentence || '';
        
        if (!currentSentence || currentSentence === '---') {
            panel.style.display = 'none';
            return;
        }
        
        const normalizedSentence = normalizeVietnamese(currentSentence);
        
        const words = normalizedSentence.split(/[\s,.!?;:]+/)
            .filter(word => word.length > 1);
        
        if (words.length === 0) {
            panel.style.display = 'none';
            return;
        }
        
        const suggestions = [];
        const usedPhrases = new Set();
        
        commonPhrases.forEach(phrase => {
            const normalizedPhrase = normalizeVietnamese(phrase);
            let matchedWords = 0;
            
            words.forEach(word => {
                if (normalizedPhrase.includes(word)) {
                    matchedWords++;
                }
            });
            
            if (matchedWords > 0 && !usedPhrases.has(phrase)) {
                suggestions.push({
                    text: phrase,
                    score: matchedWords,
                    wordsMatched: matchedWords
                });
                usedPhrases.add(phrase);
            }
        });
        
        suggestions.sort((a, b) => b.score - a.score);
        
        const topSuggestions = suggestions.slice(0, 6);
        
        if (topSuggestions.length === 0) {
            const defaultSuggestions = getDefaultSuggestions(words);
            topSuggestions.push(...defaultSuggestions);
        }
        
        grid.innerHTML = topSuggestions.map(suggestion => `
            <div class="auto-suggestion-item">
                <div class="auto-suggestion-text">${suggestion.text}</div>
                <div class="suggestion-header">
                    <small>üìå Kh·ªõp ${suggestion.wordsMatched || 0} t·ª´ trong c√¢u c·ªßa b·∫°n</small>
                </div>
                <div class="auto-suggestion-actions">
                    <button class="auto-suggestion-btn speak" onclick="speakText('${suggestion.text.replace(/'/g, "\\'")}', 'vi-VN')">üîä ƒê·ªçc</button>
                    <button class="auto-suggestion-btn use" onclick="useSuggestion('${suggestion.text.replace(/'/g, "\\'")}')">üìù D√πng</button>
                    <button class="auto-suggestion-btn translate" onclick="translateSuggestion('${suggestion.text.replace(/'/g, "\\'")}')">üåê D·ªãch</button>
                </div>
            </div>
        `).join('');
        
        panel.style.display = 'block';
        log('SUGGESTION', `T√¨m th·∫•y ${topSuggestions.length} ƒë·ªÅ xu·∫•t cho c√¢u: "${currentSentence.substring(0, 30)}..."`);
    }
    
    function getDefaultSuggestions(words) {
        const defaultSuggestions = [];
        
        const keywordMap = {
            'chao': ['Xin ch√†o, r·∫•t vui ƒë∆∞·ª£c g·∫∑p b·∫°n', 'Ch√†o bu·ªïi s√°ng'],
            'xin': ['L√†m ∆°n cho t√¥i xin h√≥a ƒë∆°n', 'Xin ch√†o, r·∫•t vui ƒë∆∞·ª£c g·∫∑p b·∫°n'],
            'cam': ['C·∫£m ∆°n b·∫°n r·∫•t nhi·ªÅu'],
            'hoi': ['L√†m ∆°n cho t√¥i h·ªèi ƒë∆∞·ªùng', 'B·∫°n c√≥ th·ªÉ n√≥i ch·∫≠m h∆°n ƒë∆∞·ª£c kh√¥ng?'],
            'duong': ['L√†m ∆°n cho t√¥i h·ªèi ƒë∆∞·ªùng'],
            'noi': ['B·∫°n c√≥ th·ªÉ n√≥i ch·∫≠m h∆°n ƒë∆∞·ª£c kh√¥ng?'],
            'cham': ['B·∫°n c√≥ th·ªÉ n√≥i ch·∫≠m h∆°n ƒë∆∞·ª£c kh√¥ng?'],
            'hieu': ['T√¥i kh√¥ng hi·ªÉu'],
            'ten': ['B·∫°n t√™n l√† g√¨?'],
            'giup': ['T√¥i c√≥ th·ªÉ gi√∫p g√¨ kh√¥ng?']
        };
        
        words.forEach(word => {
            if (keywordMap[word]) {
                keywordMap[word].forEach(phrase => {
                    if (!defaultSuggestions.some(s => s.text === phrase)) {
                        defaultSuggestions.push({
                            text: phrase,
                            wordsMatched: 1
                        });
                    }
                });
            }
        });
        
        if (defaultSuggestions.length === 0) {
            defaultSuggestions.push(
                { text: 'B·∫°n c√≥ th·ªÉ n√≥i ch·∫≠m h∆°n ƒë∆∞·ª£c kh√¥ng?', wordsMatched: 0 },
                { text: 'T√¥i kh√¥ng hi·ªÉu, b·∫°n c√≥ th·ªÉ gi·∫£i th√≠ch kh√¥ng?', wordsMatched: 0 },
                { text: 'R·∫•t vui ƒë∆∞·ª£c tr√≤ chuy·ªán v·ªõi b·∫°n', wordsMatched: 0 }
            );
        }
        
        return defaultSuggestions.slice(0, 3);
    }
    
    async function speakWithGoogleTTSProxy(text, langCode, gender = 'male') {
        if (isSpeaking) {
            stopAllSpeech();
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        const cacheKey = `${text}_${langCode}_${gender}`;
        
        if (audioCache.has(cacheKey)) {
            const audio = audioCache.get(cacheKey);
            currentSpeech = audio.cloneNode();
            
            return new Promise((resolve, reject) => {
                currentSpeech.onended = () => {
                    setIsSpeaking(false);
                    stopAudioVisualizer();
                    updateUI();
                    log('TTS', 'K·∫øt th√∫c ph√°t √¢m thanh t·ª´ cache');
                    resolve();
                };
                
                currentSpeech.onerror = (err) => {
                    setIsSpeaking(false);
                    stopAudioVisualizer();
                    updateUI();
                    log('TTS', 'L·ªói khi ph√°t √¢m thanh t·ª´ cache');
                    reject(err);
                };
                
                setIsSpeaking(true);
                startAudioVisualizer();
                currentSpeech.play().then(resolve).catch(reject);
                
                log('TTS', `Ph√°t √¢m thanh t·ª´ cache: "${text.substring(0, 50)}..."`);
            });
        }
        
        try {
            const googleLang = TTS_CONFIG.googleLangCodes[langCode] || langCode.split('-')[0];
            const encodedText = encodeURIComponent(text);
            
            const speed = TTS_CONFIG.languages[langCode]?.voices[gender]?.speed || 
                         (gender === 'male' ? 0.9 : 1.0);
            
            let ttsUrl = `${TTS_PROXY_SERVERS[0]}?ie=UTF-8&client=tw-ob&q=${encodedText}&tl=${googleLang}`;
            
            if (USE_CORS_PROXY) {
                ttsUrl = CORS_PROXY + encodeURIComponent(ttsUrl);
            }
            
            const audio = new Audio();
            audio.crossOrigin = "anonymous";
            
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    if (isSpeaking) {
                        audio.pause();
                        setIsSpeaking(false);
                        stopAudioVisualizer();
                        log('TTS', 'Timeout khi t·∫£i TTS');
                        reject(new Error('TTS timeout'));
                    }
                }, 10000);
                
                audio.onloadeddata = () => {
                    clearTimeout(timeout);
                    
                    audioCache.set(cacheKey, audio.cloneNode());
                    
                    currentSpeech = audio;
                    setIsSpeaking(true);
                    startAudioVisualizer();
                    
                    audio.play().then(() => {
                        log('TTS', `B·∫Øt ƒë·∫ßu Google TTS: "${text.substring(0, 50)}..."`);
                        resolve();
                    }).catch(reject);
                };
                
                audio.onended = () => {
                    clearTimeout(timeout);
                    setIsSpeaking(false);
                    stopAudioVisualizer();
                    updateUI();
                    log('TTS', 'K·∫øt th√∫c Google TTS');
                    resolve();
                };
                
                audio.onerror = (err) => {
                    clearTimeout(timeout);
                    setIsSpeaking(false);
                    stopAudioVisualizer();
                    updateUI();
                    log('TTS', `L·ªói Google TTS: ${err}`);
                    reject(err);
                };
                
                audio.src = ttsUrl;
                audio.load();
            });
            
        } catch (error) {
            console.error('Google TTS Proxy error:', error);
            log('TTS', `Google TTS th·∫•t b·∫°i: ${error.message}`);
            
            if (window.speechSynthesis) {
                speakWithWebSpeech(text, langCode, gender);
            }
            throw error;
        }
    }
    
    function speakWithWebSpeech(text, langCode, gender = 'male') {
        if (isSpeaking) {
            stopAllSpeech();
            return;
        }
        
        if (!('speechSynthesis' in window)) {
            log('SPEECH', 'Speech synthesis kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ tr√™n tr√¨nh duy·ªát n√†y');
            return;
        }
        
        window.speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = langCode;
        utterance.rate = gender === 'male' ? 0.9 : 1.1;
        utterance.pitch = gender === 'male' ? 0.8 : 1.2;
        utterance.volume = 1;
        
        const voices = window.speechSynthesis.getVoices();
        const preferredVoice = voices.find(voice => 
            voice.lang.startsWith(langCode.split('-')[0]) &&
            ((gender === 'male' && voice.name.toLowerCase().includes('male')) ||
             (gender === 'female' && voice.name.toLowerCase().includes('female')))
        );
        
        if (preferredVoice) {
            utterance.voice = preferredVoice;
            log('SPEECH', `S·ª≠ d·ª•ng gi·ªçng: ${preferredVoice.name}`);
        }
        
        utterance.onstart = function() {
            setIsSpeaking(true);
            updateUI();
            startAudioVisualizer();
            log('SPEECH', `B·∫Øt ƒë·∫ßu Web Speech: "${text.substring(0, 50)}..."`);
        };
        
        utterance.onend = function() {
            setIsSpeaking(false);
            currentSpeech = null;
            stopAudioVisualizer();
            updateUI();
            log('SPEECH', 'K·∫øt th√∫c Web Speech');
        };
        
        utterance.onerror = function(event) {
            setIsSpeaking(false);
            currentSpeech = null;
            stopAudioVisualizer();
            updateUI();
            log('SPEECH', `L·ªói Web Speech: ${event.error}`);
        };
        
        currentSpeech = utterance;
        window.speechSynthesis.speak(utterance);
    }
    
    async function speakText(text, langCode, gender = 'male') {
        if (isSpeaking) {
            stopAllSpeech();
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        if (useGoogleTTS) {
            try {
                await speakWithGoogleTTSProxy(text, langCode, gender);
            } catch (error) {
                console.error('Google TTS Proxy failed:', error);
                log('TTS', `Google TTS th·∫•t b·∫°i, chuy·ªÉn sang Web Speech: ${error.message}`);
                
                if (window.speechSynthesis) {
                    speakWithWebSpeech(text, langCode, gender);
                }
            }
        } else {
            speakWithWebSpeech(text, langCode, gender);
        }
    }
    
    function setIsSpeaking(speaking) {
        isSpeaking = speaking;
        updateUI();
    }
    
    function startAudioVisualizer() {
        stopAudioVisualizer();
        
        const visualizer = document.getElementById('audioVisualizer');
        visualizer.innerHTML = '';
        
        for (let i = 0; i < 20; i++) {
            const bar = document.createElement('div');
            bar.className = 'audio-bar';
            bar.style.height = '5px';
            visualizer.appendChild(bar);
        }
        
        const bars = visualizer.querySelectorAll('.audio-bar');
        audioVisualizerInterval = setInterval(() => {
            bars.forEach(bar => {
                const height = 5 + Math.random() * 35;
                bar.style.height = `${height}px`;
                
                const hue = 200 + Math.random() * 160;
                bar.style.backgroundColor = `hsl(${hue}, 70%, 50%)`;
            });
        }, 100);
    }
    
    function stopAudioVisualizer() {
        if (audioVisualizerInterval) {
            clearInterval(audioVisualizerInterval);
            audioVisualizerInterval = null;
        }
        
        const visualizer = document.getElementById('audioVisualizer');
        if (visualizer) {
            visualizer.innerHTML = '';
            
            for (let i = 0; i < 20; i++) {
                const bar = document.createElement('div');
                bar.className = 'audio-bar';
                bar.style.height = '5px';
                bar.style.backgroundColor = '#e0e0e0';
                visualizer.appendChild(bar);
            }
        }
    }
    
    function updateUI() {
        updateWordDisplays();
        updateSentenceDisplay();
        
        const speakVnBtn = document.getElementById('speakVnBtn');
        const speakTransBtn = document.getElementById('speakTransBtn');
        const stopSpeechBtn = document.getElementById('stopSpeechBtn');
        
        speakVnBtn.disabled = !convertedFullSentence || isSpeaking;
        speakTransBtn.disabled = !document.getElementById('translationOutput').textContent || 
            document.getElementById('translationOutput').textContent.includes('ƒêang ch·ªù d·ªãch') ||
            isSpeaking;
        stopSpeechBtn.disabled = !isSpeaking;
        
        if (isSpeaking) {
            speakVnBtn.classList.add('speaking');
            speakVnBtn.innerHTML = 'üîä ƒêang ƒë·ªçc...';
        } else {
            speakVnBtn.classList.remove('speaking');
            speakVnBtn.innerHTML = 'üîä ƒê·ªçc Ti·∫øng Vi·ªát';
        }
        
        const langName = TTS_CONFIG.langDisplayNames[currentVoice.lang] || currentVoice.lang;
        const genderName = currentVoice.gender === 'male' ? 'Nam' : 'N·ªØ';
        const ttsMode = useGoogleTTS ? 'Google TTS' : 'Web Speech';
        
        document.getElementById('currentVoiceDisplay').textContent = 
            `Hi·ªán t·∫°i: ${langName} - ${genderName} (${ttsMode})`;
        
        document.getElementById('useGoogleTTS').classList.toggle('active', useGoogleTTS);
        document.getElementById('useWebSpeech').classList.toggle('active', !useGoogleTTS);
    }

    // === KH·ªûI T·∫†O ===
    document.addEventListener('DOMContentLoaded', function() {
        log('SYSTEM', '·ª®ng d·ª•ng ƒë√£ kh·ªüi ƒë·ªông v·ªõi ƒê·ªìng b·ªô Firebase');
        
        // Kh·ªüi t·∫°o FPS counter
        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastFrameTime >= 1000) {
                currentFPS = frameCount;
                frameCount = 0;
                lastFrameTime = currentTime;
                
                document.getElementById('fps').textContent = currentFPS;
                
                if (currentFPS < 30 && pollingInterval > 150) {
                    pollingInterval = Math.min(pollingInterval * 1.5, 1000);
                    updatePollingDisplay();
                    log('PERF', `FPS th·∫•p (${currentFPS}), tƒÉng polling interval l√™n ${pollingInterval}ms`);
                } else if (currentFPS > 50 && pollingInterval < 1000) {
                    pollingInterval = Math.max(pollingInterval * 0.8, 150);
                    updatePollingDisplay();
                }
            }
            requestAnimationFrame(updateFPS);
        }
        
        requestAnimationFrame(updateFPS);
        
        // T·∫£i hi·ªáu chu·∫©n t·ª´ localStorage
        loadCalibration();
        
        // T·∫£i ƒë·ªÅ xu·∫•t c·ª•m t·ª´
        loadPhraseSuggestions();
        
        // Kh·ªüi t·∫°o Web Speech API
        if ('speechSynthesis' in window) {
            speechSynthesis.getVoices();
            
            speechSynthesis.onvoiceschanged = function() {
                const voices = speechSynthesis.getVoices();
                log('SPEECH', `ƒê√£ t·∫£i ${voices.length} gi·ªçng t·ªïng h·ª£p`);
            };
        }
        
        // Kh·ªüi t·∫°o ƒë·ªìng b·ªô Firebase
        initializeFirebaseSync();
        
        // Kh·ªüi t·∫°o auto-refresh
        setTimeout(() => {
            fetchFirebaseDataOptimized();
            toggleAutoRefresh();
        }, 100);
        
        // Clear audio cache periodically
        setInterval(() => {
            if (audioCache.size > 20) {
                const keys = Array.from(audioCache.keys());
                for (let i = 0; i < 5; i++) {
                    audioCache.delete(keys[i]);
                }
                log('CACHE', `ƒê√£ x√≥a 5 item t·ª´ audio cache, c√≤n ${audioCache.size} item`);
            }
        }, 60000);
        
        // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë·ªìng b·ªô ƒë·ªãnh k·ª≥
        setInterval(updateSyncStatus, 5000);
    });
</script>
</body>
</html>
