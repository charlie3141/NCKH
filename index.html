#include <Wire.h>
#include <MPU6050.h>
#include <SoftwareSerial.h>

MPU6050 mpu;
const uint8_t HC05_RX_PIN = 7;
const uint8_t HC05_TX_PIN = 6;
const long HC05_BAUD = 9600;
SoftwareSerial bt(HC05_TX_PIN, HC05_RX_PIN);

const int FLEX2_PIN = A0;
const int FLEX1_PIN = A1;
const int FLEX0_PIN = A2;
const int FLEX3_PIN = A3;

const int FLEX0_STRAIGHT_MAX = 150, FLEX0_BENT_MAX = 300;
const int FLEX1_STRAIGHT_MAX = 150, FLEX1_BENT_MAX = 450;
const int FLEX2_STRAIGHT_MAX = 150, FLEX2_BENT_MAX = 350;
const int FLEX3_STRAIGHT_MAX = 150, FLEX3_BENT_MAX = 300;

const uint8_t FLEX_SAMPLES = 6;
const uint8_t ACC_SAMPLES = 4;
uint8_t acc_idx = 0;
int16_t ax_buf[ACC_SAMPLES], ay_buf[ACC_SAMPLES], az_buf[ACC_SAMPLES];

const uint8_t DEBOUNCE_COUNT = 3;
uint8_t stableCount = 0;
int lastDetectedIndex = -1;
int lastF0 = -1, lastF1 = -1, lastF2 = -1, lastF3idx = -1;

unsigned long holdStartMs = 0;
bool holdFired = false;
const unsigned long HOLD_MS_DEFAULT = 800UL;
const unsigned long POST_HOLD_COOLDOWN = 600UL;
unsigned long lastActionMs = 0;

char slot1[64];
char slot2[64];
unsigned long lastSendMs = 0;
const unsigned long SEND_INTERVAL = 200UL;


const char* tableC[3][3][3] = {
  { {"B","C","D"},{"ƒê","G","H"},{"K","L","M"} },
  { {"N","P","Q"},{"R","S","T"},{"V","X","CH"} },
  { {"GH","KH","NG"},{"NGH","NH","PH"},{"TH","TR","_"} }
}};

const char* tableA[8][9] = {
  {"A","AC","ACH","AI","AM","AN","ANG","ANH","AO"},
  {"AP","AT","AU","AY","E","EC","ECH","EM","EN"},
  {"ENG","ENH","EO","EP","ET","EU","I","IA","IAC"},
  {"IAI","IAM","IAN","IANG","IANH","IAO","IAP","IAT","IAU"},
  {"IAY","IC","ICH","IE","IEC","IEM","IEN","IENG","IEO"},
  {"IEP","IET","IEU","IM","IN","ING","INH","IO","IOI"},
  {"ION","IONG","IOT","IP","IT","IU","IUA","IUC","IUI"},
  {"IUN","IUONG","IUP","O","OA","OAC","OACH","OAI","OAM"}
};

const char* tableB[8][9] = {
  {"COMMIT","nullptr","nullptr","nullptr","OAN","OANG","OANH","OAP","OAT"},
  {"OAY","OC","OE","OEN","OEO","OET","OI","OM","ON"},
  {"ONG","OOC","OONG","OP","OT","U","UA","UAC","UACH"},
  {"UAI","UAM","UAN","UANG","UANH","UAO","UAT","UAY","UC"},
  {"UE","UECH","UEN","UENH","UEO","UET","UI","UM","UN"},
  {"UNG","UO","UOC","UOI","UOM","UON","UONG","UOP","OUT"},
  {"UOU","UP","UT","UU","UY","UYA","UYCH","UYEN","UYET"},
  {"UYNH","UYP","UYT","UYU","Y","YEM","YEN","YET","YEU"}
};

int readFlexAverage(int pin) {
  long sum = 0;
  for (uint8_t i=0;i<FLEX_SAMPLES;i++){ sum += analogRead(pin); }
  return sum / FLEX_SAMPLES;
}

int flexToIndex(int raw, int straightMax, int bentMax) {
  if (raw <= straightMax) return 0;
  else if (raw <= bentMax) return 1;
  else return 2;
}

int detectMPUState(){
  long sax=0,say=0,saz=0;
  for(uint8_t i=0;i<2;i++){
    int16_t rx,ry,rz;
    mpu.getAcceleration(&rx,&ry,&rz);
    sax+=rx; say+=ry; saz+=rz;
  }
  ax_buf[acc_idx]=sax/2; ay_buf[acc_idx]=say/2; az_buf[acc_idx]=saz/2;
  acc_idx=(acc_idx+1)%ACC_SAMPLES;
  long ax=0,ay=0,az=0;
  for(uint8_t i=0;i<ACC_SAMPLES;i++){ ax+=ax_buf[i]; ay+=ay_buf[i]; az+=az_buf[i]; }
  ax/=ACC_SAMPLES; ay/=ACC_SAMPLES; az/=ACC_SAMPLES;
  float axg=ax/16384.0, ayg=ay/16384.0, azg=az/16384.0;
  float absx=fabs(axg), absy=fabs(ayg), absz=fabs(azg);
  int state;
  if(absx>absy && absx>absz) state=(axg>=0)?0:1;
  else if(absy>absx && absy>absz) state=(ayg>=0)?2:3;
  else state=(azg>=0)?4:5;
  if(fmax(fmax(absx,absy),absz)<0.6) state=(azg>=0)?6:7;
  return state;
}

const char* getMappingForIndices(int mpuState,int a0,int a1,int a2,int a3){
  if(a3==2){ if(a0<3 && a1<3 && a2<3) return tableC[a0][a1][a2]; return nullptr; }
  int a3bin=(a3==1)?1:0;
  if(mpuState<0||mpuState>=8||a1<0||a1>=3||a2<0||a2>=3) return nullptr;
  int flatIndex=a1*3+a2;
  return (a3bin==0)? tableA[mpuState][flatIndex] : tableB[mpuState][flatIndex];
}

bool performActionSlotLogic(int mpu,int a0,int a1,int a2,int a3){
  const char* s = getMappingForIndices(mpu,a0,a1,a2,a3);
  if(!s) return false;
  
  if(strcmp(s,"<")==0){ if(strlen(slot2)>0) slot2[strlen(slot2)-1]=0; return true; }
  if(strcmp(s,"_")==0 || strcmp(s,"COMMIT")==0){ slot1[0]=0; slot2[0]=0; return true; }
  
  bool isSlot1 = (a3==2);
  
  if(isSlot1){
    strncpy(slot1, s, sizeof(slot1)-1);
    slot1[sizeof(slot1)-1]=0;
  } else {
    strncpy(slot2, s, sizeof(slot2)-1);
    slot2[sizeof(slot2)-1]=0;
  }
  
  return true;
}

uint8_t calcChecksum(const char* data) {
  uint8_t csum = 0;
  for(int i=0; data[i]!=0; i++) csum ^= data[i];
  return csum;
}

void sendPacket(const char* slot1_val, const char* slot2_val) {
  char packet[150];
  snprintf(packet, sizeof(packet), "$%s,%s", slot1_val, slot2_val);
  uint8_t csum = calcChecksum(packet);
  char fullPacket[160];
  snprintf(fullPacket, sizeof(fullPacket), "%s*%02X", packet, csum);
  bt.println(fullPacket);
  Serial.print(F("SEND: "));
  Serial.println(fullPacket);
}

void setup(){
  pinMode(LED_BUILTIN, OUTPUT);
  Serial.begin(115200);
  delay(80);
  Serial.println(F("=== HC-05 WORDS ONLY ==="));
  Wire.begin();
  delay(50);
  mpu.initialize();
  Serial.print(F("MPU: "));
  Serial.println(mpu.testConnection()?F("OK"):F("FAIL"));
  bt.begin(HC05_BAUD);
  Serial.println(F("HC-05 ready @9600"));
  for(uint8_t i=0;i<ACC_SAMPLES;i++) ax_buf[i]=ay_buf[i]=az_buf[i]=0;
  slot1[0]=0; slot2[0]=0;
  lastSendMs = millis();
}

void loop(){
  unsigned long now = millis();
  
  int rawF0 = readFlexAverage(FLEX0_PIN);
  int rawF1 = readFlexAverage(FLEX1_PIN);
  int rawF2 = readFlexAverage(FLEX2_PIN);
  int rawF3 = readFlexAverage(FLEX3_PIN);
  
  int idxF0 = flexToIndex(rawF0, FLEX0_STRAIGHT_MAX, FLEX0_BENT_MAX);
  int idxF1 = flexToIndex(rawF1, FLEX1_STRAIGHT_MAX, FLEX1_BENT_MAX);
  int idxF2 = flexToIndex(rawF2, FLEX2_STRAIGHT_MAX, FLEX2_BENT_MAX);
  int idxF3 = flexToIndex(rawF3, FLEX3_STRAIGHT_MAX, FLEX3_BENT_MAX);
  
  int mpuState = detectMPUState();
  
  if(mpuState==lastDetectedIndex && idxF0==lastF0 && idxF1==lastF1 && idxF2==lastF2 && idxF3==lastF3idx)
    stableCount++;
  else{
    stableCount=1;
    lastDetectedIndex=mpuState;
    lastF0=idxF0; lastF1=idxF1; lastF2=idxF2; lastF3idx=idxF3;
    holdStartMs=millis(); holdFired=false;
  }
  
  if(stableCount>=DEBOUNCE_COUNT){
    unsigned long held = millis()-holdStartMs;
    if(!holdFired && millis()-lastActionMs>POST_HOLD_COOLDOWN && held>=HOLD_MS_DEFAULT){
      if(performActionSlotLogic(mpuState, idxF0, idxF1, idxF2, idxF3)){
        holdFired=true;
        lastActionMs=millis();
      }
    }
  }
  
  if(now - lastSendMs >= SEND_INTERVAL){
    lastSendMs = now;
    sendPacket(slot1, slot2);
  }
  
  while (bt.available()) {
    Serial.write(bt.read());
  }
}
