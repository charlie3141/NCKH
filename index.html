<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ứng dụng và cải tiến "Công nghệ dịch thủ ngữ" (FAST VERSION)</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-database-compat.js"></script>
    <style>
        /* CSS tối ưu hiệu suất - Giữ nguyên phần CSS gốc nhưng thêm phần tối ưu hóa */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        /* Tối ưu hiệu suất rendering */
        .container, .card, .conversion-display, .sentence-display, .current-word-display {
            will-change: transform, opacity;
            backface-visibility: hidden;
            transform: translateZ(0);
        }

        /* Tắt animation khi không cần thiết */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            
            .indicator.online {
                animation: none;
            }
            
            .shake-active {
                animation: none;
            }
        }

        /* Giữ nguyên tất cả CSS gốc... */
        /* (CSS gốc vẫn giữ nguyên từ trên) */
        /* ... */

        /* Thêm CSS cho hiệu suất */
        .card {
            contain: content;
        }

        .sensor-value, .conversion-display, .sentence-display {
            contain: layout style paint;
        }
        
        /* Giữ nguyên toàn bộ CSS gốc */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            padding: 20px;
            text-align: center;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .dashboard {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        /* ... TẤT CẢ CSS GỐC VẪN GIỮ NGUYÊN ... */
        
        /* Thêm style cho performance monitor (tùy chọn) */
        .performance-monitor {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: #0f0;
            padding: 5px 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
            z-index: 1000;
            display: none;
        }
        
        .performance-monitor.visible {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Performance Monitor -->
    <div class="performance-monitor" id="perfMonitor">
        <div>FPS: <span id="fpsCounter">0</span></div>
        <div>Latency: <span id="latencyCounter">0</span>ms</div>
        <div>Updates: <span id="updateCounter">0</span></div>
    </div>

    <div class="container">
        <header>
            <h1>Ứng dụng và cải tiến "Công nghệ dịch thủ ngữ" - TỐI ƯU HIỆU SUẤT</h1>
            <div>Giám sát thời gian thực từ Firebase Realtime</div>
            <div class="firebase-status" id="firebaseStatus">
                Đang kết nối với Firebase Realtime...
            </div>
        </header>

        <!-- Dashboard giữ nguyên -->
        <!-- ... Nội dung dashboard vẫn giữ nguyên như file gốc ... -->
    </div>

    <script>
        // ===========================================
        // CẤU HÌNH FIREBASE REALTIME
        // ===========================================
        const firebaseConfig = {
            apiKey: "AIzaSyDbPmge2DxS8-_Wgh6XH2LbUZ5nzq79Kkw",
            authDomain: "gangtay-f1efe.firebaseapp.com",
            databaseURL: "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "gangtay-f1efe",
            storageBucket: "gangtay-f1efe.firebasestorage.app",
            messagingSenderId: "144511241430",
            appId: "1:144511241430:web:218bd0e794b23707381a6e"
        };

        // Khởi tạo Firebase
        let firebaseApp;
        let database;
        let dataRef;
        
        try {
            firebaseApp = firebase.initializeApp(firebaseConfig);
            database = firebase.database();
            dataRef = database.ref('sensorData');
            
            console.log("Firebase initialized successfully");
        } catch (error) {
            console.error("Firebase initialization error:", error);
            // Fallback to REST API
            initRestFallback();
        }

        // ===========================================
        // BIẾN TOÀN CỤC TỐI ƯU
        // ===========================================
        let firebaseData = null;
        let lastUpdateTime = 0;
        
        // Biến tối ưu hiệu suất
        let updateTimeout = null;
        let lastSensorData = null;
        let isFetching = false;
        let frameCount = 0;
        let lastFrameTime = performance.now();
        let fps = 0;
        let domCache = {};
        let updateQueue = [];
        let isProcessingQueue = false;
        
        // Biến xây dựng câu (giữ nguyên)
        let slot1 = "";
        let slot2 = "";
        let displayBuffer = "";
        let convertedCurrentWord = "";
        let sentenceWords = [];
        let fullSentence = "";
        let convertedFullSentence = "";
        
        // Trạng thái cảm biến uốn
        let flexStates = [0, 0, 0, 0];
        let lastFlexStates = [-1, -1, -1, -1];
        let stableCount = 0;
        let lastDetectedIndex = -1;
        let holdStartMs = 0;
        let holdFired = false;
        const DEBOUNCE_COUNT = 2; // Giảm từ 3 xuống 2 để nhanh hơn
        const HOLD_MS_DEFAULT = 500; // Giảm từ 800 xuống 500
        const POST_HOLD_COOLDOWN = 300; // Giảm từ 600 xuống 300
        let lastActionMs = 0;
        
        // Bảng từ và chuyển đổi (giữ nguyên)
        // ... (các bảng tableA, tableB, tableC, vietnameseTable vẫn giữ nguyên)
        
        // ===========================================
        // HÀM TỐI ƯU HIỆU SUẤT
        // ===========================================
        
        // 1. Hàm cập nhật DOM hiệu quả
        function updateElement(id, content, className = '') {
            const element = document.getElementById(id);
            if (!element) return;
            
            // Kiểm tra cache để tránh cập nhật không cần thiết
            const cacheKey = id;
            if (domCache[cacheKey] && 
                domCache[cacheKey].content === content && 
                domCache[cacheKey].className === className) {
                return;
            }
            
            // Batch DOM updates
            if (element.textContent !== content) {
                element.textContent = content;
            }
            
            if (className && element.className !== className) {
                element.className = className;
            }
            
            // Lưu vào cache
            domCache[cacheKey] = { content, className };
        }
        
        // 2. Queue system cho batch updates
        function queueUpdate(type, data) {
            updateQueue.push({ type, data });
            
            if (!isProcessingQueue) {
                processUpdateQueue();
            }
        }
        
        function processUpdateQueue() {
            if (updateQueue.length === 0) {
                isProcessingQueue = false;
                return;
            }
            
            isProcessingQueue = true;
            
            // Process batch trong một animation frame
            requestAnimationFrame(() => {
                const batchSize = Math.min(10, updateQueue.length);
                const batch = updateQueue.splice(0, batchSize);
                
                batch.forEach(update => {
                    switch(update.type) {
                        case 'MPU':
                            updateMPUDisplay(update.data);
                            break;
                        case 'FLEX':
                            updateFlexDisplay(update.data);
                            break;
                        case 'TIME':
                            updateTimeDisplay();
                            break;
                        case 'WORD':
                            updateWordConstruction(update.data);
                            break;
                    }
                });
                
                // Tiếp tục xử lý queue nếu còn
                if (updateQueue.length > 0) {
                    setTimeout(processUpdateQueue, 0);
                } else {
                    isProcessingQueue = false;
                }
            });
        }
        
        // 3. Debounced update với requestAnimationFrame
        function debouncedUpdate(data) {
            if (updateTimeout) {
                cancelAnimationFrame(updateTimeout);
            }
            
            updateTimeout = requestAnimationFrame(() => {
                performFastUpdate(data);
            });
        }
        
        function performFastUpdate(data) {
            if (!data) return;
            
            // So sánh dữ liệu để tránh cập nhật không cần thiết
            const dataStr = JSON.stringify(data);
            if (lastSensorData === dataStr) return;
            lastSensorData = dataStr;
            
            firebaseData = data;
            lastUpdateTime = Date.now();
            
            // Queue các updates
            queueUpdate('MPU', data);
            queueUpdate('FLEX', data);
            queueUpdate('TIME', null);
            queueUpdate('WORD', data);
            
            // Hiệu suất monitoring
            frameCount++;
            const now = performance.now();
            if (now >= lastFrameTime + 1000) {
                fps = Math.round((frameCount * 1000) / (now - lastFrameTime));
                frameCount = 0;
                lastFrameTime = now;
                
                updateElement('fpsCounter', fps);
                updateElement('updateCounter', updateQueue.length);
            }
        }
        
        // 4. Các hàm update riêng biệt
        function updateMPUDisplay(data) {
            updateElement('mpuOrientation', data.o || 'Không xác định');
            updateElement('mpuShakeState', data.d || 'Không');
            updateElement('isShaking', data.sf || 'KHÔNG');
            
            // Animation shake hiệu quả hơn
            const isShakingElement = document.getElementById('isShaking');
            if (data.sf === "YES") {
                isShakingElement.classList.add('shake-active');
            } else {
                isShakingElement.classList.remove('shake-active');
            }
        }
        
        function updateFlexDisplay(data) {
            const flexValues = [data.f0 || 0, data.f1 || 0, data.f2 || 0, data.f3 || 0];
            let needsUpdate = false;
            
            // Tính toán trạng thái uốn
            for (let i = 0; i < 4; i++) {
                const newState = calculateFlexState(flexValues[i], i);
                if (flexStates[i] !== newState) {
                    flexStates[i] = newState;
                    needsUpdate = true;
                }
            }
            
            if (needsUpdate) {
                for (let i = 0; i < 4; i++) {
                    const box = document.getElementById(`flex${i}-box`);
                    const boxCacheKey = `flex${i}-box`;
                    
                    if (domCache[boxCacheKey]?.content != flexStates[i]) {
                        box.textContent = flexStates[i];
                        box.className = `flex-box active-${flexStates[i]}`;
                        domCache[boxCacheKey] = { content: flexStates[i], className: box.className };
                    }
                }
                
                updateElement('rawValues', flexValues.join(', '));
                updateElement('flexFormat', flexStates.join(''));
            }
        }
        
        function updateTimeDisplay() {
            const now = Date.now();
            const timeStr = formatTime(now);
            const latency = now - lastUpdateTime;
            
            updateElement('lastUpdate', `Cập nhật: ${timeStr} (${latency}ms)`);
            updateElement('lastUpdateTime', timeStr);
            updateElement('latencyCounter', latency);
        }
        
        function updateWordConstruction(data) {
            const mpuState = getMPUState(data.o || "Không xác định", data.d || "Không");
            const a0 = flexStates[0];
            const a1 = flexStates[1];
            const a2 = flexStates[2];
            const a3 = flexStates[3];
            
            // Tối ưu stable count
            if (mpuState === lastDetectedIndex && 
                a0 === lastFlexStates[0] && 
                a1 === lastFlexStates[1] && 
                a2 === lastFlexStates[2] && 
                a3 === lastFlexStates[3]) {
                stableCount++;
            } else {
                stableCount = 1;
                lastDetectedIndex = mpuState;
                lastFlexStates = [...flexStates];
                holdStartMs = performance.now();
                holdFired = false;
            }
            
            // Kiểm tra hành động với timing chính xác hơn
            if (stableCount >= DEBOUNCE_COUNT) {
                const held = performance.now() - holdStartMs;
                if (!holdFired && (performance.now() - lastActionMs) > POST_HOLD_COOLDOWN && held >= HOLD_MS_DEFAULT) {
                    performActionSlotLogic(mpuState, a0, a1, a2, a3);
                    holdFired = true;
                    lastActionMs = performance.now();
                }
            }
        }
        
        // 5. Hàm tính toán flex state tối ưu
        function calculateFlexState(rawValue, sensorIndex) {
            // Tối ưu: Sử dụng lookup table thay vì if-else
            const thresholds = [
                { straight: 100, bent: 300 },    // sensor 0
                { straight: 150, bent: 450 },    // sensor 1
                { straight: 150, bent: 350 },    // sensor 2
                { straight: 100, bent: 300 }     // sensor 3
            ];
            
            const threshold = thresholds[sensorIndex];
            
            if (rawValue <= threshold.straight) return 0;
            if (rawValue <= threshold.bent) return 1;
            return 2;
        }
        
        // 6. Kết nối Firebase Realtime với timeout
        function initFirebaseRealtime() {
            if (!dataRef) {
                initRestFallback();
                return;
            }
            
            // Thiết lập listener với timeout
            const connectionTimeout = setTimeout(() => {
                log('SYSTEM', 'Firebase realtime timeout, switching to REST');
                initRestFallback();
            }, 5000);
            
            dataRef.on('value', (snapshot) => {
                clearTimeout(connectionTimeout);
                
                const data = snapshot.val();
                if (data) {
                    debouncedUpdate(data);
                    updateConnectionStatus(true);
                }
            }, (error) => {
                clearTimeout(connectionTimeout);
                console.error('Firebase error:', error);
                updateConnectionStatus(false);
                initRestFallback();
            });
            
            // Keep-alive ping mỗi 30 giây
            setInterval(() => {
                if (dataRef) {
                    dataRef.once('value').catch(() => {
                        updateConnectionStatus(false);
                    });
                }
            }, 30000);
        }
        
        // 7. Fallback REST API tối ưu
        function initRestFallback() {
            const FIREBASE_URL = "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/sensorData.json";
            
            // Fast polling với exponential backoff
            let pollInterval = 100;
            let retryCount = 0;
            
            async function fastPoll() {
                if (isFetching) return;
                
                try {
                    isFetching = true;
                    const startTime = performance.now();
                    
                    // Sử dụng fetch với AbortController và cache busting
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 1000);
                    
                    const response = await fetch(`${FIREBASE_URL}?t=${Date.now()}`, {
                        signal: controller.signal,
                        cache: 'no-store',
                        headers: {
                            'Pragma': 'no-cache',
                            'Cache-Control': 'no-cache, no-store, must-revalidate'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const data = await response.json();
                    const latency = Math.round(performance.now() - startTime);
                    
                    // Adaptive polling dựa trên latency
                    if (latency < 50) pollInterval = 50;
                    else if (latency < 100) pollInterval = 100;
                    else if (latency < 200) pollInterval = 200;
                    else pollInterval = 300;
                    
                    retryCount = 0;
                    updateConnectionStatus(true);
                    debouncedUpdate(data);
                    
                    isFetching = false;
                    
                    // Lập lịch poll tiếp theo
                    setTimeout(fastPoll, pollInterval);
                    
                } catch (error) {
                    isFetching = false;
                    retryCount++;
                    
                    // Exponential backoff
                    const backoff = Math.min(1000 * Math.pow(2, retryCount), 10000);
                    
                    updateConnectionStatus(false);
                    log('SYSTEM', `REST fallback error (retry ${retryCount}): ${error.message}`);
                    
                    setTimeout(fastPoll, backoff);
                }
            }
            
            // Bắt đầu polling
            fastPoll();
            
            log('SYSTEM', 'Đã kích hoạt REST fallback với adaptive polling');
        }
        
        // ===========================================
        // HÀM TRỢ GIÚP (tối ưu)
        // ===========================================
        function log(source, message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = { timestamp, source, message };
            
            // Hiển thị log ngay lập tức
            const logContainer = document.getElementById('logContainer');
            if (logContainer) {
                // Chỉ giữ 10 log entries
                const currentLogs = logContainer.innerHTML;
                const logs = currentLogs.split('</div>').filter(l => l.trim());
                if (logs.length >= 10) {
                    logs.shift();
                }
                
                const newLog = `<div class="log-entry">
                    <span style="color: #666; font-size: 0.8rem;">[${timestamp}] ${source}:</span>
                    <span style="color: #333;"> ${message}</span>
                </div>`;
                
                logContainer.innerHTML = [...logs, newLog].join('</div>') + '</div>';
                logContainer.scrollTop = logContainer.scrollHeight;
            }
        }
        
        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            
            if (connected) {
                indicator.className = 'indicator online';
                statusText.textContent = 'Đã kết nối với Firebase';
                statusText.style.color = '#4CAF50';
            } else {
                indicator.className = 'indicator';
                statusText.textContent = 'Mất kết nối - Đang thử lại...';
                statusText.style.color = '#FF5722';
            }
        }
        
        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }
        
        // ===========================================
        // HÀM CHUYỂN ĐỔI TIẾNG VIỆT (tối ưu)
        // ===========================================
        // Tạo lookup table cho chuyển đổi nhanh
        const vietnameseLookup = {};
        
        function initVietnameseLookup() {
            vietnameseTable.forEach(item => {
                vietnameseLookup[item.key] = item.forms;
            });
        }
        
        function convertVietnameseWord(encodedWord) {
            if (!encodedWord || encodedWord.length === 0) return "";
            
            // Tối ưu: Sử dụng regex để tìm nhanh hơn
            const match = encodedWord.match(/^([^_]*)_([^_]*)_([^_]*)$/);
            if (!match) return encodedWord;
            
            const [, consonant, middle, vowelTypeStr] = match;
            if (middle.length < 2) return encodedWord;
            
            const toneChar = middle[0];
            if (toneChar < '1' || toneChar > '6') return encodedWord;
            
            const tone = parseInt(toneChar);
            const vowelKey = middle.substring(1).toUpperCase();
            
            let vowelType = 0;
            if (vowelTypeStr === "b") {
                vowelType = 1;
            } else if (vowelTypeStr === "p") {
                vowelType = 2;
            } else if (vowelTypeStr !== "s") {
                return encodedWord;
            }
            
            const tableIndex = (tone - 1) + (vowelType * 6);
            if (tableIndex < 0 || tableIndex >= 18) return encodedWord;
            
            const vowelForms = vietnameseLookup[vowelKey];
            if (!vowelForms) return encodedWord;
            
            return consonant + vowelForms[tableIndex];
        }
        
        function convertVietnameseText(encodedText) {
            if (!encodedText || encodedText.length === 0) return "";
            
            // Tách từ và chuyển đổi song song
            const words = encodedText.split(' ');
            const results = [];
            
            for (let word of words) {
                results.push(convertVietnameseWord(word));
            }
            
            return results.join(' ');
        }
        
        // ===========================================
        // CÁC HÀM CÒN LẠI (giữ nguyên nhưng tối ưu)
        // ===========================================
        // ... (các hàm processWordConstruction, performActionSlotLogic, 
        // updateDisplayBufferFromSlots, addWordToSentence, commitSentence,
        // v.v. vẫn giữ nguyên nhưng sử dụng các hàm tối ưu mới)
        
        // ===========================================
        // KHỞI TẠO
        // ===========================================
        document.addEventListener('DOMContentLoaded', function() {
            log('SYSTEM', 'Ứng dụng đã khởi động (FAST MODE)');
            
            // Khởi tạo lookup table
            initVietnameseLookup();
            
            // Khởi tạo Firebase Realtime
            initFirebaseRealtime();
            
            // Hiển thị performance monitor (nhấn Ctrl+Shift+P để toggle)
            let perfVisible = false;
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && e.key === 'P') {
                    perfVisible = !perfVisible;
                    document.getElementById('perfMonitor').classList.toggle('visible', perfVisible);
                }
            });
            
            // Auto-clear log cũ
            setInterval(() => {
                const logContainer = document.getElementById('logContainer');
                if (logContainer) {
                    const logs = logContainer.innerHTML.split('</div>').filter(l => l.trim());
                    if (logs.length > 15) {
                        logContainer.innerHTML = logs.slice(-10).join('</div>') + '</div>';
                    }
                }
            }, 30000);
            
            log('SYSTEM', 'Hệ thống tối ưu hiệu suất đã sẵn sàng');
        });
        
        // ===========================================
        // CÁC HÀM KHÁC GIỮ NGUYÊN
        // ===========================================
        // ... (Các hàm: getMPUState, getMappingForIndices, flexModeCharFromA0,
        // updateUI, clearCurrentWord, backspace, resetSentence, loadPhraseSuggestions,
        // speakVietnameseSentence, translateSentence, refreshData, toggleAutoRefresh,
        // v.v. giữ nguyên nhưng có thể tối ưu thêm nếu cần)
        
    </script>
</body>
</html>
