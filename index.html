<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gangtay — Simple Poll + Play</title>
<style>
  body{font-family:system-ui,Arial;padding:16px;max-width:900px;margin:auto}
  label{display:block;margin-top:10px;font-weight:600}
  input, button {padding:8px; margin:6px 0; width:100%; box-sizing:border-box}
  .row{display:flex; gap:8px; flex-wrap:wrap}
  .half{flex:1 1 48%}
  #log{white-space:pre-wrap;background:#f6f6f6;padding:10px;border-radius:6px;font-family:monospace;max-height:320px;overflow:auto}
  .manual{background:#ff4757;color:white;border:none;padding:10px;border-radius:6px}
</style>
</head>
<body>
  <h2>Gangtay — Simple Poll + Play</h2>

  <label>T1.TXT (upload local) / or put T1.TXT at site root</label>
  <input id="fileInput" type="file" accept=".txt"/>

  <label>Audio base URL (folder containing 0001.mp3, 0002.mp3 ...)</label>
  <input id="audioBase" value="/audio/" />

  <label>Firebase message.json URL</label>
  <input id="firebaseUrl" value="https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json" />

  <div class="row">
    <button id="enableBtn" class="half">Enable audio & Start</button>
    <button id="stopBtn" class="half" disabled>Stop</button>
  </div>

  <div class="row">
    <button id="previewBtn" class="half">Preview 0001</button>
    <button id="manualPlay" class="half manual" style="display:none">Manual Play (tap once)</button>
  </div>

  <div style="margin-top:8px;">
    <label>Options</label>
    <div class="row">
      <div class="half"><label><input id="allowReplay" type="checkbox" checked> Allow duplicates</label></div>
      <div class="half"><label>Poll interval ms: <input id="pollMs" type="number" value="500" min="100" style="width:100%"></label></div>
    </div>
  </div>

  <div id="status">Status: idle</div>
  <div id="log"></div>

<script>
/* Simple, robust polling + playback
   - Press Enable once to start. Press Stop to stop.
   - Plays {"index":N} or {"text":"..."} mapped to T1.TXT
   - If audio element errors mid-file, tries single fetch+decode fallback and continues polling.
   - Auto-starts Firebase polling on page open; audio unlock still requires a user gesture per browser rules.
*/

const fileInput = document.getElementById('fileInput');
const audioBaseEl = document.getElementById('audioBase');
const firebaseUrlEl = document.getElementById('firebaseUrl');
const enableBtn = document.getElementById('enableBtn');
const stopBtn = document.getElementById('stopBtn');
const previewBtn = document.getElementById('previewBtn');
const manualBtn = document.getElementById('manualPlay');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
const allowReplayEl = document.getElementById('allowReplay');
const pollMsEl = document.getElementById('pollMs');

let lines = [];
let pollingActive = false;
let pollIntervalId = null;
let inFlight = false;
let audioCtx = null;
let masterGain = null;
let currentAudio = null;
let isPlaying = false;
let queue = [];
let enabling = false; // prevent re-entry of enable handler

// cooldown / duplicate suppression
const PLAY_COOLDOWN = 5000; // ms
const lastAttemptTimes = {}; // index -> timestamp
let lastPlayedIndex = null;
let lastPlayedTime = 0;

// helpers
function now(){ return new Date().toLocaleTimeString(); }
function log(s){ logEl.textContent = '['+now()+'] '+s + '\n' + logEl.textContent; }
function setStatus(s){ statusEl.textContent = 'Status: ' + s; log(s); }
function pad4(n){ return String(n).padStart(4,'0'); }

// read T1.TXT local uploader
fileInput.addEventListener('change', async (e) => {
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  setStatus('Reading ' + f.name);
  try {
    const txt = await f.text();
    lines = txt.split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
    setStatus('Loaded ' + lines.length + ' lines from ' + f.name);
  } catch(err) {
    setStatus('Read failed: ' + err.message);
  }
});

// audio context creation
function ensureAudioCtx(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 1.0;
  masterGain.connect(audioCtx.destination);
  log('AudioContext created');
}

// small compat wrapper for decodeAudioData
function decodeAudioDataCompat(ab){
  return new Promise((resolve,reject)=>{
    try{
      const p = audioCtx.decodeAudioData(ab);
      if (p && typeof p.then === 'function') {
        p.then(resolve).catch(err=>{
          try{ audioCtx.decodeAudioData(ab, resolve, reject); } catch(e){ reject(err||e); }
        });
        return;
      }
    }catch(e){}
    try{ audioCtx.decodeAudioData(ab, resolve, reject); } catch(e){ reject(e); }
  });
}

// fetch with timeout
async function fetchWithTimeout(url, timeout=4000){
  const ctrl = new AbortController();
  const id = setTimeout(()=>ctrl.abort(), timeout);
  try{
    const r = await fetch(url, { signal: ctrl.signal, cache: 'no-store' });
    clearTimeout(id);
    return r;
  }catch(e){ clearTimeout(id); throw e; }
}

// play using <audio> element first; onerror -> try fetch+decode once.
// does NOT stop polling if error occurs.
async function playFileByIndex(idx){
  if (idx <= 0) { log('Invalid index ' + idx); return; }
  const fname = pad4(idx) + '.mp3';
  let base = (audioBaseEl.value || '/audio/').trim();
  if (!base.endsWith('/')) base += '/';
  const url = (base.startsWith('http') ? base : location.origin + base) + fname + '?ts=' + Date.now();

  ensureAudioCtx();
  if (currentAudio) {
    try { currentAudio.pause(); currentAudio.src = ''; } catch(e){}
    currentAudio = null;
  }
  const a = new Audio(url);
  a.crossOrigin = 'anonymous';
  try {
    // try attach to audio context (works on many browsers)
    const src = audioCtx.createMediaElementSource(a);
    src.connect(masterGain);
    a._mediaSource = src;
  } catch(e){
    // ignore; element will play directly
  }

  setStatus('Play request: ' + fname);
  isPlaying = true;
  let played = false;

  a.onended = () => {
    isPlaying = false;
    lastPlayedIndex = idx;
    lastPlayedTime = Date.now();
    setStatus('Finished ' + fname);
    played = true;
    flushQueue();
  };
  a.onerror = async (ev) => {
    log('Audio element error ' + fname + ' — trying buffer fallback');
    // fallback: try fetch + decode once
    try{
      const r = await fetchWithTimeout(url, 4000);
      if (!r.ok) throw new Error('fetch status ' + r.status);
      const ab = await r.arrayBuffer();
      const buf = await decodeAudioDataCompat(ab);
      const srcBuf = audioCtx.createBufferSource();
      srcBuf.buffer = buf;
      srcBuf.connect(masterGain);
      srcBuf.onended = () => { isPlaying = false; lastPlayedIndex = idx; lastPlayedTime = Date.now(); setStatus('Finished via buffer ' + fname); flushQueue(); };
      srcBuf.start(0);
      played = true;
      setStatus('Playing via buffer: ' + fname);
    }catch(err){
      log('Fallback failed for ' + fname + ': ' + (err.message || err));
      // do not stop polling — just mark as not playing and continue
      isPlaying = false;
      flushQueue();
    }
  };

  // attempt play (may be blocked by autoplay)
  try {
    await a.play();
    setStatus('Element play started: ' + fname);
    currentAudio = a;
    lastPlayedIndex = idx;
    lastPlayedTime = Date.now();
    return;
  } catch(err) {
    log('Element play rejected (autoplay?) — trying fetch+decode fallback: ' + (err && err.message ? err.message : err));
    // try fallback path directly
    try{
      const r = await fetchWithTimeout(url, 4000);
      if (!r.ok) throw new Error('fetch status ' + r.status);
      ensureAudioCtx();
      const ab = await r.arrayBuffer();
      const buf = await decodeAudioDataCompat(ab);
      const srcBuf = audioCtx.createBufferSource();
      srcBuf.buffer = buf;
      srcBuf.connect(masterGain);
      srcBuf.onended = () => { isPlaying = false; lastPlayedIndex = idx; lastPlayedTime = Date.now(); setStatus('Finished via buffer ' + fname); flushQueue(); };
      srcBuf.start(0);
      setStatus('Playing via buffer: ' + fname);
      lastPlayedIndex = idx;
      lastPlayedTime = Date.now();
      return;
    }catch(e){
      log('Fallback decode failed: ' + (e && e.message ? e.message : e));
      isPlaying = false;
      flushQueue();
      // show manual play so user can tap once to unlock
      manualBtn.style.display = 'inline-block';
      manualBtn.focus();
      return;
    }
  }
}

// simple queue: if playing, queue; else play immediately
function queueOrPlayIndex(idx){
  if (isPlaying) {
    queue.push(idx);
    log('Queued index ' + idx + ' (queue len ' + queue.length + ')');
  } else {
    playFileByIndex(idx);
  }
}
function flushQueue(){
  if (queue.length > 0 && !isPlaying) {
    const next = queue.shift();
    playFileByIndex(next);
  }
}

// find index by exact match (case-insensitive)
function findIndexForText(text){
  if (!text) return -1;
  const k = text.trim().toLowerCase();
  for (let i=0;i<lines.length;i++){
    if ((lines[i]||'').toLowerCase() === k) return i+1;
  }
  return -1;
}

// single poll step
async function pollStep(){
  if (!pollingActive) return;
  if (inFlight) return; // avoid overlap
  const url = (firebaseUrlEl.value || '').trim();
  if (!url) { log('No Firebase URL set'); return; }
  inFlight = true;
  try {
    const r = await fetchWithTimeout(url, 4000);
    if (!r.ok) { log('Firebase fetch failed: ' + r.status); inFlight = false; return; }
    const j = await r.json();
    // Accept {index:N} or {text: "..."}. Play duplicates allowed by UI.
    if (j) {
      log('Firebase message: ' + JSON.stringify(j));
      const nowt = Date.now();
      if (typeof j.index === 'number') {
        const idx = j.index;
        // duplicate suppression and cooldown:
        if (!allowReplayEl.checked && lastPlayedIndex === idx) {
          log('Duplicate index ignored: ' + idx);
        } else if (lastAttemptTimes[idx] && (nowt - lastAttemptTimes[idx] < PLAY_COOLDOWN)) {
          log('Skipping rapid retry for index ' + idx);
        } else {
          lastAttemptTimes[idx] = nowt;
          queueOrPlayIndex(idx);
        }
      } else if (typeof j.text === 'string') {
        const idx = findIndexForText(j.text);
        if (idx > 0) {
          if (!allowReplayEl.checked && lastPlayedIndex === idx) {
            log('Duplicate text->index ignored: ' + idx);
          } else if (lastAttemptTimes[idx] && (nowt - lastAttemptTimes[idx] < PLAY_COOLDOWN)) {
            log('Skipping rapid retry for index ' + idx);
          } else {
            lastAttemptTimes[idx] = nowt;
            queueOrPlayIndex(idx);
          }
        } else {
          log('Text not found in T1.TXT: "' + j.text + '"');
        }
      } else {
        log('Unrecognized payload');
      }
    }
  } catch(err) {
    log('Poll error: ' + (err && err.name ? err.name : err));
  } finally {
    inFlight = false;
  }
}

// simple start/stop
function startPolling(){
  if (pollingActive) { log('Already polling'); return; }
  const ms = Math.max(100, Number(pollMsEl.value) || 500);
  pollingActive = true;
  pollIntervalId = setInterval(pollStep, ms);
  setStatus('Polling started every ' + ms + ' ms');
}
function stopPolling(){
  if (!pollingActive) { log('Polling not active'); return; }
  pollingActive = false;
  if (pollIntervalId) { clearInterval(pollIntervalId); pollIntervalId = null; }
  setStatus('Polling stopped');
}

// small preview on enable (plays 0001 once if present)
async function playPreviewOnce(){
  ensureAudioCtx();
  if (isPlaying) return;
  // try element play for 0001
  const base = (audioBaseEl.value || '/audio/').trim();
  const url = (base.endsWith('/') ? base : base + '/') + '0001.mp3?ts=' + Date.now();
  const a = new Audio(url);
  a.crossOrigin = 'anonymous';
  try { await a.play(); setStatus('Preview element started'); currentAudio = a; a.onended=()=>{ setStatus('Preview finished'); }; }
  catch(e){
    log('Preview element blocked -> tone unlock');
    await unlockTone();
  }
}

// play small tone to unlock
async function unlockTone(){
  ensureAudioCtx();
  const nowt = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine'; o.frequency.value = 880;
  g.gain.value = 0.0001;
  o.connect(g); g.connect(masterGain);
  g.gain.setValueAtTime(0.0001, nowt);
  g.gain.linearRampToValueAtTime(0.06, nowt + 0.01);
  o.start(nowt);
  g.gain.linearRampToValueAtTime(0.0001, nowt + 0.12);
  o.stop(nowt + 0.13);
  try{ await audioCtx.resume(); }catch(e){}
  await new Promise(r=>setTimeout(r, 180));
}

// Enable / Stop wiring
enableBtn.addEventListener('click', async () => {
  // guard: prevent re-entrancy and immediate re-click spam
  if (enabling) { log('Enable already in progress'); return; }
  enabling = true;
  enableBtn.disabled = true; // immediate disable to avoid multiple presses
  setStatus('Enable pressed — attempting unlock and start');

  // attempt unlock sequence (user gesture required on many browsers)
  const ok = await tryUnlockSequence();
  if (!ok) {
    setStatus('Audio locked — press Manual Play once');
    manualBtn.style.display='inline-block';
    manualBtn.focus();
  }

  // try small preview (may be blocked)
  await playPreviewOnce();

  // ensure polling is running
  if (!pollingActive) startPolling();

  stopBtn.disabled = false;
  enabling = false;
});

stopBtn.addEventListener('click', () => {
  stopPolling();
  enableBtn.disabled = false;
  stopBtn.disabled = true;
});

// Manual unlock button
manualBtn.addEventListener('click', async () => {
  const ok = await tryUnlockSequence();
  if (ok) { manualBtn.style.display='none'; setStatus('Unlocked'); }
  else setStatus('Manual unlock failed');
});

// other helpers
previewBtn.addEventListener('click', ()=>{ playPreviewOnce(); });
clearLog = ()=> logEl.textContent='';

// initial attempt to fetch /T1.TXT automatically AND auto-start polling
(async function init(){
  try {
    const r = await fetch('/T1.TXT', {cache:'no-store'});
    if (r.ok) {
      const t = await r.text();
      lines = t.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
      setStatus('Loaded T1.TXT ' + lines.length + ' lines');
    } else {
      setStatus('T1.TXT not found on site');
    }
  } catch(e){ setStatus('T1.TXT fetch failed'); }

  // start polling immediately on page open (Firebase reads will run).
  // NOTE: audio playback will remain subject to browser autoplay rules.
  startPolling();
})();

// decodeAudioDataCompat and tryUnlockSequence used above:
function decodeAudioDataCompat(ab){
  return new Promise((resolve,reject)=>{
    try{
      const p = audioCtx.decodeAudioData(ab);
      if (p && typeof p.then === 'function') { p.then(resolve).catch(err=>{ try{ audioCtx.decodeAudioData(ab, resolve, reject); }catch(e){ reject(err||e); }}); return; }
    }catch(e){}
    try{ audioCtx.decodeAudioData(ab, resolve, reject); } catch(e){ reject(e); }
  });
}
async function tryUnlockSequence(){
  if (!audioCtx) ensureAudioCtx();
  try {
    if (audioCtx.state === 'running') return true;
    // try a muted Audio element
    const a = new Audio();
    a.muted = true;
    try { await a.play(); } catch(e){}
    if (audioCtx.state === 'running') return true;
    // fallback to tone
    await unlockTone();
    return audioCtx.state === 'running';
  } catch(e) { return false; }
}

</script>
</body>
</html>
