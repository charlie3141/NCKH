<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>·ª®ng d·ª•ng d·ªãch th·ªß ng·ªØ - Phi√™n b·∫£n t·ªëi ∆∞u hi·ªáu su·∫•t</title>
    
    <!-- Firebase SDK cho hi·ªáu su·∫•t t·ªët h∆°n -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js"></script>
    
    <style>
        /* CSS t·ªëi ∆∞u v·ªõi hardware acceleration */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
            will-change: transform;
            contain: content;
        }

        header {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            padding: 20px;
            text-align: center;
            backface-visibility: hidden;
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 5px;
            will-change: transform;
        }

        .dashboard {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 15px;
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            border: 1px solid #eaeaea;
            will-change: transform;
            contain: content;
            transform: translateZ(0);
        }

        .card h3 {
            color: #4A00E0;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 2px solid #f0f0f0;
        }

        .conversion-display, .sentence-display, .current-word-display {
            backface-visibility: hidden;
            transform: translateZ(0);
            will-change: transform, opacity;
        }

        .conversion-display {
            font-size: 1.3rem;
            font-weight: bold;
            color: #2196F3;
            margin: 8px 0;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #E3F2FD;
            border-radius: 8px;
            padding: 12px;
            border: 2px solid #2196F3;
            line-height: 1.3;
        }

        .sentence-display {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4CAF50;
            margin: 8px 0;
            min-height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #E8F5E9;
            border-radius: 8px;
            padding: 15px;
            border: 2px solid #4CAF50;
            line-height: 1.3;
        }

        .current-word-display {
            font-size: 1.7rem;
            font-weight: bold;
            color: #FF5722;
            margin: 8px 0;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #FFF8E1;
            border-radius: 8px;
            padding: 12px;
            border: 2px dashed #FFC107;
        }

        .word-list {
            margin: 10px 0;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #eaeaea;
        }

        .word-item {
            display: inline-block;
            padding: 6px 12px;
            margin: 4px;
            background: #e3f2fd;
            border-radius: 16px;
            border: 1px solid #bbdefb;
            font-size: 0.9rem;
        }

        .sensor-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .sensor-item {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid;
        }

        .sensor-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #333;
            margin: 4px 0;
        }

        .sensor-label {
            font-size: 0.75rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .flex-box {
            display: inline-block;
            width: 35px;
            height: 35px;
            line-height: 35px;
            text-align: center;
            background: #f8f9fa;
            border-radius: 6px;
            margin: 2px;
            font-weight: bold;
            border: 2px solid transparent;
            font-size: 0.9rem;
        }

        .flex-box.active-0 { background: #4CAF50; color: white; }
        .flex-box.active-1 { background: #FF9800; color: white; }
        .flex-box.active-2 { background: #F44336; color: white; }

        .controls {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.1s;
            font-size: 0.9rem;
            transform: translateZ(0);
        }

        button:hover {
            transform: translateY(-2px) translateZ(0);
            opacity: 0.9;
        }

        button:active {
            transform: translateY(0) translateZ(0);
        }

        .status-bar {
            background: #f8f9fa;
            padding: 12px;
            border-top: 1px solid #eaeaea;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
        }

        /* Animation t·ªëi ∆∞u */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .indicator.online {
            animation: pulse 2s ease-in-out infinite;
            transform: translateZ(0);
        }

        /* Performance optimizations */
        .performance-badge {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: #4CAF50;
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        /* Optimized animations */
        @keyframes slideIn {
            from { 
                opacity: 0; 
                transform: translateY(-5px) translateZ(0); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0) translateZ(0); 
            }
        }

        .auto-suggestions-panel {
            animation: slideIn 0.2s ease;
            transform: translateZ(0);
        }

        /* GPU accelerated elements */
        .gpu-accelerated {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
        }

        /* Gi·∫£m hi·ªáu ·ª©ng cho mobile */
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
                gap: 10px;
                padding: 10px;
            }
            
            .card {
                padding: 10px;
            }
            
            button {
                padding: 8px 16px;
                font-size: 0.85rem;
            }
        }

        /* Th√™m c√°c style c·∫ßn thi·∫øt kh√°c t·ª´ file g·ªëc */
        /* ... (gi·ªØ nguy√™n c√°c style kh√°c t·ª´ file g·ªëc) ... */
        
    </style>
</head>
<body>
    <div class="container gpu-accelerated">
        <header>
            <h1>·ª®ng d·ª•ng d·ªãch th·ªß ng·ªØ - T·ªëi ∆∞u hi·ªáu su·∫•t</h1>
            <div>K·∫øt n·ªëi th·ªùi gian th·ª±c v·ªõi Firebase</div>
            <div class="firebase-status" id="firebaseStatus">
                ƒêang kh·ªüi t·∫°o k·∫øt n·ªëi...
            </div>
        </header>

        <div class="dashboard">
            <!-- Card X√¢y d·ª±ng C√¢u -->
            <div class="card">
                <h3>X√¢y d·ª±ng C√¢u</h3>
                <div style="text-align: center; padding: 15px; margin-bottom: 15px;">
                    <div class="sensor-label">T·ª™ HI·ªÜN T·∫†I (M√£ h√≥a)</div>
                    <div class="current-word-display" id="displayBuffer">---</div>
                    <div class="sensor-label">T·ª™ HI·ªÜN T·∫†I (Ti·∫øng Vi·ªát)</div>
                    <div class="conversion-display" id="convertedCurrentWord">---</div>
                    
                    <div style="margin: 10px 0; color: #666; font-size: 0.9rem;">
                        <div><strong>Nh·∫•n '_' ƒë·ªÉ th√™m t·ª´</strong></div>
                        <div><strong>Nh·∫•n 'COMMIT' ƒë·ªÉ ho√†n th√†nh c√¢u</strong></div>
                    </div>
                    
                    <div class="sensor-label">C√ÇU ƒê·∫¶Y ƒê·ª¶ (M√£ h√≥a)</div>
                    <div class="sentence-display" id="sentenceDisplay">---</div>
                    <div class="sensor-label">C√ÇU ƒê·∫¶Y ƒê·ª¶ (Ti·∫øng Vi·ªát)</div>
                    <div class="conversion-display" id="convertedSentenceDisplay">---</div>
                    
                    <!-- T·ªëi ∆∞u h√≥a TTS -->
                    <div class="tts-toggle" style="margin: 10px 0;">
                        <button class="tts-toggle-btn active" id="useGeminiTTS" onclick="toggleTTSMode(true)">üéØ AI Gemini</button>
                        <button class="tts-toggle-btn" id="useWebSpeech" onclick="toggleTTSMode(false)">üîä Web Speech</button>
                    </div>
                    
                    <!-- B·∫£ng ƒë·ªÅ xu·∫•t t·ª± ƒë·ªông -->
                    <div class="auto-suggestions-panel" id="autoSuggestionsPanel" style="display: none;">
                        <div class="auto-suggestions-title">
                            <span>üí° ƒê·ªÄ XU·∫§T T·ª∞ ƒê·ªòNG</span>
                        </div>
                        <div class="auto-suggestions-grid" id="autoSuggestionsGrid"></div>
                    </div>
                    
                    <!-- ƒê·ªÅ xu·∫•t c·ª•m t·ª´ -->
                    <div class="phrase-suggestions" style="margin-top: 10px;">
                        <h4 style="font-size: 0.9rem; margin-bottom: 8px;">üìù C·ª§M T·ª™ TH√îNG D·ª§NG</h4>
                        <div class="phrase-pills" id="phrasePills"></div>
                    </div>
                    
                    <!-- T√πy ch·ªçn gi·ªçng n√≥i -->
                    <div class="voice-options" style="margin-top: 10px;">
                        <button class="voice-btn male active" data-gender="male" data-lang="vi-VN" onclick="selectVoice(this)">
                            üë® VI
                        </button>
                        <button class="voice-btn female" data-gender="female" data-lang="vi-VN" onclick="selectVoice(this)">
                            üë© VI
                        </button>
                        <button class="voice-btn male" data-gender="male" data-lang="en-GB" onclick="selectVoice(this)">
                            üë® EN
                        </button>
                    </div>
                    
                    <!-- ƒêi·ªÅu khi·ªÉn gi·ªçng n√≥i -->
                    <div class="speech-controls" style="margin-top: 10px;">
                        <button onclick="speakVietnameseSentence()" id="speakVnBtn" style="padding: 8px 16px;">
                            üîä ƒê·ªçc
                        </button>
                        <button onclick="stopAllSpeech()" id="stopSpeechBtn" class="red" style="padding: 8px 16px;">
                            ‚èπ D·ª´ng
                        </button>
                    </div>
                    
                    <div class="word-list" id="wordList">Ch∆∞a c√≥ t·ª´ n√†o</div>
                    <div class="word-count" style="font-size: 0.8rem;">S·ªë t·ª´: <span id="wordCount">0</span>/10</div>
                    
                    <div style="display: flex; justify-content: space-around; margin: 10px 0; padding: 12px; background: #f8f9fa; border-radius: 8px;">
                        <div>
                            <div class="sensor-label">KHE 1</div>
                            <div class="sensor-value" id="slot1" style="font-size: 1rem;">---</div>
                        </div>
                        <div>
                            <div class="sensor-label">KHE 2</div>
                            <div class="sensor-value" id="slot2" style="font-size: 1rem;">---</div>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button onclick="clearCurrentWord()" class="red" style="padding: 8px 12px;">X√≥a t·ª´</button>
                        <button onclick="backspace()" style="padding: 8px 12px;">X√≥a k√Ω t·ª±</button>
                        <button onclick="addWordToSentence()" class="green" style="padding: 8px 12px;">Th√™m (_)</button>
                        <button onclick="commitSentence()" class="blue" style="padding: 8px 12px;">Ho√†n th√†nh</button>
                    </div>
                </div>
            </div>

            <!-- Card D·ªãch thu·∫≠t -->
            <div class="card">
                <h3>D·ªãch thu·∫≠t</h3>
                <div style="margin-bottom: 15px;">
                    <div class="sensor-label">C√ÇU ƒê·ªÇ D·ªäCH</div>
                    <textarea id="translationInput" placeholder="Nh·∫≠p vƒÉn b·∫£n ti·∫øng Vi·ªát..." 
                              style="width: 100%; height: 80px; font-size: 1rem; padding: 10px; margin-bottom: 10px;"></textarea>
                    
                    <div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 8px;">
                        <div style="font-size: 0.9rem;"><strong>T√πy ch·ªçn:</strong></div>
                        <div style="display: flex; gap: 10px; margin-top: 8px; flex-wrap: wrap;">
                            <div>
                                <div class="sensor-label">Ng√¥n ng·ªØ ƒë√≠ch</div>
                                <select id="targetLanguage" style="padding: 5px 10px; font-size: 0.9rem;">
                                    <option value="en-GB">Ti·∫øng Anh</option>
                                    <option value="ja-JP">Ti·∫øng Nh·∫≠t</option>
                                    <option value="ko-KR">Ti·∫øng H√†n</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="sensor-label">K·∫æT QU·∫¢ D·ªäCH</div>
                <div id="translationOutput" class="conversion-display" style="min-height: 60px; margin-bottom: 10px;">
                    ƒêang ch·ªù...
                </div>

                <div class="controls">
                    <button onclick="translateSentence()" class="blue" style="padding: 8px 12px;">D·ªãch</button>
                    <button onclick="clearTranslation()" class="red" style="padding: 8px 12px;">X√≥a</button>
                </div>
            </div>

            <!-- Card Hi·ªÉn th·ªã C·∫£m bi·∫øn -->
            <div class="card">
                <h3>D·ªØ li·ªáu C·∫£m bi·∫øn</h3>
                <div class="sensor-grid">
                    <div class="sensor-item mpu">
                        <div class="sensor-label">ƒê·ªäNH H∆Ø·ªöNG MPU</div>
                        <div class="sensor-value" id="mpuOrientation">---</div>
                        <div class="sensor-label">TR·∫†NG TH√ÅI L·∫ÆC</div>
                        <div class="sensor-value" id="mpuShakeState">---</div>
                    </div>
                    <div class="sensor-item flex">
                        <div class="sensor-label">C·∫¢M BI·∫æN U·ªêN</div>
                        <div>
                            <div>
                                <span class="flex-box" id="flex0-box">0</span>
                                <span class="flex-box" id="flex1-box">0</span>
                                <span class="flex-box" id="flex2-box">0</span>
                                <span class="flex-box" id="flex3-box">0</span>
                            </div>
                            <div class="sensor-label" style="margin-top: 8px;">
                                Gi√° tr·ªã: <span id="rawValues">0, 0, 0, 0</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 10px; font-size: 0.8rem;">
                    <div>C·∫≠p nh·∫≠t l·∫ßn cu·ªëi: <span id="lastUpdateTime">--:--:--</span></div>
                    <div>T·∫ßn su·∫•t: <span id="refreshRate">0Hz</span></div>
                </div>
                
                <div class="controls" style="margin-top: 10px;">
                    <button onclick="refreshData()" class="blue" style="padding: 8px 12px;">L√†m m·ªõi</button>
                    <button onclick="toggleAutoRefresh()" id="autoRefreshBtn" class="green" style="padding: 8px 12px;">T·ª± ƒë·ªông: B·∫¨T</button>
                </div>
            </div>

            <!-- Card Nh·∫≠t k√Ω -->
            <div class="card">
                <h3>Nh·∫≠t k√Ω H·ªá th·ªëng</h3>
                <div style="max-height: 200px; overflow-y: auto; background: #f8f9fa; border-radius: 6px; padding: 8px; font-size: 0.8rem;">
                    <div id="logContainer">H·ªá th·ªëng ƒë√£ kh·ªüi ƒë·ªông...</div>
                </div>
                <div class="controls" style="margin-top: 10px;">
                    <button onclick="clearLog()" class="red" style="padding: 8px 12px;">X√≥a nh·∫≠t k√Ω</button>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div>
                <span class="indicator" id="connectionStatus"></span>
                <span id="statusText">ƒêang k·∫øt n·ªëi...</span>
            </div>
            <div>
                <span id="lastUpdate">C·∫≠p nh·∫≠t: --:--:--</span>
            </div>
        </div>
    </div>

    <!-- Performance badge -->
    <div class="performance-badge" id="performanceBadge">
        Hi·ªáu su·∫•t: <span id="fpsCounter">--</span> FPS
    </div>

    <script>
        // ============================================
        // C·∫§U H√åNH HI·ªÜU SU·∫§T
        // ============================================
        const OPTIMIZATION = {
            DEBOUNCE_MS: 16,           // ~60fps
            THROTTLE_MS: 100,          // X·ª≠ l√Ω d·ªØ li·ªáu
            BATCH_UPDATES: true,
            USE_CACHE: true,
            MAX_FPS: 60,
            MIN_REFRESH_INTERVAL: 100   // 100ms = 10Hz
        };

        // ============================================
        // C·∫§U H√åNH FIREBASE (SDK + REST fallback)
        // ============================================
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyCwILx1T-TnIPg42KwHJQYt7g_FZc2pGKw",
            authDomain: "gangtay-f1efe.firebaseapp.com",
            databaseURL: "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "gangtay-f1efe",
            storageBucket: "gangtay-f1efe.appspot.com",
            messagingSenderId: "702197627526",
            appId: "1:702197627526:web:f99d29d4918ac9d08ba051"
        };

        // URLs d·ª± ph√≤ng
        const FIREBASE_REST_URL = "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/sensorData.json";
        
        // ============================================
        // QU·∫¢N L√ù K·∫æT N·ªêI T·ªêI ∆ØU
        // ============================================
        class FirebaseOptimizer {
            constructor() {
                this.lastUpdate = 0;
                this.updateQueue = [];
                this.isUpdating = false;
                this.connectionMethod = 'rest'; // 'sdk' ho·∫∑c 'rest'
                this.db = null;
                this.isConnected = false;
                this.fps = 0;
                this.frameCount = 0;
                this.lastFpsUpdate = 0;
                
                // Hi·ªáu su·∫•t monitoring
                this.startFPSCounter();
            }
            
            async initialize() {
                try {
                    // Th·ª≠ d√πng Firebase SDK tr∆∞·ªõc
                    firebase.initializeApp(FIREBASE_CONFIG);
                    this.db = firebase.database();
                    this.connectionMethod = 'sdk';
                    this.setupRealtimeListener();
                    return true;
                } catch (error) {
                    console.log('Firebase SDK kh√¥ng kh·∫£ d·ª•ng, d√πng REST API');
                    this.connectionMethod = 'rest';
                    return false;
                }
            }
            
            setupRealtimeListener() {
                if (!this.db) return;
                
                const sensorRef = this.db.ref('sensorData');
                
                sensorRef.on('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        this.handleDataUpdate(data);
                    }
                });
                
                // B√°o tr·∫°ng th√°i k·∫øt n·ªëi
                const connectedRef = this.db.ref('.info/connected');
                connectedRef.on('value', (snap) => {
                    this.isConnected = snap.val() === true;
                    updateConnectionStatus(this.isConnected);
                });
            }
            
            async fetchViaREST() {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 2000);
                    
                    const response = await fetch(FIREBASE_REST_URL + '?t=' + Date.now(), {
                        signal: controller.signal,
                        cache: 'no-store'
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) throw new Error('Network error');
                    
                    const data = await response.json();
                    this.handleDataUpdate(data);
                    
                    return data;
                } catch (error) {
                    console.warn('REST fetch failed:', error);
                    updateConnectionStatus(false);
                    return null;
                }
            }
            
            handleDataUpdate(data) {
                const now = Date.now();
                
                // Ch·ªâ x·ª≠ l√Ω n·∫øu ƒë·ªß th·ªùi gian tr√¥i qua
                if (now - this.lastUpdate < OPTIMIZATION.MIN_REFRESH_INTERVAL) {
                    return;
                }
                
                this.lastUpdate = now;
                
                // Th√™m v√†o queue v√† x·ª≠ l√Ω b·∫•t ƒë·ªìng b·ªô
                this.updateQueue.push(data);
                
                if (!this.isUpdating && this.updateQueue.length > 0) {
                    this.processQueue();
                }
            }
            
            async processQueue() {
                if (this.isUpdating || this.updateQueue.length === 0) return;
                
                this.isUpdating = true;
                
                // L·∫•y d·ªØ li·ªáu m·ªõi nh·∫•t t·ª´ queue
                const latestData = this.updateQueue[this.updateQueue.length - 1];
                this.updateQueue = []; // X√≥a queue
                
                try {
                    // Batch update v·ªõi requestAnimationFrame
                    requestAnimationFrame(() => {
                        updateDisplayOptimized(latestData);
                        updateConnectionStatus(true);
                        
                        // C·∫≠p nh·∫≠t timestamp
                        document.getElementById('lastUpdateTime').textContent = 
                            new Date().toLocaleTimeString();
                        
                        // C·∫≠p nh·∫≠t FPS
                        this.frameCount++;
                    });
                } catch (error) {
                    console.error('Process error:', error);
                } finally {
                    this.isUpdating = false;
                    
                    // X·ª≠ l√Ω c√°c item c√≤n l·∫°i n·∫øu c√≥
                    if (this.updateQueue.length > 0) {
                        setTimeout(() => this.processQueue(), 10);
                    }
                }
            }
            
            startFPSCounter() {
                setInterval(() => {
                    const now = Date.now();
                    if (this.lastFpsUpdate) {
                        this.fps = Math.round((this.frameCount * 1000) / (now - this.lastFpsUpdate));
                        this.frameCount = 0;
                        
                        // C·∫≠p nh·∫≠t hi·ªÉn th·ªã FPS
                        const fpsElement = document.getElementById('fpsCounter');
                        if (fpsElement) {
                            fpsElement.textContent = this.fps;
                            
                            // M√†u s·∫Øc theo FPS
                            if (this.fps > 50) {
                                fpsElement.style.color = '#4CAF50';
                            } else if (this.fps > 30) {
                                fpsElement.style.color = '#FF9800';
                            } else {
                                fpsElement.style.color = '#F44336';
                            }
                        }
                    }
                    this.lastFpsUpdate = now;
                }, 1000);
            }
        }

        // ============================================
        // B·∫¢NG T·ª™ V√Ä CHUY·ªÇN ƒê·ªîI (gi·ªØ nguy√™n t·ª´ file g·ªëc)
        // ============================================
        const tableA = [ /* gi·ªØ nguy√™n */ ];
        const tableB = [ /* gi·ªØ nguy√™n */ ];
        const tableC = [ /* gi·ªØ nguy√™n */ ];
        const vietnameseTable = [ /* gi·ªØ nguy√™n */ ];

        // ============================================
        // BI·∫æN TO√ÄN C·ª§C V√Ä QU·∫¢N L√ù TR·∫†NG TH√ÅI
        // ============================================
        let firebaseOptimizer;
        let lastDisplayData = null;
        let displayUpdatePending = false;
        let autoRefresh = true;
        let autoRefreshInterval;
        let logEntries = [];
        const MAX_LOG_ENTRIES = 15;

        // Bi·∫øn x√¢y d·ª±ng c√¢u
        let slot1 = "";
        let slot2 = "";
        let displayBuffer = "";
        let convertedCurrentWord = "";
        let sentenceWords = [];
        let fullSentence = "";
        let convertedFullSentence = "";
        
        // Tr·∫°ng th√°i c·∫£m bi·∫øn u·ªën
        let flexStates = [0, 0, 0, 0];
        let lastFlexStates = [-1, -1, -1, -1];
        let stableCount = 0;
        let lastDetectedIndex = -1;
        let holdStartMs = 0;
        let holdFired = false;
        const DEBOUNCE_COUNT = 3;
        const HOLD_MS_DEFAULT = 800;
        const POST_HOLD_COOLDOWN = 600;
        let lastActionMs = 0;

        // Speech variables
        let isSpeaking = false;
        let currentSpeech = null;
        let useGeminiTTS = true;
        let currentVoice = { lang: 'vi-VN', gender: 'male' };

        // ============================================
        // H√ÄM HI·ªÜU SU·∫§T CAO
        // ============================================
        function updateDisplayOptimized(data) {
            if (!data || displayUpdatePending) return;
            
            displayUpdatePending = true;
            
            // S·ª≠ d·ª•ng requestAnimationFrame ƒë·ªÉ ƒë·ªìng b·ªô v·ªõi refresh rate
            requestAnimationFrame(() => {
                try {
                    // Ki·ªÉm tra xem d·ªØ li·ªáu c√≥ th·ª±c s·ª± thay ƒë·ªïi kh√¥ng
                    const dataString = JSON.stringify(data);
                    const lastDataString = JSON.stringify(lastDisplayData);
                    
                    if (dataString === lastDataString) {
                        displayUpdatePending = false;
                        return;
                    }
                    
                    lastDisplayData = {...data};
                    
                    // Batch DOM updates
                    const updates = [];
                    
                    // MPU updates
                    updates.push(() => {
                        const orientation = data.o || '---';
                        const shake = data.d || '---';
                        
                        const orientationEl = document.getElementById('mpuOrientation');
                        const shakeEl = document.getElementById('mpuShakeState');
                        
                        if (orientationEl.textContent !== orientation) {
                            orientationEl.textContent = orientation;
                        }
                        if (shakeEl.textContent !== shake) {
                            shakeEl.textContent = shake;
                        }
                    });
                    
                    // Flex sensor updates
                    updates.push(() => {
                        const flexValues = [
                            data.f0 || 0, 
                            data.f1 || 0, 
                            data.f2 || 0, 
                            data.f3 || 0
                        ];
                        
                        for (let i = 0; i < 4; i++) {
                            const flexState = calculateFlexState(flexValues[i], i);
                            flexStates[i] = flexState;
                            
                            const box = document.getElementById(`flex${i}-box`);
                            if (box.textContent !== flexState.toString()) {
                                box.textContent = flexState;
                                box.className = `flex-box active-${flexState}`;
                            }
                        }
                        
                        const rawValuesEl = document.getElementById('rawValues');
                        const rawString = flexValues.join(', ');
                        if (rawValuesEl.textContent !== rawString) {
                            rawValuesEl.textContent = rawString;
                        }
                    });
                    
                    // Th·ª±c thi t·∫•t c·∫£ updates
                    updates.forEach(update => update());
                    
                    // X·ª≠ l√Ω word construction v·ªõi throttle
                    throttleWordConstruction(data);
                    
                } catch (error) {
                    console.error('Display update error:', error);
                } finally {
                    displayUpdatePending = false;
                }
            });
        }

        // Throttle cho word construction
        let lastProcessTime = 0;
        function throttleWordConstruction(data) {
            const now = Date.now();
            if (now - lastProcessTime > OPTIMIZATION.THROTTLE_MS) {
                lastProcessTime = now;
                processWordConstruction(data);
                updateUI();
            }
        }

        // ============================================
        // H√ÄM X·ª¨ L√ù T·ª™ V√Ä C√ÇU (gi·ªØ nguy√™n logic)
        // ============================================
        function calculateFlexState(rawValue, sensorIndex) {
            const STRAIGHT_THRESHOLD = sensorIndex === 3 ? 100 : 150;
            const bentThresholds = [300, 450, 350, 300];
            
            if (rawValue <= STRAIGHT_THRESHOLD) return 0;
            if (rawValue <= bentThresholds[sensorIndex]) return 1;
            return 2;
        }

        function getMPUState(orientation, shakeState) {
            if (shakeState === "Shake Left") return 6;
            if (shakeState === "Shake Right") return 7;
            
            switch(orientation) {
                case "Up": return 0;
                case "Down": return 1;
                case "Left": return 2;
                case "Right": return 3;
                case "Forward": return 4;
                case "Backward": return 5;
                default: return -1;
            }
        }

        function convertVietnameseWord(encodedWord) {
            // Gi·ªØ nguy√™n t·ª´ file g·ªëc
            if (!encodedWord || encodedWord.length === 0) return "";
            
            const firstUnderscore = encodedWord.indexOf('_');
            if (firstUnderscore === -1) return encodedWord;
            
            const secondUnderscore = encodedWord.indexOf('_', firstUnderscore + 1);
            if (secondUnderscore === -1) return encodedWord;
            
            const consonant = encodedWord.substring(0, firstUnderscore);
            const middle = encodedWord.substring(firstUnderscore + 1, secondUnderscore);
            const vowelTypeStr = encodedWord.substring(secondUnderscore + 1);
            
            if (middle.length < 2) return encodedWord;
            
            const toneChar = middle[0];
            if (toneChar < '1' || toneChar > '6') return encodedWord;
            
            const tone = parseInt(toneChar);
            const vowelKey = middle.substring(1);
            
            let vowelType = 0;
            if (vowelTypeStr === "b") vowelType = 1;
            else if (vowelTypeStr === "p") vowelType = 2;
            else if (vowelTypeStr !== "s") return encodedWord;
            
            const tableIndex = (tone - 1) + (vowelType * 6);
            if (tableIndex < 0 || tableIndex >= 18) return encodedWord;
            
            const vowelKeyUpper = vowelKey.toUpperCase();
            
            for (let i = 0; i < vietnameseTable.length; i++) {
                if (vowelKeyUpper === vietnameseTable[i].key) {
                    return consonant + vietnameseTable[i].forms[tableIndex];
                }
            }
            
            return encodedWord;
        }

        function processWordConstruction(data) {
            const mpuState = getMPUState(data.o || "---", data.d || "---");
            const a0 = flexStates[0];
            const a1 = flexStates[1];
            const a2 = flexStates[2];
            const a3 = flexStates[3];
            
            // Debounce logic
            if (mpuState === lastDetectedIndex && 
                a0 === lastFlexStates[0] && 
                a1 === lastFlexStates[1] && 
                a2 === lastFlexStates[2] && 
                a3 === lastFlexStates[3]) {
                stableCount++;
            } else {
                stableCount = 1;
                lastDetectedIndex = mpuState;
                lastFlexStates = [...flexStates];
                holdStartMs = Date.now();
                holdFired = false;
            }
            
            // Check for action
            if (stableCount >= DEBOUNCE_COUNT) {
                const held = Date.now() - holdStartMs;
                if (!holdFired && (Date.now() - lastActionMs) > POST_HOLD_COOLDOWN && held >= HOLD_MS_DEFAULT) {
                    performActionSlotLogic(mpuState, a0, a1, a2, a3);
                    holdFired = true;
                    lastActionMs = Date.now();
                }
            }
        }

        function performActionSlotLogic(mpu, a0, a1, a2, a3) {
            // Mapping logic t·ª´ file g·ªëc
            if (a3 === 2) {
                if (a0 < 3 && a1 < 3 && a2 < 3) {
                    const mapping = tableC[a0][a1][a2];
                    if (mapping === "_") addWordToSentence();
                    else if (mapping === "COMMIT") commitSentence();
                    else if (mapping === "<") backspaceBuffer();
                }
                return false;
            }
            
            const a3bin = a3 === 1 ? 1 : 0;
            if (a1 < 0 || a1 >= 3 || a2 < 0 || a2 >= 3) return false;
            
            const flatIndex = a1 * 3 + a2;
            if (flatIndex >= 0 && flatIndex < 9) {
                const mapping = a3bin === 0 ? tableA[mpu][flatIndex] : tableB[mpu][flatIndex];
                
                if (mapping === "nullptr") return false;
                if (mapping === "_") { addWordToSentence(); return true; }
                if (mapping === "COMMIT") { commitSentence(); return true; }
                if (mapping === "<") { backspaceBuffer(); return true; }
                
                const isSlot1 = (a3 === 2);
                const held = Date.now() - holdStartMs;
                
                if (isSlot1 && stableCount >= DEBOUNCE_COUNT && held < HOLD_MS_DEFAULT) {
                    const mode = flexModeCharFromA0(a0);
                    slot2 = `${mapping}_${mode}`;
                } else if (isSlot1) {
                    slot1 = `${mapping}_${mpu}`;
                } else {
                    const mode = flexModeCharFromA0(a0);
                    slot2 = `${mapping}_${mode}`;
                }
                
                updateDisplayBufferFromSlots();
                log('WORD', `H√†nh ƒë·ªông: ${displayBuffer}`);
                return true;
            }
            
            return false;
        }

        function flexModeCharFromA0(a0) {
            switch(a0) {
                case 0: return 's';
                case 1: return 'b';
                case 2: return 'p';
                default: return 'x';
            }
        }

        function updateDisplayBufferFromSlots() {
            const oldBuffer = displayBuffer;
            displayBuffer = '';
            
            if (slot1) displayBuffer += slot1.toLowerCase();
            if (slot2) displayBuffer += slot2.toLowerCase();
            
            if (oldBuffer !== displayBuffer) {
                convertedCurrentWord = convertVietnameseWord(displayBuffer);
                log('WORD', `T·ª´ m·ªõi: ${displayBuffer}`);
            }
            
            updateUI();
        }

        // ============================================
        // H√ÄM UI V√Ä CONTROLS
        // ============================================
        function updateUI() {
            // Batch DOM updates
            requestAnimationFrame(() => {
                // Current word
                document.getElementById('slot1').textContent = slot1 || '---';
                document.getElementById('slot2').textContent = slot2 || '---';
                document.getElementById('displayBuffer').textContent = displayBuffer || '---';
                document.getElementById('convertedCurrentWord').textContent = convertedCurrentWord || '---';
                
                // Sentence
                document.getElementById('sentenceDisplay').textContent = fullSentence || '---';
                document.getElementById('convertedSentenceDisplay').textContent = convertedFullSentence || '---';
                document.getElementById('wordCount').textContent = sentenceWords.length;
                
                // Word list
                const wordListDiv = document.getElementById('wordList');
                if (sentenceWords.length > 0) {
                    wordListDiv.innerHTML = sentenceWords.map(word => 
                        `<div class="word-item">${word}</div>`
                    ).join('');
                } else {
                    wordListDiv.innerHTML = 'Ch∆∞a c√≥ t·ª´ n√†o';
                }
                
                // Update translation textarea
                document.getElementById('translationInput').value = convertedFullSentence || '';
                
                // Update speech buttons
                const speakVnBtn = document.getElementById('speakVnBtn');
                const stopSpeechBtn = document.getElementById('stopSpeechBtn');
                
                speakVnBtn.disabled = !convertedFullSentence || isSpeaking;
                stopSpeechBtn.disabled = !isSpeaking;
                
                if (isSpeaking) {
                    speakVnBtn.classList.add('speaking');
                } else {
                    speakVnBtn.classList.remove('speaking');
                }
            });
        }

        function addWordToSentence() {
            if (!displayBuffer || sentenceWords.length >= 10) return;
            
            sentenceWords.push(displayBuffer);
            updateFullSentence();
            log('SENTENCE', `ƒê√£ th√™m: '${displayBuffer}'`);
            
            // Clear current word
            slot1 = '';
            slot2 = '';
            displayBuffer = '';
            convertedCurrentWord = '';
            
            updateUI();
        }

        function updateFullSentence() {
            fullSentence = sentenceWords.join(' ');
            
            // Convert to Vietnamese
            if (fullSentence) {
                convertedFullSentence = fullSentence.split(' ')
                    .map(word => convertVietnameseWord(word))
                    .join(' ');
            } else {
                convertedFullSentence = '';
            }
        }

        function commitSentence() {
            if (sentenceWords.length === 0) {
                log('SENTENCE', 'Kh√¥ng c√≥ t·ª´ n√†o!');
                return;
            }
            
            if (displayBuffer) addWordToSentence();
            
            log('SENTENCE', `Ho√†n th√†nh: ${fullSentence}`);
            log('CONVERSION', `ƒê√£ chuy·ªÉn: ${convertedFullSentence}`);
            
            // Reset
            resetSentence();
        }

        function resetSentence() {
            sentenceWords = [];
            fullSentence = '';
            convertedFullSentence = '';
            slot1 = '';
            slot2 = '';
            displayBuffer = '';
            convertedCurrentWord = '';
            
            document.getElementById('autoSuggestionsPanel').style.display = 'none';
            updateUI();
        }

        function clearCurrentWord() {
            slot1 = '';
            slot2 = '';
            displayBuffer = '';
            convertedCurrentWord = '';
            updateUI();
            log('WORD', 'ƒê√£ x√≥a t·ª´ hi·ªán t·∫°i');
        }

        function backspaceBuffer() {
            if (displayBuffer.length > 0) {
                displayBuffer = displayBuffer.slice(0, -1);
                convertedCurrentWord = convertVietnameseWord(displayBuffer);
            }
        }

        function backspace() {
            backspaceBuffer();
            updateUI();
        }

        // ============================================
        // H√ÄM LOG V√Ä TR·∫†NG TH√ÅI
        // ============================================
        function log(source, message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = { timestamp, source, message };
            
            logEntries.unshift(logEntry);
            if (logEntries.length > MAX_LOG_ENTRIES) {
                logEntries.pop();
            }
            
            updateLogDisplay();
        }

        function updateLogDisplay() {
            const logContainer = document.getElementById('logContainer');
            
            // Batch update
            requestAnimationFrame(() => {
                logContainer.innerHTML = logEntries.map(entry => 
                    `<div style="margin-bottom: 3px; border-bottom: 1px solid #eee; padding: 2px 0;">
                        <span style="color: #666;">[${entry.timestamp}] ${entry.source}:</span>
                        <span style="color: #333;"> ${entry.message}</span>
                    </div>`
                ).join('');
            });
        }

        function clearLog() {
            logEntries = [];
            updateLogDisplay();
        }

        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            
            requestAnimationFrame(() => {
                if (connected) {
                    indicator.className = 'indicator online';
                    statusText.textContent = 'ƒê√£ k·∫øt n·ªëi';
                } else {
                    indicator.className = 'indicator';
                    statusText.textContent = 'M·∫•t k·∫øt n·ªëi';
                }
            });
        }

        // ============================================
        // H√ÄM ƒêI·ªÄU KHI·ªÇN FIREBASE
        // ============================================
        function refreshData() {
            if (firebaseOptimizer.connectionMethod === 'sdk') {
                // SDK t·ª± ƒë·ªông c·∫≠p nh·∫≠t
                log('SYSTEM', 'ƒêang ƒë·ªìng b·ªô d·ªØ li·ªáu...');
            } else {
                firebaseOptimizer.fetchViaREST();
            }
        }

        function toggleAutoRefresh() {
            autoRefresh = !autoRefresh;
            const btn = document.getElementById('autoRefreshBtn');
            
            if (autoRefresh) {
                btn.textContent = 'T·ª± ƒë·ªông: B·∫¨T';
                btn.className = 'green';
                
                if (firebaseOptimizer.connectionMethod === 'rest') {
                    autoRefreshInterval = setInterval(() => {
                        firebaseOptimizer.fetchViaREST();
                    }, 500); // 500ms cho REST
                }
                
                log('SYSTEM', 'ƒê√£ b·∫≠t t·ª± ƒë·ªông l√†m m·ªõi');
            } else {
                btn.textContent = 'T·ª± ƒë·ªông: T·∫ÆT';
                btn.className = 'red';
                clearInterval(autoRefreshInterval);
                log('SYSTEM', 'ƒê√£ t·∫Øt t·ª± ƒë·ªông l√†m m·ªõi');
            }
        }

        // ============================================
        // H√ÄM D·ªäCH THU·∫¨T V√Ä GI·ªåNG N√ìI (r√∫t g·ªçn)
        // ============================================
        async function translateSentence() {
            const text = document.getElementById('translationInput').value.trim();
            const targetLang = document.getElementById('targetLanguage').value;
            const outputDiv = document.getElementById('translationOutput');
            
            if (!text) {
                outputDiv.innerHTML = '<span style="color: #F44336;">Nh·∫≠p vƒÉn b·∫£n!</span>';
                return;
            }
            
            outputDiv.innerHTML = '<span class="loading">ƒêang d·ªãch...</span>';
            
            try {
                const langMap = { 'en-GB': 'en', 'ja-JP': 'ja', 'ko-KR': 'ko' };
                const langCode = langMap[targetLang] || 'en';
                
                const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=vi|${langCode}`);
                const data = await response.json();
                
                if (data.responseStatus === 200) {
                    outputDiv.innerHTML = data.responseData.translatedText;
                    log('TRANSLATION', `ƒê√£ d·ªãch sang ${targetLang}`);
                } else {
                    throw new Error('D·ªãch th·∫•t b·∫°i');
                }
            } catch (error) {
                outputDiv.innerHTML = '<span style="color: #F44336;">L·ªói d·ªãch thu·∫≠t</span>';
            }
        }

        function clearTranslation() {
            document.getElementById('translationOutput').innerHTML = 'ƒêang ch·ªù...';
        }

        async function speakVietnameseSentence() {
            const text = convertedFullSentence || document.getElementById('convertedSentenceDisplay').textContent;
            if (!text || text === '---') return;
            
            if (isSpeaking) {
                stopAllSpeech();
                return;
            }
            
            // S·ª≠ d·ª•ng Web Speech API cho ƒë∆°n gi·∫£n
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = currentVoice.lang;
                utterance.rate = 0.9;
                
                utterance.onstart = () => {
                    isSpeaking = true;
                    updateUI();
                    log('SPEECH', 'ƒêang ƒë·ªçc...');
                };
                
                utterance.onend = utterance.onerror = () => {
                    isSpeaking = false;
                    updateUI();
                };
                
                currentSpeech = utterance;
                speechSynthesis.speak(utterance);
            }
        }

        function stopAllSpeech() {
            if (window.speechSynthesis) {
                speechSynthesis.cancel();
            }
            isSpeaking = false;
            updateUI();
        }

        function selectVoice(button) {
            const lang = button.getAttribute('data-lang');
            const gender = button.getAttribute('data-gender');
            
            currentVoice = { lang, gender };
            
            // Update button states
            document.querySelectorAll('.voice-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            button.classList.add('active');
            
            log('VOICE', `Gi·ªçng: ${lang} ${gender}`);
        }

        function toggleTTSMode(useGemini) {
            useGeminiTTS = useGemini;
            log('TTS', `Ch·∫ø ƒë·ªô: ${useGemini ? 'AI Gemini' : 'Web Speech'}`);
        }

        // ============================================
        // KH·ªûI T·∫†O ·ª®NG D·ª§NG
        // ============================================
        document.addEventListener('DOMContentLoaded', async function() {
            log('SYSTEM', 'Kh·ªüi ƒë·ªông ·ª©ng d·ª•ng t·ªëi ∆∞u...');
            
            // Kh·ªüi t·∫°o Firebase Optimizer
            firebaseOptimizer = new FirebaseOptimizer();
            const sdkAvailable = await firebaseOptimizer.initialize();
            
            if (sdkAvailable) {
                log('SYSTEM', 'ƒê√£ k·∫øt n·ªëi Firebase SDK');
            } else {
                log('SYSTEM', 'D√πng REST API, b·∫≠t t·ª± ƒë·ªông l√†m m·ªõi');
                toggleAutoRefresh();
            }
            
            // Load phrase suggestions
            const commonPhrases = [
                "Xin ch√†o", "C·∫£m ∆°n", "L√†m ∆°n", "Bao nhi√™u ti·ªÅn",
                "T√¥i kh√¥ng hi·ªÉu", "Ch√†o bu·ªïi s√°ng", "T·∫°m bi·ªát"
            ];
            
            const phrasePills = document.getElementById('phrasePills');
            commonPhrases.forEach(phrase => {
                const pill = document.createElement('button');
                pill.className = 'phrase-pill';
                pill.textContent = phrase;
                pill.style.cssText = 'padding: 4px 8px; margin: 2px; font-size: 0.8rem;';
                pill.onclick = () => {
                    document.getElementById('translationInput').value = phrase;
                    translateSentence();
                };
                phrasePills.appendChild(pill);
            });
            
            // C·∫≠p nh·∫≠t hi·ªáu su·∫•t
            setInterval(() => {
                const refreshRate = document.getElementById('refreshRate');
                if (firebaseOptimizer.lastUpdate) {
                    const rate = Math.round(1000 / (Date.now() - firebaseOptimizer.lastUpdate));
                    refreshRate.textContent = rate + 'Hz';
                }
            }, 1000);
            
            log('SYSTEM', 'S·∫µn s√†ng! FPS: ' + firebaseOptimizer.fps);
        });
    </script>
</body>
</html>
