<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Word Constructor - Firebase Monitor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            padding: 20px;
            text-align: center;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .dashboard {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            border: 1px solid #eaeaea;
        }

        .card h3 {
            color: #4A00E0;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }

        .conversion-display {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2196F3;
            margin: 10px 0;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #E3F2FD;
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #2196F3;
            line-height: 1.4;
        }

        .sentence-display {
            font-size: 1.8rem;
            font-weight: bold;
            color: #4CAF50;
            margin: 10px 0;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #E8F5E9;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #4CAF50;
            line-height: 1.4;
        }

        .current-word-display {
            font-size: 2rem;
            font-weight: bold;
            color: #FF5722;
            margin: 10px 0;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #FFF8E1;
            border-radius: 10px;
            padding: 15px;
            border: 2px dashed #FFC107;
        }

        .word-list {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #eaeaea;
        }

        .word-item {
            display: inline-block;
            padding: 8px 15px;
            margin: 5px;
            background: #e3f2fd;
            border-radius: 20px;
            border: 1px solid #bbdefb;
        }

        .word-count {
            font-size: 0.9rem;
            color: #666;
            margin-top: 10px;
        }

        .sensor-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .sensor-item {
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid;
        }

        .sensor-item.mpu {
            border-left-color: #2196F3;
        }

        .sensor-item.flex {
            border-left-color: #4CAF50;
        }

        .sensor-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
            margin: 5px 0;
        }

        .sensor-label {
            font-size: 0.8rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .flex-box {
            display: inline-block;
            width: 40px;
            height: 40px;
            line-height: 40px;
            text-align: center;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 2px;
            font-weight: bold;
            border: 2px solid transparent;
        }

        .flex-box.active-0 { background: #4CAF50; color: white; }
        .flex-box.active-1 { background: #FF9800; color: white; }
        .flex-box.active-2 { background: #F44336; color: white; }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(to right, #4A00E0, #8E2DE2);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        button.red {
            background: linear-gradient(to right, #FF416C, #FF4B2B);
        }

        button.green {
            background: linear-gradient(to right, #00b09b, #96c93d);
        }

        button.blue {
            background: linear-gradient(to right, #2196F3, #21CBF3);
        }

        button.orange {
            background: linear-gradient(to right, #FF9800, #FF5722);
        }

        .status-bar {
            background: #f8f9fa;
            padding: 15px;
            border-top: 1px solid #eaeaea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        .indicator.online {
            background: #4CAF50;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .calibration-status {
            margin: 15px 0;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
        }

        .calibrating {
            background: #FFF3CD;
            border: 2px solid #FFC107;
            color: #856404;
            animation: pulse 1s infinite;
        }

        .calibrated {
            background: #D4EDDA;
            border: 2px solid #28A745;
            color: #155724;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        .shake-active {
            color: #FF5722 !important;
            font-weight: bold !important;
            animation: shake 0.5s infinite;
        }

        .language-select {
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid #ccc;
            background: white;
            font-size: 1rem;
        }

        .phrase-btn {
            padding: 8px 15px;
            background: linear-gradient(to right, #FF9800, #FF5722);
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .phrase-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(255,87,34,0.3);
        }

        .loading {
            animation: pulse 1s infinite;
            color: #2196F3 !important;
        }

        .error {
            color: #F44336 !important;
            border-color: #F44336 !important;
            background: #FFEBEE !important;
        }

        .success {
            color: #4CAF50 !important;
            border-color: #4CAF50 !important;
            background: #E8F5E9 !important;
        }

        textarea {
            width: 100%;
            height: 120px;
            font-size: 1.5rem;
            padding: 15px;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            background: #E8F5E9;
            color: #333;
            resize: vertical;
        }

        select {
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid #ccc;
            min-width: 150px;
        }

        .radio-group {
            display: flex;
            gap: 15px;
            margin-top: 5px;
        }

        .radio-group label {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .firebase-status {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

        .last-update {
            font-size: 0.8rem;
            color: #999;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }

        /* Phrase Suggestions Styles */
        .phrase-suggestions-container {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #eaeaea;
        }

        .phrase-suggestions-header {
            font-size: 0.8rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .phrase-pills {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .phrase-pill {
            padding: 6px 12px;
            background: #e3f2fd;
            color: #1976D2;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            border: 1px solid #bbdefb;
            transition: all 0.2s;
        }

        .phrase-pill:hover {
            background: #1976D2;
            color: white;
            transform: translateY(-2px);
        }

        .suggestion-dropdown {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            width: calc(100% - 30px);
            margin-top: 5px;
        }

        .suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background 0.2s;
        }

        .suggestion-item:hover {
            background: #f0f0f0;
        }

        .suggestion-header {
            padding: 8px 12px;
            background: #f8f9fa;
            font-size: 0.8rem;
            color: #666;
            border-bottom: 1px solid #ddd;
        }

        /* TTS Controls */
        .tts-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            align-items: center;
        }

        .tts-btn {
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .tts-btn.speak {
            background: linear-gradient(to right, #00b09b, #96c93d);
            color: white;
        }

        .tts-btn.stop {
            background: linear-gradient(to right, #FF416C, #FF4B2B);
            color: white;
        }

        .tts-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .api-key-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9rem;
        }

        .api-key-label {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
            display: block;
        }

        .tts-status {
            font-size: 0.9rem;
            padding: 8px 12px;
            border-radius: 6px;
            margin-top: 10px;
            text-align: center;
        }

        .tts-status.loading {
            background: #E3F2FD;
            color: #1976D2;
            animation: pulse 1s infinite;
        }

        .tts-status.error {
            background: #FFEBEE;
            color: #F44336;
        }

        .tts-status.success {
            background: #E8F5E9;
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ESP32 Word Constructor - Firebase Monitor</h1>
            <div>Real-time monitoring from Firebase Realtime Database</div>
            <div class="firebase-status" id="firebaseStatus">
                Connecting to Firebase...
            </div>
        </header>

        <div class="dashboard">
            <!-- Sentence Construction Card -->
            <div class="card">
                <h3>Sentence Construction</h3>
                <div style="text-align: center; padding: 20px; margin-bottom: 20px;">
                    <div class="sensor-label">CURRENT WORD (Encoded)</div>
                    <div class="current-word-display" id="displayBuffer">---</div>
                    <div class="sensor-label">CURRENT WORD (Vietnamese)</div>
                    <div class="conversion-display" id="convertedCurrentWord">---</div>
                    
                    <div style="margin: 15px 0; color: #666;">
                        <div><strong>Use '_' to add word to sentence</strong></div>
                        <div><strong>Use 'COMMIT' to finalize sentence</strong></div>
                    </div>
                    
                    <div class="sensor-label">FULL SENTENCE (Encoded)</div>
                    <div class="sentence-display" id="sentenceDisplay">---</div>
                    <div class="sensor-label">FULL SENTENCE (Vietnamese)</div>
                    <div class="conversion-display" id="convertedSentenceDisplay">---</div>
                    
                    <div class="word-list" id="wordList">No words yet</div>
                    <div class="word-count">Words in sentence: <span id="wordCount">0</span>/10</div>
                    
                    <div style="display: flex; justify-content: space-around; margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                        <div>
                            <div class="sensor-label">SLOT 1</div>
                            <div class="sensor-value" id="slot1" style="font-size: 1.2rem;">---</div>
                        </div>
                        <div>
                            <div class="sensor-label">SLOT 2</div>
                            <div class="sensor-value" id="slot2" style="font-size: 1.2rem;">---</div>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button onclick="clearCurrentWord()" class="red">Clear Current</button>
                        <button onclick="backspace()">Backspace</button>
                        <button onclick="addWordToSentence()" class="green">Add Word (_)</button>
                        <button onclick="commitSentence()" class="blue">Commit Sentence</button>
                        <button onclick="resetSentence()" class="red">Reset All</button>
                    </div>
                </div>
            </div>

            <!-- Translation & TTS Card -->
            <div class="card">
                <h3>Translation & Text-to-Speech</h3>
                <div style="margin-bottom: 20px;">
                    <div class="sensor-label">FULL SENTENCE (Vietnamese - For Translation)</div>
                    <textarea id="translationInput" placeholder="Enter Vietnamese text here..." oninput="handleTranslationInputChange()"></textarea>
                    
                    <!-- Phrase Suggestions -->
                    <div class="phrase-suggestions-container">
                        <div class="phrase-suggestions-header">QUICK PHRASE SUGGESTIONS</div>
                        <div class="phrase-pills" id="phrasePills">
                            <!-- Phrase pills will be inserted here by JavaScript -->
                        </div>
                    </div>
                    
                    <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                        <div><strong>Translation Options:</strong></div>
                        <div style="display: flex; gap: 15px; margin-top: 10px; flex-wrap: wrap;">
                            <div>
                                <div class="sensor-label">Target Language</div>
                                <select id="targetLanguage" class="language-select">
                                    <option value="en-GB">English</option>
                                    <option value="ja-JP">Japanese</option>
                                    <option value="ko-KR">Korean</option>
                                    <option value="zh-CN">Chinese</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="sensor-label">TRANSLATED RESULT</div>
                <div id="translationOutput" class="conversion-display" style="min-height: 80px; margin-bottom: 15px;">
                    Waiting for translation...
                </div>

                <!-- TTS Controls -->
                <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                    <div class="sensor-label">TEXT-TO-SPEECH (AI VOICE)</div>
                    
                    <div style="margin-top: 10px;">
                        <label class="api-key-label">Gemini API Key (for TTS):</label>
                        <input type="password" id="apiKeyInput" class="api-key-input" placeholder="Enter your Gemini API key">
                    </div>
                    
                    <div class="tts-controls">
                        <button onclick="speakText('vi-VN')" id="speakOriginalBtn" class="tts-btn speak" disabled>
                            <span>üîä</span> Speak Vietnamese
                        </button>
                        <button onclick="speakText('translation')" id="speakTranslatedBtn" class="tts-btn speak" disabled>
                            <span>üîä</span> Speak Translated
                        </button>
                        <button onclick="stopSpeaking()" id="stopSpeakingBtn" class="tts-btn stop" disabled>
                            <span>‚èπ</span> Stop
                        </button>
                    </div>
                    
                    <div id="ttsStatus" class="tts-status"></div>
                </div>

                <div class="controls">
                    <button onclick="translateSentence()" class="blue">Translate Sentence</button>
                    <button onclick="clearTranslation()" class="red">Clear Translation</button>
                </div>
            </div>

            <!-- Sensors Display Card -->
            <div class="card">
                <h3>Sensors Data from Firebase</h3>
                <div class="sensor-grid">
                    <div class="sensor-item mpu">
                        <div class="sensor-label">MPU6050 ORIENTATION</div>
                        <div class="sensor-value" id="mpuOrientation">Unknown</div>
                        <div class="sensor-label">SHAKE STATUS</div>
                        <div class="sensor-value" id="mpuShakeState">None</div>
                        <div class="sensor-label">IS SHAKING?</div>
                        <div class="sensor-value" id="isShaking">NO</div>
                    </div>
                    <div class="sensor-item flex">
                        <div class="sensor-label">FLEX SENSORS</div>
                        <div>
                            <div>
                                <span class="flex-box" id="flex0-box">0</span>
                                <span class="flex-box" id="flex1-box">0</span>
                                <span class="flex-box" id="flex2-box">0</span>
                                <span class="flex-box" id="flex3-box">0</span>
                            </div>
                            <div class="sensor-label" style="margin-top: 10px;">
                                Raw Values: <span id="rawValues">0, 0, 0, 0</span>
                            </div>
                            <div class="sensor-label">
                                State: <span id="flexFormat">0000</span> (a0,a1,a2,a3)
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="sensor-item" style="margin-top: 15px;">
                    <div class="sensor-label">SYSTEM STATUS</div>
                    <div>Last Update: <span id="lastUpdateTime" class="last-update">Never</span></div>
                </div>
                
                <div class="controls" style="margin-top: 15px;">
                    <button onclick="refreshData()" class="blue">Refresh Now</button>
                    <button onclick="toggleAutoRefresh()" id="autoRefreshBtn" class="green">Auto: ON</button>
                </div>
            </div>

            <!-- Log Display Card -->
            <div class="card">
                <h3>System Log</h3>
                <div style="max-height: 300px; overflow-y: auto; background: #f8f9fa; border-radius: 8px; padding: 10px;">
                    <div id="logContainer">
                        <div class="log-entry">System started. Waiting for Firebase data...</div>
                    </div>
                </div>
                <div class="controls" style="margin-top: 15px;">
                    <button onclick="clearLog()" class="red">Clear Log</button>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div>
                <span class="indicator" id="connectionStatus"></span>
                <span id="statusText">Connecting to Firebase...</span>
            </div>
            <div>
                <span id="lastUpdate">Last Firebase update: --:--:--</span>
            </div>
        </div>
    </div>

    <script>
        // Firebase Configuration
        const FIREBASE_URL = "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/sensorData.json";
        
        // Tables from ESP32 code
        const tableA = [
            ["IAY","IC","ICH","IE","IEC","IEM","IEN","IENG","IEO"],
            ["IEP","IET","IEU","IM","IN","ING","INH","IO","IOI"],
            ["ENG","ENH","EO","EP","ET","EU","I","IA","IAC"],
            ["IAI","IAM","IAN","IANG","IANH","IAO","IAP","IAT","IAU"],
            ["AP","AT","AU","AY","E","EC","ECH","EM","EN"],
            ["A","AC","ACH","AI","AM","AN","ANG","ANH","AO"],
            ["IUN","IUONG","IUP","O","OA","OAC","OACH","OAI","OAM"],
            ["ION","IONG","IOT","IP","IT","IU","IUA","IUC","IUI"]
        ];

        const tableB = [
            ["UE","UECH","UEN","UENH","UEO","UET","UI","UM","UN"],
            ["UNG","UO","UOC","UOI","UOM","UON","UONG","UOP","OUT"],
            ["ONG","OOC","OONG","OP","OT","U","UA","UAC","UACH"],
            ["UAI","UAM","UAN","UANG","UANH","UAO","UAT","UAY","UC"],
            ["OAY","OC","OE","OEN","OEO","OET","OI","OM","ON"],
            ["COMMIT","_","nullptr","nullptr","OAN","OANG","OANH","OAP","OAT"],
            ["UYNH","UYP","UYT","UYU","Y","YEM","YEN","YET","YEU"],
            ["UOU","UP","UT","UU","UY","UYA","UYCH","UYEN","UYET"]
        ];

        const tableC = [
            [ ["B","C","D"],["ƒê","G","H"],["K","L","M"] ],
            [ ["N","P","Q"],["R","S","T"],["V","X","CH"] ],
            [ ["GH","KH","NG"],["NGH","NH","PH"],["TH","TR","_"] ]
        ];

        // Vietnamese Conversion Table (full table from ESP32 code)
        const vietnameseTable = [
            {key: "IAY", forms: ["i√°y", "i√†y", "i·∫£y", "i√£y", "i·∫°y", "iay", "i·∫•y", "i·∫ßy", "i·∫©y", "i·∫´y", "i·∫≠y", "i√¢y", "i·∫Øy", "i·∫±y", "i·∫≥y", "i·∫µy", "i·∫∑y", "iƒÉy"]},
            {key: "IC", forms: ["√≠c", "√¨c", "·ªâc", "ƒ©c", "·ªãc", "ic", "√≠c", "√¨c", "·ªâc", "ƒ©c", "·ªãc", "ic", "√≠c", "√¨c", "·ªâc", "ƒ©c", "·ªãc", "ic"]},
            // ... (gi·ªØ nguy√™n to√†n b·ªô vietnameseTable, c·∫Øt b·ªõt ƒë·ªÉ code g·ªçn)
        ];

        // Common Phrases for Suggestion
        const commonPhrases = [
            "Xin ch√†o, r·∫•t vui ƒë∆∞·ª£c g·∫∑p b·∫°n",
            "B·∫°n kh·ªèe kh√¥ng?",
            "C·∫£m ∆°n b·∫°n r·∫•t nhi·ªÅu",
            "L√†m ∆°n cho t√¥i h·ªèi ƒë∆∞·ªùng",
            "Ch√∫c m·ªôt ng√†y t·ªët l√†nh",
            "T√¥i y√™u ng√¥n ng·ªØ n√†y",
            "H·∫πn g·∫∑p l·∫°i sau",
            "T√¥i kh√¥ng hi·ªÉu",
            "B·∫°n c√≥ th·ªÉ n√≥i l·∫°i kh√¥ng?",
            "Xin l·ªói",
            "T√¥i c·∫ßn gi√∫p ƒë·ª°",
            "C√°i n√†y bao nhi√™u ti·ªÅn?",
            "ƒê·∫πp qu√°",
            "Ngon qu√°",
            "M·ªát qu√°"
        ];

        // Language and Voice Mapping
        const voiceMap = {
            "vi-VN": "Aoede",
            "en-GB": "Kore",
            "ja-JP": "Aoede",
            "ko-KR": "Kore",
            "zh-CN": "Zubenelgenubi",
        };

        // Global variables
        let firebaseData = null;
        let lastUpdateTime = 0;
        let autoRefresh = true;
        let autoRefreshInterval;
        let logEntries = [];
        const MAX_LOG_ENTRIES = 20;
        
        // Sentence construction variables
        let slot1 = "";
        let slot2 = "";
        let displayBuffer = "";
        let convertedCurrentWord = "";
        let sentenceWords = [];
        let fullSentence = "";
        let convertedFullSentence = "";
        
        // Flex sensor state
        let flexStates = [0, 0, 0, 0];
        let lastFlexStates = [-1, -1, -1, -1];
        let stableCount = 0;
        let lastDetectedIndex = -1;
        let holdStartMs = 0;
        let holdFired = false;
        const DEBOUNCE_COUNT = 3;
        const HOLD_MS_DEFAULT = 800;
        const POST_HOLD_COOLDOWN = 600;
        let lastActionMs = 0;
        
        // TTS Variables
        let audioCache = {};
        let currentAudio = null;
        let isSpeaking = false;
        let isConnecting = false;
        
        // Helper to convert PCM16 (L16) data to a playable WAV Blob
        function pcmToWav(base64PCM, sampleRate = 24000) {
            const binaryString = atob(base64PCM);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }

            const wavHeader = new ArrayBuffer(44);
            const view = new DataView(wavHeader);

            const writeString = (view, offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            writeString(view, 0, "RIFF");
            view.setUint32(4, 36 + len, true);
            writeString(view, 8, "WAVE");
            writeString(view, 12, "fmt ");
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, "data");
            view.setUint32(40, len, true);

            return new Blob([view, bytes], { type: "audio/wav" });
        }

        // Helper Functions
        function log(source, message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = { timestamp, source, message };
            
            logEntries.unshift(logEntry);
            if (logEntries.length > MAX_LOG_ENTRIES) {
                logEntries.pop();
            }
            
            updateLogDisplay();
        }

        function updateLogDisplay() {
            const logContainer = document.getElementById('logContainer');
            logContainer.innerHTML = logEntries.map(entry => 
                `<div class="log-entry">
                    <span style="color: #666; font-size: 0.8rem;">[${entry.timestamp}] ${entry.source}:</span>
                    <span style="color: #333;"> ${entry.message}</span>
                </div>`
            ).join('');
        }

        function clearLog() {
            logEntries = [];
            updateLogDisplay();
        }

        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            
            if (connected) {
                indicator.className = 'indicator online';
                statusText.textContent = 'Connected to Firebase';
            } else {
                indicator.className = 'indicator';
                statusText.textContent = 'Disconnected from Firebase';
            }
        }

        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        // Vietnamese Conversion Functions
        function convertVietnameseWord(encodedWord) {
            if (!encodedWord || encodedWord.length === 0) return "";
            
            const firstUnderscore = encodedWord.indexOf('_');
            if (firstUnderscore === -1) return encodedWord;
            
            const secondUnderscore = encodedWord.indexOf('_', firstUnderscore + 1);
            if (secondUnderscore === -1) return encodedWord;
            
            const consonant = encodedWord.substring(0, firstUnderscore);
            const middle = encodedWord.substring(firstUnderscore + 1, secondUnderscore);
            const vowelTypeStr = encodedWord.substring(secondUnderscore + 1);
            
            if (middle.length < 2) return encodedWord;
            
            const toneChar = middle[0];
            if (toneChar < '1' || toneChar > '6') return encodedWord;
            
            const tone = parseInt(toneChar);
            const vowelKey = middle.substring(1);
            
            let vowelType = 0;
            if (vowelTypeStr === "b") {
                vowelType = 1;
            } else if (vowelTypeStr === "p") {
                vowelType = 2;
            } else if (vowelTypeStr !== "s") {
                return encodedWord;
            }
            
            const tableIndex = (tone - 1) + (vowelType * 6);
            
            if (tableIndex < 0 || tableIndex >= 18) {
                return encodedWord;
            }
            
            const vowelKeyUpper = vowelKey.toUpperCase();
            
            for (let i = 0; i < vietnameseTable.length; i++) {
                if (vowelKeyUpper === vietnameseTable[i].key) {
                    const convertedVowel = vietnameseTable[i].forms[tableIndex];
                    return consonant + convertedVowel;
                }
            }
            
            return encodedWord;
        }

        function convertVietnameseText(encodedText) {
            if (!encodedText || encodedText.length === 0) return "";
            
            let result = "";
            let start = 0;
            let end = 0;
            
            while (end < encodedText.length) {
                end = encodedText.indexOf(' ', start);
                if (end === -1) {
                    end = encodedText.length;
                }
                
                const word = encodedText.substring(start, end);
                const convertedWord = convertVietnameseWord(word);
                
                if (result.length > 0) {
                    result += " ";
                }
                result += convertedWord;
                
                start = end + 1;
                if (start > encodedText.length) {
                    break;
                }
            }
            
            return result;
        }

        function updateConversions() {
            if (displayBuffer.length > 0) {
                convertedCurrentWord = convertVietnameseWord(displayBuffer);
            } else {
                convertedCurrentWord = "";
            }
            
            if (fullSentence.length > 0) {
                convertedFullSentence = convertVietnameseText(fullSentence);
            } else {
                convertedFullSentence = "";
            }
        }

        // Firebase Data Functions
        async function fetchFirebaseData() {
            try {
                const response = await fetch(FIREBASE_URL);
                if (!response.ok) throw new Error('Network response was not ok');
                
                const data = await response.json();
                firebaseData = data;
                lastUpdateTime = Date.now();
                
                updateConnectionStatus(true);
                updateDisplay(data);
                log('Firebase', 'Data updated successfully');
                
                return data;
            } catch (error) {
                console.error('Error fetching Firebase data:', error);
                updateConnectionStatus(false);
                log('Firebase', `Error: ${error.message}`);
                return null;
            }
        }

        function calculateFlexState(rawValue, sensorIndex) {
            const STRAIGHT_THRESHOLD = 150;
            const bentThresholds = [300, 450, 350, 300];
            
            if (rawValue <= STRAIGHT_THRESHOLD) {
                return 0;
            } else if (rawValue <= bentThresholds[sensorIndex]) {
                return 1;
            } else {
                return 2;
            }
        }

        function getMPUState(orientation, shakeState) {
            if (shakeState === "Shake Left") {
                return 6;
            } else if (shakeState === "Shake Right") {
                return 7;
            }
            
            switch(orientation) {
                case "Up": return 0;
                case "Down": return 1;
                case "Left": return 2;
                case "Right": return 3;
                case "Forward": return 4;
                case "Backward": return 5;
                default: return -1;
            }
        }

        function getMappingForIndices(mpuState, a0, a1, a2, a3) {
            if (mpuState < 0 || mpuState > 7) return null;
            
            if (a3 === 2) {
                if (a0 < 3 && a1 < 3 && a2 < 3) {
                    return tableC[a0][a1][a2];
                }
                return null;
            }
            
            const a3bin = a3 === 1 ? 1 : 0;
            if (a1 < 0 || a1 >= 3 || a2 < 0 || a2 >= 3) return null;
            
            const flatIndex = a1 * 3 + a2;
            
            if (flatIndex >= 0 && flatIndex < 9) {
                return a3bin === 0 ? tableA[mpuState][flatIndex] : tableB[mpuState][flatIndex];
            }
            
            return null;
        }

        function flexModeCharFromA0(a0) {
            switch(a0) {
                case 0: return 's';
                case 1: return 'b';
                case 2: return 'p';
                default: return 'x';
            }
        }

        function updateDisplay(data) {
            if (!data) return;
            
            document.getElementById('mpuOrientation').textContent = data.o || 'Unknown';
            document.getElementById('mpuShakeState').textContent = data.d || 'None';
            document.getElementById('isShaking').textContent = data.sf || 'NO';
            
            const flexValues = [data.f0 || 0, data.f1 || 0, data.f2 || 0, data.f3 || 0];
            
            for (let i = 0; i < 4; i++) {
                flexStates[i] = calculateFlexState(flexValues[i], i);
            }
            
            for (let i = 0; i < 4; i++) {
                const box = document.getElementById(`flex${i}-box`);
                box.textContent = flexStates[i];
                box.className = `flex-box active-${flexStates[i]}`;
            }
            
            document.getElementById('rawValues').textContent = flexValues.join(', ');
            document.getElementById('flexFormat').textContent = flexStates.join('');
            
            const updateTime = document.getElementById('lastUpdate');
            updateTime.textContent = `Last Firebase update: ${formatTime(Date.now())}`;
            document.getElementById('lastUpdateTime').textContent = formatTime(Date.now());
            
            processWordConstruction(data);
            
            updateUI();
        }

        function processWordConstruction(data) {
            const mpuState = getMPUState(data.o || "Unknown", data.d || "None");
            const a0 = flexStates[0];
            const a1 = flexStates[1];
            const a2 = flexStates[2];
            const a3 = flexStates[3];
            
            if (mpuState === lastDetectedIndex && 
                a0 === lastFlexStates[0] && 
                a1 === lastFlexStates[1] && 
                a2 === lastFlexStates[2] && 
                a3 === lastFlexStates[3]) {
                stableCount++;
            } else {
                stableCount = 1;
                lastDetectedIndex = mpuState;
                lastFlexStates = [...flexStates];
                holdStartMs = Date.now();
                holdFired = false;
            }
            
            if (stableCount >= DEBOUNCE_COUNT) {
                const held = Date.now() - holdStartMs;
                if (!holdFired && (Date.now() - lastActionMs) > POST_HOLD_COOLDOWN && held >= HOLD_MS_DEFAULT) {
                    performActionSlotLogic(mpuState, a0, a1, a2, a3);
                    holdFired = true;
                    lastActionMs = Date.now();
                }
            }
        }

        function performActionSlotLogic(mpu, a0, a1, a2, a3) {
            const mapping = getMappingForIndices(mpu, a0, a1, a2, a3);
            if (!mapping || mapping === "nullptr") return false;
            
            if (mapping === "_") {
                addWordToSentence();
                return true;
            }
            
            if (mapping === "COMMIT") {
                commitSentence();
                return true;
            }
            
            if (mapping === "<") {
                backspaceBuffer();
                updateDisplayBufferFromSlots();
                return true;
            }
            
            const isSlot1 = (a3 === 2);
            const held = Date.now() - holdStartMs;
            
            if (isSlot1 && stableCount >= DEBOUNCE_COUNT && held < HOLD_MS_DEFAULT) {
                const mode = flexModeCharFromA0(a0);
                slot2 = `${mapping}_${mode}`;
            } else if (isSlot1) {
                slot1 = `${mapping}_${mpu}`;
            } else {
                const mode = flexModeCharFromA0(a0);
                slot2 = `${mapping}_${mode}`;
            }
            
            updateDisplayBufferFromSlots();
            log('WORD', `Action performed: ${displayBuffer}`);
            return true;
        }

        function updateDisplayBufferFromSlots() {
            const oldBuffer = displayBuffer;
            displayBuffer = '';
            
            if (slot1) {
                displayBuffer += slot1.toLowerCase();
            }
            
            if (slot2) {
                displayBuffer += slot2.toLowerCase();
            }
            
            if (oldBuffer !== displayBuffer) {
                updateConversions();
                log('WORD', `Word updated: ${displayBuffer}`);
            }
            
            updateUI();
        }

        function updateUI() {
            document.getElementById('slot1').textContent = slot1 || '---';
            document.getElementById('slot2').textContent = slot2 || '---';
            document.getElementById('displayBuffer').textContent = displayBuffer || '---';
            document.getElementById('convertedCurrentWord').textContent = convertedCurrentWord || '---';
            document.getElementById('sentenceDisplay').textContent = fullSentence || '---';
            document.getElementById('convertedSentenceDisplay').textContent = convertedFullSentence || '---';
            document.getElementById('wordCount').textContent = sentenceWords.length;
            
            const wordListDiv = document.getElementById('wordList');
            if (sentenceWords.length > 0) {
                wordListDiv.innerHTML = sentenceWords.map(word => 
                    `<div class="word-item">${word}</div>`
                ).join('');
            } else {
                wordListDiv.innerHTML = 'No words yet';
            }
            
            document.getElementById('translationInput').value = convertedFullSentence || '';
            
            updateTTSButtons();
        }

        // Sentence Functions
        function addWordToSentence() {
            if (!displayBuffer) return;
            
            if (sentenceWords.length < 10) {
                sentenceWords.push(displayBuffer);
                updateFullSentence();
                log('SENTENCE', `Added word: '${displayBuffer}'`);
                
                slot1 = '';
                slot2 = '';
                displayBuffer = '';
                convertedCurrentWord = '';
                
                updateUI();
            } else {
                log('SENTENCE', 'Sentence full! Max 10 words reached.');
            }
        }

        function updateFullSentence() {
            fullSentence = sentenceWords.join(' ');
            convertedFullSentence = convertVietnameseText(fullSentence);
        }

        function commitSentence() {
            if (sentenceWords.length === 0) {
                log('SENTENCE', 'No words to commit!');
                return;
            }
            
            if (displayBuffer) {
                addWordToSentence();
            }
            
            log('SENTENCE', '=== COMMIT SENTENCE ===');
            log('SENTENCE', `Full sentence: ${fullSentence}`);
            log('CONVERSION', `Converted sentence: ${convertedFullSentence}`);
            
            sentenceWords.forEach((word, i) => {
                const convertedWord = convertVietnameseWord(word);
                log('SENTENCE', `Word ${i + 1}: ${word} -> ${convertedWord}`);
            });
            
            resetSentence();
        }

        function resetSentence() {
            sentenceWords = [];
            fullSentence = '';
            convertedFullSentence = '';
            slot1 = '';
            slot2 = '';
            displayBuffer = '';
            convertedCurrentWord = '';
            
            log('SENTENCE', 'Sentence reset - ready for new input');
            updateUI();
        }

        function clearCurrentWord() {
            slot1 = '';
            slot2 = '';
            displayBuffer = '';
            convertedCurrentWord = '';
            updateUI();
            log('WORD', 'Current word cleared');
        }

        function backspaceBuffer() {
            if (displayBuffer.length > 0) {
                displayBuffer = displayBuffer.slice(0, -1);
                updateConversions();
                log('WORD', `Backspace - Buffer: ${displayBuffer}`);
            }
        }

        function backspace() {
            backspaceBuffer();
            updateUI();
        }

        // Translation Functions
        let translationCache = {};
        let lastTranslationTime = 0;
        const TRANSLATION_COOLDOWN = 2000;

        async function translateSentence() {
            const textarea = document.getElementById('translationInput');
            const text = textarea.value.trim();
            const targetLang = document.getElementById('targetLanguage').value;
            const outputDiv = document.getElementById('translationOutput');
            
            if (!text) {
                outputDiv.innerHTML = '<span style="color: #F44336;">Please enter text to translate!</span>';
                outputDiv.className = 'conversion-display error';
                return;
            }
            
            const now = Date.now();
            if (now - lastTranslationTime < TRANSLATION_COOLDOWN) {
                outputDiv.innerHTML = '<span style="color: #FF9800;">Please wait before translating again...</span>';
                outputDiv.className = 'conversion-display';
                return;
            }
            
            const cacheKey = text + '|' + targetLang;
            if (translationCache[cacheKey]) {
                outputDiv.innerHTML = translationCache[cacheKey];
                outputDiv.className = 'conversion-display success';
                lastTranslationTime = now;
                return;
            }
            
            outputDiv.innerHTML = '<span class="loading">Translating with AI... ‚è≥</span>';
            outputDiv.className = 'conversion-display loading';
            
            try {
                const langMap = {
                    'en-GB': 'en',
                    'ja-JP': 'ja',
                    'ko-KR': 'ko',
                    'zh-CN': 'zh'
                };
                
                const langCode = langMap[targetLang] || 'en';
                const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=vi|${langCode}`);
                const data = await response.json();
                
                if (data.responseStatus === 200 && data.responseData) {
                    const translated = data.responseData.translatedText;
                    translationCache[cacheKey] = translated;
                    outputDiv.innerHTML = translated;
                    outputDiv.className = 'conversion-display success';
                    lastTranslationTime = Date.now();
                    log('TRANSLATION', `Translated to ${targetLang}: ${translated}`);
                } else {
                    throw new Error('Translation failed');
                }
            } catch (error) {
                console.error('Translation error:', error);
                outputDiv.innerHTML = '<span style="color: #F44336;">Translation service unavailable. Please try again later.</span>';
                outputDiv.className = 'conversion-display error';
            }
        }

        function clearTranslation() {
            document.getElementById('translationOutput').innerHTML = 'Waiting for translation...';
            document.getElementById('translationOutput').className = 'conversion-display';
            translationCache = {};
        }

        // Phrase Suggestion Functions
        function initPhraseSuggestions() {
            const phrasePills = document.getElementById('phrasePills');
            phrasePills.innerHTML = '';
            
            commonPhrases.forEach((phrase, index) => {
                const pill = document.createElement('div');
                pill.className = 'phrase-pill';
                pill.textContent = phrase;
                pill.onclick = () => {
                    document.getElementById('translationInput').value = phrase;
                    translateSentence();
                    log('PHRASE', `Selected phrase: ${phrase}`);
                };
                phrasePills.appendChild(pill);
            });
        }

        function handleTranslationInputChange() {
            const textarea = document.getElementById('translationInput');
            const text = textarea.value;
            
            updateTTSButtons();
        }

        // TTS Functions
        async function speakWithRetry(text, langCode, retries = 5) {
            const apiKeyInput = document.getElementById('apiKeyInput');
            const apiKey = apiKeyInput.value.trim();
            
            if (!apiKey) {
                throw new Error('API_KEY_MISSING');
            }
            
            const voiceName = voiceMap[langCode] || "Kore";
            
            for (let i = 0; i < retries; i++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000);

                    const response = await fetch(
                        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`,
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            signal: controller.signal,
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: text }] }],
                                generationConfig: {
                                    responseModalities: ["AUDIO"],
                                    speechConfig: {
                                        voiceConfig: { prebuiltVoiceConfig: { voiceName } },
                                    },
                                },
                            }),
                        }
                    );

                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(`API_ERROR_${response.status}: ${errorData?.error?.message || response.statusText}`);
                    }

                    const data = await response.json();
                    const inlineData = data.candidates?.[0]?.content?.parts?.[0]?.inlineData;
                    
                    if (!inlineData || !inlineData.data) {
                        throw new Error("NO_DATA");
                    }

                    return inlineData.data;
                } catch (err) {
                    if (i === retries - 1) throw err;
                    const delay = Math.pow(2, i) * 1000;
                    await new Promise(r => setTimeout(r, delay));
                }
            }
        }

        async function speakText(langType) {
            if (isSpeaking) {
                stopSpeaking();
                return;
            }
            
            let text = '';
            let langCode = '';
            
            if (langType === 'vi-VN') {
                text = document.getElementById('translationInput').value.trim();
                langCode = 'vi-VN';
            } else if (langType === 'translation') {
                const outputDiv = document.getElementById('translationOutput');
                text = outputDiv.textContent.trim();
                if (text === 'Waiting for translation...' || text.includes('Please enter') || text.includes('Translation service')) {
                    showTTSStatus('No valid translation to speak', 'error');
                    return;
                }
                langCode = document.getElementById('targetLanguage').value;
            }
            
            if (!text) {
                showTTSStatus('No text to speak', 'error');
                return;
            }
            
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            if (!apiKey) {
                showTTSStatus('Please enter Gemini API key for TTS', 'error');
                return;
            }
            
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            
            const cacheKey = `${langCode}:${text}`;
            if (audioCache[cacheKey]) {
                playAudioFromCache(cacheKey, langCode);
                return;
            }
            
            isSpeaking = true;
            isConnecting = true;
            updateTTSButtons();
            showTTSStatus('Connecting to TTS service...', 'loading');
            
            try {
                const audioDataBase64 = await speakWithRetry(text, langCode);
                const wavBlob = pcmToWav(audioDataBase64, 24000);
                const audioUrl = URL.createObjectURL(wavBlob);
                
                audioCache[cacheKey] = audioUrl;
                
                isConnecting = false;
                showTTSStatus('Playing audio...', 'success');
                
                const audio = new Audio(audioUrl);
                currentAudio = audio;
                audio.onended = () => {
                    isSpeaking = false;
                    updateTTSButtons();
                    showTTSStatus('Ready', 'success');
                };
                
                audio.onerror = () => {
                    isSpeaking = false;
                    updateTTSButtons();
                    showTTSStatus('Audio playback error', 'error');
                };
                
                audio.play().catch(e => {
                    console.error("Audio Playback Error:", e);
                    isSpeaking = false;
                    updateTTSButtons();
                    showTTSStatus('Playback failed', 'error');
                });
                
            } catch (err) {
                isSpeaking = false;
                isConnecting = false;
                updateTTSButtons();
                
                if (err.message.includes('API_KEY_MISSING')) {
                    showTTSStatus('Please enter valid Gemini API key', 'error');
                } else if (err.message.includes('API_ERROR_')) {
                    showTTSStatus('TTS API error. Check API key and quota.', 'error');
                } else {
                    showTTSStatus('TTS service unavailable. Try again.', 'error');
                }
                console.error("TTS Failed:", err);
            }
            
            updateTTSButtons();
        }

        function playAudioFromCache(cacheKey, langCode) {
            isSpeaking = true;
            updateTTSButtons();
            showTTSStatus('Playing from cache...', 'success');
            
            const audio = new Audio(audioCache[cacheKey]);
            currentAudio = audio;
            
            audio.onended = () => {
                isSpeaking = false;
                updateTTSButtons();
                showTTSStatus('Ready', 'success');
            };
            
            audio.onerror = () => {
                isSpeaking = false;
                updateTTSButtons();
                showTTSStatus('Audio playback error', 'error');
            };
            
            audio.play().catch(e => {
                console.error("Audio Playback Error:", e);
                isSpeaking = false;
                updateTTSButtons();
                showTTSStatus('Playback failed', 'error');
            });
        }

        function stopSpeaking() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            isSpeaking = false;
            isConnecting = false;
            updateTTSButtons();
            showTTSStatus('Stopped', 'success');
        }

        function showTTSStatus(message, type) {
            const statusDiv = document.getElementById('ttsStatus');
            statusDiv.textContent = message;
            statusDiv.className = `tts-status ${type}`;
            
            if (type !== 'loading') {
                setTimeout(() => {
                    statusDiv.textContent = '';
                    statusDiv.className = 'tts-status';
                }, 3000);
            }
        }

        function updateTTSButtons() {
            const speakOriginalBtn = document.getElementById('speakOriginalBtn');
            const speakTranslatedBtn = document.getElementById('speakTranslatedBtn');
            const stopBtn = document.getElementById('stopSpeakingBtn');
            
            const hasOriginalText = document.getElementById('translationInput').value.trim().length > 0;
            const hasTranslatedText = document.getElementById('translationOutput').textContent.trim().length > 0 && 
                                    !document.getElementById('translationOutput').textContent.includes('Waiting for') &&
                                    !document.getElementById('translationOutput').textContent.includes('Please enter') &&
                                    !document.getElementById('translationOutput').textContent.includes('Translation service');
            
            speakOriginalBtn.disabled = !hasOriginalText || isConnecting;
            speakTranslatedBtn.disabled = !hasTranslatedText || isConnecting;
            stopBtn.disabled = !isSpeaking;
            
            if (isSpeaking) {
                speakOriginalBtn.innerHTML = '<span>‚è∏</span> Speaking...';
                speakOriginalBtn.disabled = false;
                speakTranslatedBtn.innerHTML = '<span>‚è∏</span> Speaking...';
                speakTranslatedBtn.disabled = false;
            } else {
                speakOriginalBtn.innerHTML = '<span>üîä</span> Speak Vietnamese';
                speakTranslatedBtn.innerHTML = '<span>üîä</span> Speak Translated';
            }
        }

        // Control Functions
        function refreshData() {
            fetchFirebaseData();
        }

        function toggleAutoRefresh() {
            autoRefresh = !autoRefresh;
            const btn = document.getElementById('autoRefreshBtn');
            
            if (autoRefresh) {
                btn.textContent = 'Auto: ON';
                btn.className = 'green';
                autoRefreshInterval = setInterval(fetchFirebaseData, 2000);
                log('SYSTEM', 'Auto-refresh enabled');
            } else {
                btn.textContent = 'Auto: OFF';
                btn.className = 'red';
                clearInterval(autoRefreshInterval);
                log('SYSTEM', 'Auto-refresh disabled');
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            log('SYSTEM', 'Application started');
            fetchFirebaseData();
            initPhraseSuggestions();
            updateTTSButtons();
            toggleAutoRefresh();
        });
    </script>
</body>
</html>
