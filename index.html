<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gangtay — Simple Poll + Play (auto-start)</title>
<style>
  body{font-family:system-ui,Arial;padding:16px;max-width:900px;margin:auto}
  label{display:block;margin-top:10px;font-weight:600}
  input, button {padding:8px; margin:6px 0; width:100%; box-sizing:border-box}
  .row{display:flex; gap:8px; flex-wrap:wrap}
  .half{flex:1 1 48%}
  #log{white-space:pre-wrap;background:#f6f6f6;padding:10px;border-radius:6px;font-family:monospace;max-height:320px;overflow:auto}
  .manual{background:#ff4757;color:white;border:none;padding:10px;border-radius:6px}
</style>
</head>
<body>
  <h2>Gangtay — Simple Poll + Play (auto-start)</h2>

  <label>T1.TXT (upload local) / or put T1.TXT at site root</label>
  <input id="fileInput" type="file" accept=".txt"/>

  <label>Audio base URL (folder containing 0001.mp3, 0002.mp3 ...)</label>
  <input id="audioBase" value="/audio/" />

  <label>Firebase message.json URL</label>
  <input id="firebaseUrl" value="https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json" />

  <div class="row">
    <button id="enableBtn" class="half">Enable audio & Play preview (1x)</button>
    <button id="stopBtn" class="half">Stop polling</button>
  </div>

  <div class="row">
    <button id="previewBtn" class="half">Preview 0001</button>
    <button id="manualPlay" class="half manual" style="display:none">Manual Play (tap once)</button>
  </div>

  <div style="margin-top:8px;">
    <label>Options</label>
    <div class="row">
      <div class="half"><label><input id="allowReplay" type="checkbox" checked> Allow duplicates</label></div>
      <div class="half"><label>Poll interval ms: <input id="pollMs" type="number" value="500" min="100" style="width:100%"></label></div>
    </div>
  </div>

  <div id="status">Status: idle</div>
  <div id="log"></div>

<script>
/*
  Behavior changes:
  - Polling AUTO-STARTS on page open.
  - "Enable audio & Play preview (1x)" only unlocks audio & plays preview once (no repeated start).
  - Stop button stops polling; Refresh page to restart auto-polling.
  - Allow duplicates checkbox controls whether identical payloads (JSON string-equal) will replay.
  - Simpler playback to reduce "Audio element error".

  Replace your index.html with this file.
*/

const fileInput = document.getElementById('fileInput');
const audioBaseEl = document.getElementById('audioBase');
const firebaseUrlEl = document.getElementById('firebaseUrl');
const enableBtn = document.getElementById('enableBtn');
const stopBtn = document.getElementById('stopBtn');
const previewBtn = document.getElementById('previewBtn');
const manualBtn = document.getElementById('manualPlay');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
const allowReplayEl = document.getElementById('allowReplay');
const pollMsEl = document.getElementById('pollMs');

let lines = [];
let pollingActive = false;
let pollIntervalId = null;
let inFlight = false;
let audioCtx = null;
let masterGain = null;
let currentAudio = null;
let isPlaying = false;
let queue = [];
let previewPlayed = false;
let lastPayloadStr = null; // for dedupe when allowReplay is false

// Helpers
function now(){ return new Date().toLocaleTimeString(); }
function log(s){ logEl.textContent = '['+now()+'] '+s + '\n' + logEl.textContent; }
function setStatus(s){ statusEl.textContent = 'Status: ' + s; log(s); }
function pad4(n){ return String(n).padStart(4,'0'); }

// Load T1.TXT from uploader
fileInput.addEventListener('change', async (e) => {
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  setStatus('Reading ' + f.name);
  try {
    const txt = await f.text();
    lines = txt.split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
    setStatus('Loaded ' + lines.length + ' lines from ' + f.name);
  } catch(err) { setStatus('Read failed: ' + err.message); }
});

// Audio context & decoder
function ensureAudioCtx(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 1.0;
  masterGain.connect(audioCtx.destination);
  log('AudioContext created');
}
function decodeAudioDataCompat(ab){
  return new Promise((resolve, reject) => {
    try {
      const p = audioCtx.decodeAudioData(ab);
      if (p && typeof p.then === 'function') {
        p.then(resolve).catch(err => {
          try { audioCtx.decodeAudioData(ab, resolve, reject); } catch(cbErr) { reject(err || cbErr); }
        });
        return;
      }
    } catch(e){}
    try { audioCtx.decodeAudioData(ab, resolve, reject); } catch(e) { reject(e); }
  });
}

// fetch timeout
async function fetchWithTimeout(url, timeout = 4000){
  const ctrl = new AbortController();
  const id = setTimeout(()=>ctrl.abort(), timeout);
  try {
    const r = await fetch(url, { signal: ctrl.signal, cache: 'no-store' });
    clearTimeout(id);
    return r;
  } catch(e) { clearTimeout(id); throw e; }
}

// playback: use <audio> element first (simple). If element rejected/error -> try one fetch+decode fallback.
async function playFileByIndex(idx) {
  if (idx <= 0) { log('Invalid index ' + idx); return; }
  const fname = pad4(idx) + '.mp3';
  let base = (audioBaseEl.value || '/audio/').trim();
  if (!base.endsWith('/')) base += '/';
  // build url: if startsWith http -> use; else if startsWith / -> origin + base; else origin + '/' + base
  let url;
  if (/^https?:\/\//i.test(base)) url = base + fname;
  else if (base.startsWith('/')) url = location.origin + base + fname;
  else url = location.origin + '/' + base + fname;
  url += '?ts=' + Date.now();

  ensureAudioCtx();

  // create audio element (do NOT attach to AudioContext directly — simpler, avoids some iOS bugs)
  const a = new Audio(url);
  a.crossOrigin = 'anonymous';
  a.preload = 'auto';

  setStatus('Play request: ' + fname);
  isPlaying = true;

  // cleanup currentAudio only when we are starting a new one (but avoid aggressive pause which can trigger errors)
  if (currentAudio && currentAudio !== a) {
    try { currentAudio.onended = null; currentAudio.onerror = null; } catch(e){}
  }
  currentAudio = a;

  // onended handler
  a.onended = () => {
    isPlaying = false;
    setStatus('Finished ' + fname);
    flushQueue();
  };

  // onerror: try fallback (fetch+decode) once
  a.onerror = async () => {
    log('Audio element error ' + fname + ' — trying fetch+decode fallback');
    try {
      const r = await fetchWithTimeout(url, 4000);
      if (!r.ok) throw new Error('fetch status ' + r.status);
      const ab = await r.arrayBuffer();
      const buf = await decodeAudioDataCompat(ab);
      const src = audioCtx.createBufferSource();
      src.buffer = buf;
      src.connect(masterGain);
      src.onended = () => { isPlaying = false; setStatus('Finished via buffer ' + fname); flushQueue(); };
      src.start(0);
      setStatus('Playing via buffer: ' + fname);
    } catch(err) {
      log('Fallback failed for ' + fname + ': ' + (err && err.message ? err.message : err));
      isPlaying = false;
      flushQueue();
      // show manual unlock
      manualBtn.style.display = 'inline-block';
      manualBtn.focus();
    }
  };

  // try to play element
  try {
    await a.play();
    setStatus('Element play started: ' + fname);
  } catch(err) {
    log('Element play rejected (autoplay?) — trying fetch+decode fallback: ' + (err && err.message ? err.message : err));
    // attempt fallback once
    try {
      const r = await fetchWithTimeout(url, 4000);
      if (!r.ok) throw new Error('fetch status ' + r.status);
      const ab = await r.arrayBuffer();
      ensureAudioCtx();
      const buf = await decodeAudioDataCompat(ab);
      const src = audioCtx.createBufferSource();
      src.buffer = buf;
      src.connect(masterGain);
      src.onended = () => { isPlaying = false; setStatus('Finished via buffer ' + fname); flushQueue(); };
      src.start(0);
      setStatus('Playing via buffer: ' + fname);
    } catch(e) {
      log('Fallback decode failed: ' + (e && e.message ? e.message : e));
      isPlaying = false;
      flushQueue();
      manualBtn.style.display = 'inline-block';
      manualBtn.focus();
    }
  }
}

// queue behavior
function queueOrPlayIndex(idx) {
  if (isPlaying) {
    queue.push(idx);
    log('Queued index ' + idx + ' (queue len ' + queue.length + ')');
  } else {
    playFileByIndex(idx);
  }
}
function flushQueue() {
  if (!isPlaying && queue.length > 0) {
    const next = queue.shift();
    playFileByIndex(next);
  }
}

// find index in T1.TXT (exact match, case-insensitive)
function findIndexForText(text){
  if (!text) return -1;
  const k = text.trim().toLowerCase();
  for (let i=0;i<lines.length;i++){
    if ((lines[i]||'').toLowerCase() === k) return i+1;
  }
  return -1;
}

// Poll step: get message.json, handle payload
async function pollStep() {
  if (!pollingActive) return;
  if (inFlight) return; // avoid overlap
  const url = (firebaseUrlEl.value || '').trim();
  if (!url) { log('No Firebase URL set'); return; }
  inFlight = true;
  try {
    const r = await fetchWithTimeout(url, 4000);
    if (!r.ok) { log('Firebase fetch failed: ' + r.status); inFlight = false; return; }
    const j = await r.json();
    if (!j) { inFlight = false; return; }

    // dedupe when allowReplay unchecked:
    const payloadStr = JSON.stringify(j);
    if (!allowReplayEl.checked) {
      if (payloadStr === lastPayloadStr) {
        // skip repeated identical payload
        inFlight = false;
        return;
      }
      lastPayloadStr = payloadStr;
    }

    log('Firebase message: ' + payloadStr);

    // handle index or text
    if (typeof j.index === 'number') {
      queueOrPlayIndex(j.index);
    } else if (typeof j.text === 'string') {
      const idx = findIndexForText(j.text);
      if (idx > 0) queueOrPlayIndex(idx);
      else log('Text not found in T1.TXT: "' + j.text + '"');
    } else {
      log('Unrecognized payload');
    }
  } catch(err) {
    log('Poll error: ' + (err && err.name ? err.name : err));
  } finally {
    inFlight = false;
  }
}

// start/stop polling
function startPolling() {
  if (pollingActive) { log('Polling already active'); return; }
  const ms = Math.max(100, Number(pollMsEl.value) || 500);
  pollingActive = true;
  pollIntervalId = setInterval(pollStep, ms);
  setStatus('Polling started every ' + ms + ' ms (auto-start)');
}
function stopPolling() {
  if (!pollingActive) { log('Polling not active'); return; }
  pollingActive = false;
  if (pollIntervalId) { clearInterval(pollIntervalId); pollIntervalId = null; }
  setStatus('Polling stopped');
}

// preview (play 0001 once)
async function playPreviewOnce(){
  if (previewPlayed) return;
  previewPlayed = true;
  ensureAudioCtx();
  if (isPlaying) return;
  const base = (audioBaseEl.value || '/audio/').trim();
  let url;
  if (/^https?:\/\//i.test(base)) url = base + '0001.mp3';
  else if (base.startsWith('/')) url = location.origin + base + '0001.mp3';
  else url = location.origin + '/' + base + '0001.mp3';
  url += '?ts=' + Date.now();
  const a = new Audio(url);
  a.crossOrigin = 'anonymous';
  try { await a.play(); setStatus('Preview started'); currentAudio = a; a.onended = ()=> setStatus('Preview finished'); }
  catch(e) { log('Preview element blocked -> tone unlock'); await unlockTone(); }
}

// small tone to unlock
async function unlockTone(){
  ensureAudioCtx();
  const nowt = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine'; o.frequency.value = 880;
  g.gain.value = 0.0001;
  o.connect(g); g.connect(masterGain);
  g.gain.setValueAtTime(0.0001, nowt);
  g.gain.linearRampToValueAtTime(0.06, nowt + 0.01);
  o.start(nowt);
  g.gain.linearRampToValueAtTime(0.0001, nowt + 0.12);
  o.stop(nowt + 0.13);
  try{ await audioCtx.resume(); } catch(e){}
  await new Promise(r=>setTimeout(r, 180));
}

// unlock attempt sequence
async function tryUnlockSequence(){
  if (!audioCtx) ensureAudioCtx();
  try {
    if (audioCtx.state === 'running') return true;
    // try muted audio element
    const a = new Audio();
    a.muted = true;
    try { await a.play(); } catch(e){}
    if (audioCtx.state === 'running') return true;
    await unlockTone();
    return audioCtx.state === 'running';
  } catch(e) { return false; }
}

// UI wiring
enableBtn.addEventListener('click', async () => {
  setStatus('Enable pressed — unlocking audio & preview (1x)');
  // attach one-time gesture unlocks in case of mobile
  document.addEventListener('touchstart', ()=>tryUnlockSequence(), {once:true, passive:true});
  document.addEventListener('click', ()=>tryUnlockSequence(), {once:true});
  const ok = await tryUnlockSequence();
  if (!ok) { setStatus('Audio locked — press Manual Play once'); manualBtn.style.display='inline-block'; manualBtn.focus(); }
  await playPreviewOnce();   // only plays once per page load
  // NOTE: do NOT start polling here; polling already auto-started on load.
  enableBtn.disabled = true;
});

stopBtn.addEventListener('click', () => {
  stopPolling();
  enableBtn.disabled = false;
});

// Manual unlock button
manualBtn.addEventListener('click', async () => {
  const ok = await tryUnlockSequence();
  if (ok) { manualBtn.style.display='none'; setStatus('Unlocked'); }
  else setStatus('Manual unlock failed');
});

previewBtn.addEventListener('click', ()=>{ playPreviewOnce(); });

// boot: try to load T1.TXT and auto-start polling
(async function init(){
  // try fetch T1.TXT from site root
  try {
    const r = await fetch('/T1.TXT', {cache:'no-store'});
    if (r.ok) {
      const t = await r.text();
      lines = t.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
      setStatus('Loaded T1.TXT ' + lines.length + ' lines');
    } else {
      setStatus('T1.TXT not found on site (upload or use file input)');
    }
  } catch(e){ setStatus('T1.TXT fetch failed'); }

  // auto-start polling right away
  startPolling();
  // do an immediate poll once (avoid waiting first interval)
  pollStep();
})();

</script>
</body>
</html>
