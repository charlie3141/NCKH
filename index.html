<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gangtay — auto play from Firebase</title>
<style>
  body{font-family:system-ui,Arial;padding:18px;max-width:900px;margin:auto}
  h1{font-size:1.3rem;margin-bottom:.2rem}
  .muted{color:#666;font-size:.9rem}
  label{display:block;margin-top:10px;font-weight:600}
  input[type="text"], input[type="url"]{width:100%;padding:8px;margin-top:6px;box-sizing:border-box}
  button{padding:10px 14px;margin:8px 6px;font-size:1rem}
  .row{display:flex;gap:8px;align-items:center;margin-top:8px}
  #status{margin-top:10px;color:#333}
  #log{white-space:pre-wrap;font-family:monospace;margin-top:10px;background:#f6f6f6;padding:8px;border-radius:6px;max-height:240px;overflow:auto}
  .controls{display:flex;gap:8px;align-items:center;margin-top:8px}
</style>
</head>
<body>
  <h1>Gangtay — Auto Play từ Firebase</h1>
  <p class="muted">Nhấn <strong>Enable audio & Start</strong> 1 lần để cấp quyền phát âm thanh. Sau đó trang sẽ poll Firebase mỗi 1s và tự phát file tương ứng.</p>

  <label>1) T1.TXT (mỗi dòng 1 từ) — site root /T1.TXT hoặc upload local</label>
  <div class="row">
    <input type="file" id="fileInput" accept=".txt">
    <button id="reloadTxt">Try fetch /T1.TXT</button>
  </div>
  <div id="txtInfo" class="muted">Trying to fetch /T1.TXT ...</div>

  <label>2) Audio base path (relative or absolute)</label>
  <input id="audioBase" type="text" value="/audio/" />

  <label>3) Firebase message URL (will poll automatically after Enable)</label>
  <input id="firebaseUrl" type="url" value="https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json" />

  <div class="row">
    <button id="enableBtn">Enable audio & Start polling</button>
    <button id="stopBtn" disabled>Stop polling</button>
    <button id="previewBtn">Preview 0001</button>
  </div>

  <label>Volume (gain)</label>
  <div class="controls">
    <input id="gainSlider" type="range" min="0.2" max="4.0" step="0.05" value="1.2">
    <div id="gainVal">Gain x1.20</div>
  </div>

  <div id="status">Status: idle</div>
  <div id="log"></div>

<script>
/*
  Auto-play page:
  - Click Enable audio & Start polling once (user gesture)
  - Polls FIREBASE_URL and expects JSON: either { text: "...", ts: ... } OR { index: N, ts: ... }
  - If text provided: searches T1.TXT for exact match (case-insensitive) and plays /audio/XXXX.mp3 (XXXX = 0001..9999)
  - If index provided: directly plays /audio/XXXX.mp3 (no lookup)
*/

const FIREBASE_DEFAULT = "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json";
const POLL_INTERVAL_MS = 1000; // 1s

// UI
const fileInput = document.getElementById('fileInput');
const reloadTxtBtn = document.getElementById('reloadTxt');
const txtInfo = document.getElementById('txtInfo');
const audioBaseEl = document.getElementById('audioBase');
const firebaseUrlEl = document.getElementById('firebaseUrl');
const enableBtn = document.getElementById('enableBtn');
const stopBtn = document.getElementById('stopBtn');
const previewBtn = document.getElementById('previewBtn');
const gainSlider = document.getElementById('gainSlider');
const gainVal = document.getElementById('gainVal');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');

let lines = []; // from T1.TXT
let pollHandle = null;
let lastTs = null;
let audioCtx = null;
let masterGain = null;
let currentAudio = null;

function log(msg) {
  const t = new Date().toLocaleTimeString();
  logEl.textContent = `[${t}] ${msg}\n` + logEl.textContent;
}
function setStatus(s) { statusEl.textContent = 'Status: ' + s; log(s); }
function pad4(n){ return String(n).padStart(4,'0'); }

// load /T1.TXT from site root
async function fetchRemoteTxt() {
  setStatus('Fetching /T1.TXT ...');
  try {
    const r = await fetch('/T1.TXT', { cache: 'no-store' });
    if (!r.ok) { setStatus('/T1.TXT not found on site (HTTP ' + r.status + ')'); return false; }
    const txt = await r.text();
    parseTxt(txt);
    setStatus(`Loaded /T1.TXT (${lines.length} entries)`);
    return true;
  } catch (err) {
    setStatus('Fetch /T1.TXT failed: ' + err.message);
    return false;
  }
}
function parseTxt(txt) {
  const raw = txt.split(/\r?\n/);
  lines = raw.map(l => l.trim()).filter(l => l.length>0);
  log('Parsed lines: ' + lines.length);
}

// local file input
fileInput.addEventListener('change', async (ev) => {
  const f = ev.target.files && ev.target.files[0];
  if (!f) return;
  setStatus('Reading local file ' + f.name);
  try {
    const txt = await f.text();
    parseTxt(txt);
    setStatus(`Loaded local ${f.name} (${lines.length} lines)`);
  } catch (err) {
    setStatus('Read file failed: ' + err.message);
  }
});
reloadTxtBtn.addEventListener('click', fetchRemoteTxt);

// audio context and gain
function ensureAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = parseFloat(gainSlider.value || 1.0);
  masterGain.connect(audioCtx.destination);
  log('AudioContext created. base gain=' + masterGain.gain.value.toFixed(2));
}
gainSlider.addEventListener('input', () => {
  const v = parseFloat(gainSlider.value);
  gainVal.textContent = `Gain x${v.toFixed(2)}`;
  if (masterGain) masterGain.gain.setValueAtTime(v, audioCtx.currentTime);
});

// create and connect <audio> element to WebAudio
function makeAudioElement(url) {
  ensureAudio();
  const a = new Audio(url);
  a.crossOrigin = "anonymous";
  try {
    // disconnect previous if any
    if (currentAudio && currentAudio.mediaSource) {
      try { currentAudio.mediaSource.disconnect(); } catch(e) {}
      currentAudio.mediaSource = null;
    }
    const src = audioCtx.createMediaElementSource(a);
    src.connect(masterGain);
    a._mediaSource = src;
  } catch (err) {
    // cross-origin or already connected issues, fall back to element volume
    console.warn('MediaElementSource failed:', err);
    a.volume = parseFloat(gainSlider.value);
  }
  return a;
}

async function playFileByIndex(idx) {
  if (idx <= 0) { setStatus('Invalid index'); return; }
  const name = pad4(idx) + '.mp3';
  let base = audioBaseEl.value.trim() || '/audio/';
  if (!base.endsWith('/')) base += '/';
  const url = (base.startsWith('http') ? base : base) + name + '?ts=' + Date.now();
  setStatus('Playing ' + name + ' → ' + url);
  try {
    if (currentAudio) { try { currentAudio.pause(); } catch(e){} currentAudio = null; }
    const a = makeAudioElement(url);
    currentAudio = a;
    // resume audio context if suspended
    if (audioCtx && audioCtx.state === 'suspended') try { await audioCtx.resume(); } catch(e){}
    // play
    await a.play();
    a.onended = () => setStatus('Finished ' + name);
    a.onerror = () => setStatus('Playback error ' + name);
  } catch (err) {
    setStatus('Play failed: ' + err.message);
    console.error(err);
  }
}

// search text in lines -> 1-based index
function findIndexForText(text) {
  if (!text) return -1;
  const k = text.trim().toLowerCase();
  for (let i=0;i<lines.length;i++){
    if ((lines[i]||'').toLowerCase() === k) return i+1;
  }
  return -1;
}

// handle incoming firebase payload
async function handleMessageObject(obj) {
  if (!obj) return;
  // if contains index field, use it directly
  if (typeof obj.index === 'number') {
    await playFileByIndex(obj.index);
    return;
  }
  // otherwise use text lookup
  const text = (typeof obj.text === 'string') ? obj.text : (typeof obj.message === 'string' ? obj.message : null);
  if (!text) return;
  const idx = findIndexForText(text);
  if (idx > 0) {
    await playFileByIndex(idx);
  } else {
    setStatus(`Text not found in T1.TXT: "${text}"`);
    log('Received text not found: ' + text);
  }
}

// polling loop
async function pollOnce() {
  const url = (firebaseUrlEl.value.trim() || FIREBASE_DEFAULT);
  try {
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) { setStatus('Firebase fetch failed: ' + r.status); return; }
    const j = await r.json();
    // detect change via ts or whole object string
    const t = j && (j.ts || j.timestamp || JSON.stringify(j));
    if (!t) return;
    if (String(t) !== String(lastTs)) {
      lastTs = t;
      log('New firebase message: ' + JSON.stringify(j));
      await handleMessageObject(j);
    }
  } catch (err) {
    console.warn('poll error', err);
    setStatus('Poll error: ' + err.message);
  }
}

// start / stop polling
enableBtn.addEventListener('click', async () => {
  // user gesture: create/resume audio context
  ensureAudio();
  try { if (audioCtx && audioCtx.state === 'suspended') await audioCtx.resume(); } catch(e){}
  // try load remote T1.TXT if empty
  if (!lines.length) await fetchRemoteTxt();
  // start poll
  if (!pollHandle) {
    pollHandle = setInterval(pollOnce, POLL_INTERVAL_MS);
    setStatus('Polling started (every ' + (POLL_INTERVAL_MS/1000) + 's)');
    enableBtn.disabled = true;
    stopBtn.disabled = false;
  }
});
stopBtn.addEventListener('click', () => {
  if (pollHandle) { clearInterval(pollHandle); pollHandle = null; setStatus('Polling stopped'); enableBtn.disabled = false; stopBtn.disabled = true; }
});
previewBtn.addEventListener('click', () => { ensureAudio(); playFileByIndex(1); });

// init: try load remote T1.TXT
(async function init(){
  firebaseUrlEl.value = firebaseUrlEl.value || FIREBASE_DEFAULT;
  const ok = await fetchRemoteTxt();
  if (!ok) txtInfo.textContent = '/T1.TXT not found on server — upload local file or add to site.';
  else txtInfo.textContent = `Loaded /T1.TXT (${lines.length} entries)`;
  setStatus('Ready. Click "Enable audio & Start polling" to begin (one user gesture required).');
})();
</script>
</body>
</html>
