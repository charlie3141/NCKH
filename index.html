<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gangtay — Stable Auto Play (dedupe + debug)</title>
<style>
  body{font-family:system-ui,Arial;padding:18px;max-width:980px;margin:auto}
  h1{font-size:1.2rem}
  .muted{color:#666;font-size:.9rem}
  label{display:block;margin-top:10px;font-weight:600}
  input[type="text"], input[type="url"]{width:100%;padding:8px;margin-top:6px;box-sizing:border-box}
  button{padding:10px 14px;margin:8px 6px;font-size:1rem}
  .row{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
  #status{margin-top:10px;color:#333}
  #log{white-space:pre-wrap;font-family:monospace;margin-top:10px;background:#f6f6f6;padding:10px;border-radius:6px;max-height:340px;overflow:auto}
  .bigManual{background:#ff4757;color:white;border:none;padding:12px 18px;font-weight:700;border-radius:6px}
  .controls{display:flex;gap:8px;align-items:center;margin-top:8px}
  small{color:#666}
</style>
</head>
<body>
  <h1>Gangtay — Stable Auto Play (dedupe + debug)</h1>
  <p class="muted">Tap <strong>Enable audio & Start polling</strong> once; if blocked, tap <strong>Manual Play</strong>. Use <strong>Debug fetch+decode</strong> to diagnose MP3 access / CORS / decode errors. New: payload duplicates (same index/text) are ignored to stop spam.</p>

  <label>1) T1.TXT (site root /T1.TXT or upload local)</label>
  <div class="row">
    <input type="file" id="fileInput" accept=".txt">
    <button id="reloadTxt">Try fetch /T1.TXT</button>
  </div>
  <div id="txtInfo" class="muted">Trying to fetch /T1.TXT ...</div>

  <label>2) Audio base path</label>
  <input id="audioBase" type="text" value="/audio/" />

  <label>3) Firebase message URL</label>
  <input id="firebaseUrl" type="url" value="https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json" />

  <div class="row">
    <button id="enableBtn">Enable audio & Start polling</button>
    <button id="stopBtn" disabled>Stop polling</button>
    <button id="previewBtn">Preview 0001</button>
    <button id="manualPlay" class="bigManual" style="display:none">Manual Play (tap once)</button>
  </div>

  <label>Volume (gain)</label>
  <div class="controls">
    <input id="gainSlider" type="range" min="0.2" max="4.0" step="0.05" value="1.2">
    <div id="gainVal">Gain x1.20</div>
  </div>

  <div style="margin-top:8px;">
    <label>Debug utilities</label>
    <div class="row">
      <input id="testFilename" type="text" value="0002.mp3" style="width:160px" />
      <button id="debugFetch">Debug: fetch+decode test (0002)</button>
      <button id="debugFetchCustom">Debug: fetch+decode custom</button>
      <button id="clearLog">Clear log</button>
      <button id="clearQueue">Clear queue</button>
    </div>
    <small>Debug will fetch <code>/audio/&lt;filename&gt;</code> and try decode+play. Clear queue removes any queued plays.</small>
  </div>

  <div id="status">Status: idle</div>
  <div id="log"></div>

<script>
/* Stable Auto Play page
 - Deduplicate by payload content (ignore ts) to avoid repeat spam
 - Deduplicate queued items (no duplicates)
 - Unlock strategies: tone + htmlAudio; Manual Play & page-tap supported
 - Debug fetch+decode button logs HTTP/CORS/decode results
*/

const FIREBASE_DEFAULT = "https://gangtay-f1efe-default-rtdb.asia-southeast1.firebasedatabase.app/message.json";
const POLL_INTERVAL_MS = 1000;

const fileInput = document.getElementById('fileInput');
const reloadTxtBtn = document.getElementById('reloadTxt');
const txtInfo = document.getElementById('txtInfo');
const audioBaseEl = document.getElementById('audioBase');
const firebaseUrlEl = document.getElementById('firebaseUrl');
const enableBtn = document.getElementById('enableBtn');
const stopBtn = document.getElementById('stopBtn');
const previewBtn = document.getElementById('previewBtn');
const manualBtn = document.getElementById('manualPlay');
const gainSlider = document.getElementById('gainSlider');
const gainVal = document.getElementById('gainVal');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
const debugFetchBtn = document.getElementById('debugFetch');
const debugFetchCustomBtn = document.getElementById('debugFetchCustom');
const testFilenameInput = document.getElementById('testFilename');
const clearLogBtn = document.getElementById('clearLog');
const clearQueueBtn = document.getElementById('clearQueue');

let lines = [];
let pollHandle = null;
let lastPayloadKey = null; // dedupe by payload content (ignores ts)
let audioCtx = null;
let masterGain = null;
let currentAudio = null;
let pendingQueue = []; // [{key:'i:25'|'t:xin chao', type:'index'|'text', value:...}]
let pendingSet = new Set(); // set of keys currently queued
let unlocked = false;

function nowLabel(){ return new Date().toLocaleTimeString(); }
function log(msg){ logEl.textContent = `[${nowLabel()}] ${msg}\n` + logEl.textContent; }
function setStatus(s){ statusEl.textContent = 'Status: ' + s; log(s); }
function pad4(n){ return String(n).padStart(4,'0'); }

/* ---------------- T1.TXT ---------------- */
async function fetchRemoteTxt(){
  setStatus('Fetching /T1.TXT ...');
  try {
    const r = await fetch('/T1.TXT', { cache: 'no-store' });
    if (!r.ok) { setStatus('/T1.TXT not found (HTTP ' + r.status + ')'); return false; }
    const txt = await r.text();
    parseTxt(txt);
    setStatus(`Loaded /T1.TXT (${lines.length} entries)`);
    return true;
  } catch (e) {
    setStatus('Fetch /T1.TXT failed: ' + e.message);
    return false;
  }
}
function parseTxt(txt){
  const raw = txt.split(/\r?\n/);
  lines = raw.map(l=>l.trim()).filter(l=>l.length>0);
  log('Parsed lines: ' + lines.length);
}
fileInput.addEventListener('change', async(ev)=>{ const f=ev.target.files && ev.target.files[0]; if(!f) return; setStatus('Reading local ' + f.name); try{ const t = await f.text(); parseTxt(t); setStatus('Loaded local '+f.name+' ('+lines.length+' lines)'); }catch(e){ setStatus('Read failed: '+e.message); }});
reloadTxtBtn.addEventListener('click', fetchRemoteTxt);

/* ---------------- WebAudio + gain ---------------- */
function createAudioCtxIfNeeded(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = parseFloat(gainSlider.value || 1.0);
  masterGain.connect(audioCtx.destination);
  log('AudioContext created, gain=' + masterGain.gain.toFixed(2));
}
gainSlider.addEventListener('input', ()=>{ const v = parseFloat(gainSlider.value); gainVal.textContent = `Gain x${v.toFixed(2)}`; if(masterGain && audioCtx) masterGain.gain.setValueAtTime(v, audioCtx.currentTime); });

/* ---------------- Unlock helpers ---------------- */
async function unlockWithTone(){
  try {
    createAudioCtxIfNeeded();
    if (audioCtx.state === 'running') { unlocked = true; return true; }
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'sine'; osc.frequency.value = 880;
    g.gain.value = 0.0001;
    osc.connect(g); g.connect(masterGain);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.linearRampToValueAtTime(0.08, now + 0.01);
    osc.start(now);
    g.gain.linearRampToValueAtTime(0.0001, now + 0.18);
    osc.stop(now + 0.19);
    try { await audioCtx.resume(); } catch(e){}
    await new Promise(r => setTimeout(r, 250));
    if (audioCtx.state === 'running') { unlocked = true; log('Unlocked (tone)'); return true; }
    log('unlockWithTone: state=' + audioCtx.state);
    return false;
  } catch (e) {
    console.warn('unlockWithTone err', e);
    return false;
  }
}
async function unlockWithHtmlAudio(){
  try {
    createAudioCtxIfNeeded();
    const a = new Audio();
    a.muted = true;
    try { await a.play(); } catch(e){}
    await new Promise(r => setTimeout(r, 50));
    if (audioCtx && audioCtx.state === 'running') { unlocked = true; log('Unlocked (html audio)'); return true; }
    return false;
  } catch(e) { console.warn('unlockWithHtmlAudio err', e); return false; }
}
async function tryUnlockSequence(){
  if (unlocked) return true;
  if (await unlockWithTone()) return true;
  if (await unlockWithHtmlAudio()) return true;
  return false;
}

/* ---------------- Playback helpers ---------------- */
function makeAudioElement(url){
  createAudioCtxIfNeeded();
  const a = new Audio(url);
  a.crossOrigin = 'anonymous';
  try {
    if (currentAudio && currentAudio._mediaSource) try { currentAudio._mediaSource.disconnect(); } catch(e){}
    const ms = audioCtx.createMediaElementSource(a);
    ms.connect(masterGain);
    a._mediaSource = ms;
  } catch(e) {
    console.warn('createMediaElementSource failed', e);
    a.volume = Math.min(1.0, parseFloat(gainSlider.value || 1.0));
  }
  return a;
}
async function tryPlayElement(el){
  try {
    if (audioCtx && audioCtx.state === 'suspended') try { await audioCtx.resume(); } catch(e){}
    await el.play();
    return true;
  } catch(e) {
    console.warn('play rejected', e);
    return false;
  }
}
async function fetchAndPlayBuffer(url){
  try {
    createAudioCtxIfNeeded();
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) throw new Error('fetch status ' + r.status);
    const ab = await r.arrayBuffer();
    const buf = await audioCtx.decodeAudioData(ab);
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    src.connect(masterGain);
    if (audioCtx.state === 'suspended') try { await audioCtx.resume(); } catch(e){}
    src.start(0);
    await new Promise(r => setTimeout(r, Math.max(300, buf.duration*1000 + 100)));
    return true;
  } catch(e) { console.warn('fetchAndPlayBuffer failed', e); return false; }
}

/* ---------------- Queue & dedupe ---------------- */
function makePayloadKey(obj) {
  if (!obj) return null;
  if (typeof obj.index === 'number') return 'i:' + obj.index;
  const t = (typeof obj.text === 'string') ? obj.text : (typeof obj.message === 'string' ? obj.message : null);
  if (t) return 't:' + t.trim().toLowerCase();
  return null;
}
async function playFileByIndex(idx){
  if (idx <= 0) { setStatus('Invalid index'); return false; }
  const name = pad4(idx) + '.mp3';
  let base = audioBaseEl.value.trim() || '/audio/';
  if (!base.endsWith('/')) base += '/';
  const url = (base.startsWith('http') ? base : base) + name + '?ts=' + Date.now();
  // do not spam logs if same request repeated rapidly; log only when new or queued
  setStatus('Play request: ' + name + ' → ' + url);
  try {
    if (currentAudio) { try { currentAudio.pause(); currentAudio.src=""; } catch(e){} currentAudio=null; }
    const a = makeAudioElement(url);
    currentAudio = a;
    const ok = await tryPlayElement(a);
    if (ok) {
      a.onended = ()=> setStatus('Finished ' + name);
      a.onerror = ()=> setStatus('Audio element error ' + name);
      return true;
    }
    // blocked -> queue if not already queued
    const key = 'i:' + idx;
    if (!pendingSet.has(key)) {
      pendingQueue.push({key, type:'index', value: idx});
      pendingSet.add(key);
      log('Queued (blocked): ' + key);
    } else {
      log('Already queued (skipping duplicate): ' + key);
    }
    showManual();
    return false;
  } catch(e) {
    console.warn('play exception', e);
    const ok2 = await fetchAndPlayBuffer(url);
    if (!ok2) {
      const key = 'i:' + idx;
      if (!pendingSet.has(key)) {
        pendingQueue.push({key, type:'index', value: idx});
        pendingSet.add(key);
        log('Queued after fallback fail: ' + key);
      }
      showManual();
      return false;
    } else {
      setStatus('Played via buffer ' + name);
      return true;
    }
  }
}
function findIndexForText(text){
  if (!text) return -1;
  const k = text.trim().toLowerCase();
  for (let i=0;i<lines.length;i++){
    if ((lines[i]||'').toLowerCase() === k) return i+1;
  }
  return -1;
}
async function handleMessageObject(obj){
  if (!obj) return;
  const payloadKey = makePayloadKey(obj);
  if (!payloadKey) return;
  // dedupe by payload content (ignore ts)
  if (payloadKey === lastPayloadKey) {
    // nothing new content-wise — skip (prevents spam if only ts changed)
    // we still log a minimal message
    log('Ignored duplicate payload content: ' + payloadKey);
    return;
  }
  // new payload: update last key and process
  lastPayloadKey = payloadKey;
  if (payloadKey.startsWith('i:')) {
    const idx = parseInt(payloadKey.slice(2), 10);
    await playFileByIndex(idx);
    return;
  }
  // text case
  const text = obj.text || obj.message || '';
  const idx = findIndexForText(text);
  if (idx > 0) {
    await playFileByIndex(idx);
  } else {
    log('Text not found: "' + text + '" — queued for manual handling');
    const key = 't:' + text.trim().toLowerCase();
    if (!pendingSet.has(key)) {
      pendingQueue.push({key, type:'text', value: text});
      pendingSet.add(key);
    } else {
      log('Text already queued, skipping duplicate');
    }
    showManual();
  }
}

async function flushPending(){
  while (pendingQueue.length > 0) {
    const it = pendingQueue.shift();
    pendingSet.delete(it.key);
    if (it.type === 'index') {
      log('Flushing queued index ' + it.value);
      await playFileByIndex(it.value);
      await new Promise(r=>setTimeout(r,250));
    } else {
      log('Flushing queued text "' + it.value + '"');
      const idx = findIndexForText(it.value);
      if (idx > 0) { await playFileByIndex(idx); await new Promise(r=>setTimeout(r,250)); }
      else log('Queued text still not found: ' + it.value);
    }
  }
}

/* ---------------- Polling ---------------- */
async function pollOnce(){
  const url = firebaseUrlEl.value.trim() || FIREBASE_DEFAULT;
  try {
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) { setStatus('Firebase fetch failed: ' + r.status); return; }
    const j = await r.json();
    // build payload key and compare to lastPayloadKey inside handleMessageObject, so here we only call handler
    await handleMessageObject(j);
  } catch(e) { console.warn('poll error', e); setStatus('Poll error: ' + (e.message||e)); }
}

/* ---------------- UI & events ---------------- */
function showManual(){ manualBtn.style.display = 'inline-block'; manualBtn.focus(); }
function hideManual(){ manualBtn.style.display = 'none'; }
clearQueueBtn.addEventListener('click', ()=> { pendingQueue = []; pendingSet.clear(); log('Cleared queued items'); });

enableBtn.addEventListener('click', async ()=>{
  setStatus('Enable pressed — attempting audible unlock...');
  document.addEventListener('touchstart', firstGesture, {passive:true});
  document.addEventListener('click', firstGesture);
  const ok = await tryUnlockSequence();
  if (!ok) {
    setStatus('Audio locked — please tap Manual Play or tap page once. Polling will run but playback is blocked until unlock.');
    showManual();
    if (!pollHandle) { pollHandle = setInterval(pollOnce, POLL_INTERVAL_MS); setStatus('Polling started (playback blocked)'); enableBtn.disabled = true; stopBtn.disabled = false; }
    return;
  }
  setStatus('Unlocked — starting poll & flushing queue');
  if (!pollHandle) { pollHandle = setInterval(pollOnce, POLL_INTERVAL_MS); enableBtn.disabled=true; stopBtn.disabled=false; }
  await flushPending();
});
stopBtn.addEventListener('click', ()=> { if (pollHandle) { clearInterval(pollHandle); pollHandle=null; setStatus('Polling stopped'); enableBtn.disabled=false; stopBtn.disabled=true; } });
previewBtn.addEventListener('click', ()=> { createAudioCtxIfNeeded(); playFileByIndex(1); });

manualBtn.addEventListener('click', async ()=> {
  setStatus('Manual Play tapped — attempting unlock...');
  const ok = await tryUnlockSequence();
  if (ok) { setStatus('Unlocked (manual). Flushing queue...'); hideManual(); await flushPending(); }
  else setStatus('Unlock failed — try tapping page or check site permissions.');
});

function firstGesture(e){
  document.removeEventListener('touchstart', firstGesture, {passive:true});
  document.removeEventListener('click', firstGesture);
  log('Detected page gesture — attempting unlock');
  tryUnlockSequence().then(ok=>{
    if (ok) { setStatus('Unlocked via gesture. Flushing queue...'); hideManual(); flushPending().catch(e=>console.warn(e)); }
    else { setStatus('Gesture did not unlock; press Manual Play'); showManual(); }
  });
}

/* ---------------- Debug fetch+decode ---------------- */
async function debugFetchDecodeOnce(filename) {
  const base = audioBaseEl.value.trim() || '/audio/';
  const name = (filename || testFilenameInput.value || '0002.mp3').trim();
  let baseWithSlash = base;
  if (!baseWithSlash.endsWith('/')) baseWithSlash = baseWithSlash + '/';
  const url = (baseWithSlash.startsWith('http') ? baseWithSlash : baseWithSlash) + name + '?ts=' + Date.now();
  log('Debug fetch -> ' + url);
  try {
    const r = await fetch(url, { cache: 'no-store' });
    log('HTTP status: ' + r.status);
    if (!r.ok) { log('Fetch failed with status ' + r.status); return; }
    const ab = await r.arrayBuffer();
    log('Fetched bytes: ' + ab.byteLength);
    createAudioCtxIfNeeded();
    try { await audioCtx.resume(); } catch(e){ log('audioCtx.resume() failed: '+e); }
    let buf;
    try {
      buf = await audioCtx.decodeAudioData(ab);
      log('Decoded audio duration (s): ' + buf.duration.toFixed(3));
    } catch(decodeErr) {
      log('decodeAudioData failed: ' + (decodeErr && decodeErr.message ? decodeErr.message : decodeErr));
      console.warn('decode error', decodeErr);
      return;
    }
    const src = audioCtx.createBufferSource();
    const g = audioCtx.createGain();
    g.gain.value = parseFloat(gainSlider.value || 1.0);
    src.buffer = buf;
    src.connect(g); g.connect(audioCtx.destination);
    try { src.start(); log('Debug playback started via AudioBufferSourceNode'); } catch(playErr){ log('Debug playback start failed: ' + (playErr && playErr.message ? playErr.message : playErr)); console.warn(playErr); }
  } catch(err) { log('Debug fetch/ decode error: ' + (err && err.message ? err.message : err)); console.error(err); }
}

debugFetchBtn.addEventListener('click', ()=> debugFetchDecodeOnce('0002.mp3'));
debugFetchCustomBtn.addEventListener('click', ()=> { const fn = testFilenameInput.value.trim() || '0002.mp3'; debugFetchDecodeOnce(fn); });
clearLogBtn.addEventListener('click', ()=> logEl.textContent = '');

/* ---------------- Init ---------------- */
(async function init(){
  firebaseUrlEl.value = firebaseUrlEl.value || FIREBASE_DEFAULT;
  const ok = await fetchRemoteTxt();
  if (!ok) txtInfo.textContent = '/T1.TXT not found on server — upload local file or add to site.';
  else txtInfo.textContent = `Loaded /T1.TXT (${lines.length} entries)`;
  setStatus('Ready. Click Enable or tap the page when queued plays appear.');
})();
</script>
</body>
</html>
